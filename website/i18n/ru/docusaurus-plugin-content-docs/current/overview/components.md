---
sidebar_position: 3
---
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import Components from '../img/components.png'
import Agent from '../img/agent.png'
import Aggregator from '../img/aggregator.png'
import ShardsReplicas from '../img/shards-replicas.png'
import RealHist from '../img/real-hist.png'
import OddEven from '../img/odd-even.png'
import IngressProxy from '../img/ingress-proxy.png'
import AgentParameters from '../img/agent-parameters.png'
import Mapping from '../img/mapping.png'
import MappingCached from '../img/mapping-cached.png'

# Компоненты

Основные компоненты StatsHouse изображены на рисунке:

<img src={Components} width="1000"/>

А вот их описания:
<!-- TOC -->
* [Агент](#агент)
  * [Получение данных по UDP](#получение-данных-по-udp)
  * [Установка агентов в подах Kubernetes](#установка-агентов-в-подах-kubernetes)
* [Агрегатор](#агрегатор)
  * [Актуальные и "исторические" данные](#актуальные-и-исторические-данные)
  * [Работа при отказе агрегатора](#работа-при-отказе-агрегатора)
* [База данных](#база-данных)
* [API](#api)
* [Пользовательский интерфейс (UI)](#пользовательский-интерфейс-ui)
* [Прокси](#прокси)
* [Сервис метаданных](#сервис-метаданных)
  * [Бюджет на создание значений тегов](#бюджет-на-создание-значений-тегов)
    * [_Тег String top_ (Топ строк)](#тег-string-top-топ-строк)
    * ["Сырые" (_Raw_) теги](#сырые-raw-теги)
  * [Бюджет на создание метрик](#бюджет-на-создание-метрик)
<!-- TOC -->

## Агент

Агент
* валидирует метрику (например, проверяет, существует ли она),
* [агрегирует](concepts.md#агрегация) данные в пределах секунды,
* шардирует данные
* и отправляет их на агрегаторы.

<img src={Agent} width="500"/>

Если агрегаторы недоступны, агент хранит данные на локальном диске в пределах квоты и отправляет их позже.

Агент получает данные по протоколу [UDP](https://en.wikipedia.org/wiki/User_Datagram_Protocol). Поддерживаются 
следующие форматы:
* [JSON](https://www.json.org/json-en.html),
* [Protocol Buffers](https://protobuf.dev),
* [MessagePack](https://msgpack.org),
* [TL](https://core.telegram.org/mtproto/TL).

:::note
Агенты поддерживают IPv6.
:::

### Получение данных по UDP

StatsHouse получает данные по UDP в форматах MessagePack, Protocol Buffers, JSON и TL — они семантически
идентичны. Формат определяется автоматически по первым байтам в пакете.

Посмотрите схемы для [TL](https://github.com/VKCOM/statshouse/blob/master/internal/data_model/public.tl), 
MessagePack и [Protocol Buffers](https://github.com/VKCOM/statshouse/blob/master/internal/receiver/statshouse.proto):

<Tabs>

<TabItem value="TL" label="TL">

```
---types---

statshouse.metric#3325d884 fields_mask:#
name:    string
tags:    (dictionary string)
counter: fields_mask.0?double
ts:      fields_mask.4?#               // UNIX timestamp UTC
value:   fields_mask.1?(vector double)
unique:  fields_mask.2?(vector long)

= statshouse.Metric;

---functions---

// for smooth JSON interoperability, first byte of tag must not be 0x5b or 0x7b ("[" or "{")
// for smooth MessagePack interoperability, first byte of tag must be less than 0x80
// for smooth ProtoBuf interoperability, first byte must be as large as possible.

@write statshouse.addMetricsBatch#56580239 fields_mask:# metrics:(vector statshouse.metric) = True;
```
</TabItem>

<TabItem value="MessagePack" label="MessagePack">

```{
  metrics: [
    {
      ts:   1670673392,     # uint32, UNIX timestamp in seconds (optional)
      name: "foobar",       # string([a-zA-Z][a-zA-Z0-9_]*), metric name
      tags: {
        "env":              # string([a-zA-Z][a-zA-Z0-9_]*), tag name
          "production"      # string(printable UTF-8),       tag value
      },
      counter: 100500.1,    # float64,        number of observed events
      value:   [0.7],       # array(float64), observed values array
      unique:  [591068825], # array(int64),   observed IDs array
    }
  ]
}
```

</TabItem>

<TabItem value="Protocol Buffers" label="Protocol Buffers">

```
syntax = "proto3";
package statshouse;

option go_package = "github.com/VKCOM/statshouse/internal/receiver/pb";

message Metric {
    string              name    = 1;
    map<string, string> tags    = 2;
    double              counter = 3;
    uint32              ts      = 4;  // UNIX seconds UTC
    repeated double     value   = 5;
    repeated int64      unique  = 6;
}

message MetricBatch {
    repeated Metric metrics = 13337;  // to autodetect packet format by first bytes
}

// to compile
// sudo apt-get install libprotobuf-dev
// go install google.golang.org/protobuf/cmd/protoc-gen-go
// ~/go/src/github.com/VKCOM/statshouse$ protoc -I=internal/receiver --go_out=../../../../.. statshouse.proto

// to compile if proto3 format not supported, for example by protocute

// 1. comment out line: option go_package = "github.com/VKCOM/statshouse/internal/receiver/pb";
// 2. add
// message MapFieldEntry {
//   optional string key = 1;
//   optional string value = 2;
// }
// 3. replace Metric with
// message Metric {
// string              name    = 1;
// map<string, string> tags    = 2;
// double              counter = 3;
// uint32              ts      = 4;  // UNIX seconds UTC
// repeated double     value   = 5;
// repeated int64      unique  = 6;
// }
// 4. ./protocute --cpp_out=. ~/go/src/github.com/VKCOM/statshouse/internal/receiver/statshouse.proto
```

</TabItem>

</Tabs>

Пакет — это объект, содержащий массив метрик:

```
    {"metrics":[ ... ]}

```

Каждый элемент этого массива представляет собой объект с полями:

```
{
 "name":"rpc_call_latency",  // metric name (obligatory)
 "tags":{"protocol": "tcp"}, // tags
 "ts": 1630000000,           // timestamp; 0 and no timestamp means "now"
 "counter": 6,               // event counter
 "value": [1, 2.0, -3.0],    // values if any (do not use with "unique")
 "unique": [15, 18, -60]     // unique counters if any (do not use with "value")
}
```

Например, можно отправить такой пакет:

```
{"metrics":[
{"name":"rpc_call_latency",
 "tags":{"protocol": "tcp"},
 "value": [15, 18, 60]},
{"name": "rpc_call_errors",
 "tags":{"protocol": "udp","error_code": "-3000"},
 "counter": 5}
]}
{"metrics":[
{"name": "external_landings",
 "tags":{"country": "ru","gender": "m","skey": "lenta.ru"},
 "counter": 1}
]}
```

Обратите внимание на требования к использованию форматов.
* Для TL: тело пакета должно быть Boxed-сериализацией объекта `statshouse.addMetricsBatch`.
* Для JSON: первым символом должна быть фигурная скобка `{` (для корректного определения формата).
* Для Protocol Buffers: не добавляйте поля в объект `MetricBatch` (для корректного определения формата).

### Установка агентов в подах Kubernetes

Не устанавливайте агенты в подах Kubernetes.
Мы настоятельно рекомендуем устанавливать их только на реальных серверах (обязательно указывайте порт `13337`).

Число агентов не должно колебаться.
Агенты отправляют агрегаторам посекундные отчёты. Если число агентов постоянно, значит, они подключены к 
агрегаторам. Из-за остановки подов число агентов уменьшается, и срабатывает главный алерт StatsHouse.

<details>
    <summary>Подробнее</summary>
  <p>При шифровании в VK RPC для вывода эфемерных ключей используются удалённый и локальный IP-адреса соединений (как их 
видят клиент и сервер).
Маршрутизация пакетов от одного адаптера к другому через брандмауэр делает установление соединений невозможным.
Для соединения компонентов в таком случае понадобится создать виртуальные сетевые адаптеры и соединить
их средствами Linux network namespaces.</p>
</details>

## Агрегатор

Агрегирует посекундные данные от всех агентов и вставляет результат в базу данных ClickHouse.

<img src={Aggregator} width="500"/>

Число агрегаторов должно быть равно числу шардов ClickHouse с репликами. Каждый агрегатор вставляет 
данные в реплику базы данных, развёрнутую на той же машине. Например: 3 шарда × 3 реплики = 9 агрегаторов.

<img src={ShardsReplicas} width="700"/>

### Актуальные и "исторические" данные

У агрегатора есть два режима работы:
* работа с актуальными данными,
* работа с "историческими" данными. Данные считаются "историческими", если их не удалось отправить сразу после создания.

Вставка актуальных данных — приоритет для агрегатора.

<img src={RealHist} width="800"/>

Представьте: возник сбой. Долгое время вставить данные было невозможно, затем система восстановилась.
StatsHouse немедленно начинает вставлять актуальные данные. А вот "исторические" данные StatsHouse вставит при 
первой возможности, если только это не помешает вставке актуальных данных.

<details>
    <summary>Подробнее</summary>
  <p>Вставка актуальных данных имеет приоритет, поскольку "исторические" данные вставляются в базу ClickHouse 
довольно медленно.</p>

<p>**Актуальные данные**</p>

<p>Агрегатор позволяет агентам вставлять данные за последние 5 минут — это "короткое" окно вставки (его можно 
настроить). Если агент не успел вставить данные вовремя, он отправит данные как "исторические".</p>

<p>Для каждой актуальной секунды агрегатор хранит контейнер со статистикой. В этот контейнер агрегируются данные от 
агентов. Как только наступает следующая секунда, агрегатор вставляет данные для неё (из "короткого" окна) 
в базу. А агенты получают ответ с результатом вставки.</p>

<p>"Короткое" окно распространяется на две секунды в будущее, чтобы нормально работали агенты, у которых часы немного 
спешат.</p>

<p>**"Исторические" данные**</p>

<p>Агрегатор позволяет агентам вставлять данные за последние 48 часов — это "длинное" окно вставки (его можно
настроить).</p>

<p>Если данные старше 48 часов, StatsHouse записывает метастатистику и выбрасывает этот фрагмент данных. Агент получает ответ `OK`.</p>

<p>Агрегация между хостами очень важна, поэтому StatsHouse делает всё возможное, чтобы она состоялась:
<li>каждый агент делает запрос на вставку нескольких десятков "исторических" секунд, начиная с самой "старой";</li>
<li>агрегатор получает эти запросы и выбирает самую "старую" секунду;</li>
<li>он агрегирует данные, вставляет их в базу данных и отправляет ответ;</li>
<li>затем снова выбирает "самую старую" секунду и т.д.</li></p>

<p>Этот алгоритм помогает наиболее удалённым ("старым") секундам оказаться рядом с самыми "новыми". Он делает 
возможным агрегирование исторических данных и помогает вставлять данные одновременно.</p>
</details>

### Работа при отказе агрегатора

Если агрегатор недоступен или отвечает с ошибкой, агент хранит данные на локальном диске.
Хранение данных на диске ограничено в байтах. Оно также ограничено по времени — в пределах "длинного"
(48-часового) окна вставки.

<details>
    <summary>Подробнее</summary>
  <p>**Распределение данных между репликами**</p>

  <p>Если доступ к диску нежелателен или невозможен, можно запустить агент с пустым аргументом `--cache-dir`.
StatsHouse не будет использовать диск. "Исторические" данные будут храниться в памяти, пока агрегаторы
недоступны, т. е. в течение нескольких минут.</p>

<p>Если агрегатор недоступен, агенты отправляют данные репликам.
Данные распределяются в соответствии с порядковыми номерами секунд: чётные секунды отправляются в одну из реплик,
нечётные — в другую. Таким образом, нагрузка на обе реплики увеличивается на 50 %. Это одна из причин, по которой 
StatsHouse записывает данные ровно в три реплики ClickHouse.</p>

  <p>**Предотвращение двойной вставки**</p>

  <p>Если агрегатор отвечает с ошибкой, агент отправляет данные другому агрегатору (другой реплике) на другом
хосте. Для дедупликации нужно использовать алгоритм консенсуса, а это довольно сложно.</p>

  <p>В StatsHouse основной и резервный агрегаторы могут вставлять данные от одного и того же агента в одну и ту же секунду.
Это происходит редко, и для такого случая мы отслеживаем двойные вставки с помощью метаметрики `__heartbeat_version`, 
которая показывает _количество агентов, отправляющих данные в текущую секунду_. Чтобы эта метаметрика была 
стабильной при нормальной работе агрегаторов, агенты отправляют данные каждую секунду, даже если в данный момент нет 
реальных пользовательских данных.</p>
</details>

## База данных

В базе данных [ClickHouse](https://clickhouse.com) хранятся [агрегированные](concepts.md#агрегация) данные метрик.

StatsHouse вставляет данные в таблицу ClickHouse, которая определяется следущим образом:

```
CREATE TABLE statshouse2_value_1s (
    `time`           DateTime,
    `metric`         Int32,
    `tag0`           Int32,
    `tag1`           Int32,
...
    `tag15`          Int32,
    `stag`           String,
    `count`          SimpleAggregateFunction(sum, Float64),
    `min`            SimpleAggregateFunction(min, Float64),
    `max`            SimpleAggregateFunction(max, Float64),
    `sum`            SimpleAggregateFunction(sum, Float64),
    `max_host`       AggregateFunction(argMax, Int32, Float32), 
    `percentiles`    AggregateFunction(quantilesTDigest(0.5), Float32),
    `uniq_state`     AggregateFunction(uniq, Int64)
) ENGINE = *MergeTree
PARTITION BY toDate(time) ORDER BY (metric, time,tag0,tag1, ...,tag15, stag);
```

Если для метрики не включена запись [перцентилей](../guides/edit-metrics.md#перцентили-percentiles) или метрика не имеет тип
[_unique counter_](../guides/design-metric.md#счётчики-уникальных-значений-тип-unique), соответствующие столбцы таблицы (`percentiles` или 
`uniq_state`) будут пустыми.

Если метрика представляет собой простой [счётчик](../guides/design-metric.md#счётчики-тип-counter), все столбцы будут пустыми, 
кроме `count`.  Колонка `stag` не пуста, только если в метрике используется 
[тег String top](../guides/design-metric.md#тег-string-top-топ-строк).

Чтобы получить данные за интервал, превышающий секунду, StatsHouse агрегирует данные и создает поминутные
и часовые агрегаты.

<details>
    <summary>Подробнее</summary>
  <p>Данные распределяются между шардами ClickHouse с помощью хэша `metric, key0, ... , key15`.
Если в метрике используется несколько тегов, то данные, относящиеся к конкретному тегу (например, `"protocol": 
"tcp"`), обычно хранятся на разных шардах. Чтобы получить полную статистику, всегда нужно делать _распределённые 
запросы_ ко всему набору шардов.</p>

  <p>Почему это так?
Набор значений тегов имеет определенную кардинальность: существует конечное число возможных комбинаций значений тегов для
метрики. Если мы достигаем предела кардинальности, то есть отправляем все эти комбинации значений тегов, 
объём данных перестает увеличиваться из-за агрегации — StatsHouse объединяет события с одним и тем же сочетанием 
значений тегов.</p>

  <p>Чтобы хранить выборку данных для всей метрики, каждый шард должен хранить столько рядов, сколько существует 
комбинаций значений тегов для метрики, а не долю, пропорциональную числу шардов.</p>

  <p>StatsHouse не использует буферные таблицы: каждый агрегатор вставляет данные раз в секунду в 
incoming-таблицу. Данные фильтруются по `time` в пределах окна приёма (48 часов) и копируются через 
материализованное представление. Это защищает StatsHouse от вставки "мусорных" данных. В противном случае 
ClickHouse должен был бы читать данные не из одного или двух шардов, а из всех.</p>

  <p>Шард должен иметь три или более реплик. Агрегаторы вставляют данные в первые три реплики.
Остальные являются read-only репликами — их можно использовать, чтобы масштабировать нагрузку на чтение.</p>

  <p>Количество шардов может быть любым. Для предотвращения неправильной конфигурации и непоследовательного 
шардирования, которое может привести к резкому увеличению объёма данных из-за слабой агрегации, агенты отправляют 
агрегатору номер реплики шарда. Если агрегатор "видит", что данные предназначаются не ему, то отвечает ошибкой. 
Этот же номер позволяет прокси направить данные нужному агрегатору.</p>
</details>

## API

Ознакомьтесь со спецификацией [OpenAPI](../guides/openapi.md) для StatsHouse.

Тонкий API-клиент позволяет StatsHouse отправлять эффективные запросы к базе данных.
Сервис кэширует данные, чтобы минимизировать нагрузку на базу данных. Мы ограничиваем получение данных 
непосредственно из ClickHouse, поскольку неэффективные запросы могут негативно повлиять на кластер ClickHouse.

## Пользовательский интерфейс (UI)

Пользовательский интерфейс получает данные из StatsHouse API и отображает данные метрик в виде графика.

## Прокси

Прокси получает данные от агентов, которые находятся за пределами защищённого периметра
(т.е. за пределами датацентра) и отправляет их в агрегаторы.

Агенты и агрегаторы используют протокол TL/RPC с ключом шифрования датацентра. Таким образом, агенты, находящиеся за 
пределами датацентра, не могут подключаться к агрегаторам напрямую, поскольку это требовало бы раскрытия или 
копирования ключа для внешних систем.

Для внешних подключений у прокси есть отдельный набор ключей шифрования. Чтобы отозвать ключ шифрования,
необходимо удалить его из конфигурации прокси.

Проекси не имеет состояния. Чтобы снизить вероятность атаки, он проксирует только подмножество TL/RPC
типов запросов, используемых агрегаторами.

Требуется ровно три прокси. Каждый из них является прокси для соответствующей реплики шарда.
Недоступный прокси эквивалентен выходу из строя реплики одного шарда и не влияет на работу StatsHouse.

<img src={IngressProxy} width="600"/>

Три экземпляра прокси имитируют агрегаторы. Можно установить ещё один уровень проксирования за имеющимися
прокси. Этот уровень будет использовать предыдущие прокси в качестве агрегаторов.

Не рекомендуется устанавливать прокси в подах Kubernetes.

<details>
    <summary>Подробнее</summary>
  <p>**Криптоключи**</p>

  <p>StatsHouse использует протокол VK RPC с (опциональным) шифрованием для общения компонентов.</p>

  <p>Согласно протоколу VK RPC криптоключ является одновременно логином для получения доступа и секретом для получения 
эфемерных ключей соединения. Чтобы установить соединение, клиент должен использовать один из ключей, известных серверу. 
Центральным компонентом системы являются агрегаторы. При запуске они получают единственный "главный" криптоключ 
датацентра.</p>

  <p>Для подключения к агрегаторам агенты должны получить следующие параметры:
<li>`-agg-addr` — адреса первого шарда агрегаторов;</li>
<li>`-aes-pwd-file` — "главный" криптоключ датацентра.</li></p>

  <p>Описанный механизм безопасен только внутри защищённого периметра. Для подключения извне используйте прокси, 
установленный на границе.</p>

  <p>Прокси, стоящий на границе, состоит из двух частей:
<li>RPC-сервера для подключения агентов извне,</li>
<li>RPC-клиента для подключения самого прокси к агрегаторам внутри периметра.</li></p>

  <p>Для прокси необходимо настроить следующие параметры:
<li>`-ingress-external-addr` — внешние адреса прокси-серверов, которые агенты используют для подключения;</li>
<li>`-ingress-addr` — параметр для управления интерфейсами, на которые подключаются агенты;</li>
<li>`-aes-pwd-file` — внутренний криптоключ для отправки данных агрегаторам;</li>
<li>`-ingress-pwd-dir` — набор внешних ключей для агентов с удаленных площадок.</li></p>

  <p>Параметр `-ingress-addr` обычно имеет значение `:8128`, что равнозначно `0.0.0.0:8128`.
Он также может содержать адрес подсети сетевого адаптера, чтобы разрешить подключение только через него. Порт в 
параметре `-ingress-addr` должен совпадать с одним из портов в параметре `-ingress-external-addr`. "Внешняя" часть 
входящего прокси должна быть доступна агентам через эти порты.</p>

  <p>Каждый из этих файлов содержит криптоключ; имя файла игнорируется и считается комментарием. Ключи имеют 
произвольную длину — не менее четырех байт. Первые четыре байта служат для идентификации ключа, поэтому 
они не должны быть одинаковыми.</p>

  <p>Если внешние ключи в папке изменились, перезапустите прокси. Прокси не следит за этой папкой, так как набор 
ключей меняются редко.</p>

  <p>Каждый агент получает один из ключей, указанных у прокси в папке `-ingress-pwd-dir`, в качестве 
параметра `-aes-pwd-file`.</p>
</details>

## Сервис метаданных

Сервис метаданных хранит глобальный маппинг `string`↔`int32`: именно здесь имена метрик и значения тегов, 
которые являются строками, отображаются в целые числа.

StatsHouse предоставляет данные в режиме реального времени. Чтобы гарантировать минимальную 
задержку, StatsHouse отображает строковые значения тегов (а также названия метрик) в `int32`:

```
    'iphone' <=> 12
    'null' <=> 26
```

Этот огромный маппинг общий для всех метрик. Элементы маппинга никогда не удаляются.

Чтобы не допустить неконтролируемого увеличения маппинга, бюджеты на
[создание метрик](#бюджет-на-создание-метрик) и [значений тегов](#бюджет-на-создание-значений-тегов) ограничены.

### Бюджет на создание значений тегов

Чтобы предотвратить неконтролируемый рост маппинга `string`↔`int32`, мы ограничиваем бюджет на создание значений 
тегов до 300 в день. Если бюджет исчерпан, новые строки (значения тегов) можно добавлять в маппинг дважды в час 
(правило настраивается).

При превышении бюджета возникают ошибки типа "mapping flood". Когда бюджет исчерпан и добавлять новые строки в 
маппинг нельзя, StatsHouse вставляет значение `mapping flood` в колонку тега, чтобы не потерять событие целиком.

Чтобы создавать [теги с большим количеством разных значений](../guides/design-metric.md#сколько-значений-тегов-можно-использовать), но 
избежать ошибок `mapping flood`, можно использовать тег 
[String top (Топ строк)](../guides/design-metric.md#тег-string-top-топ-строк) и 
[Raw](../guides/design-metric.md#сырые-raw-теги) теги (теги с "сырыми" значениями).

<img src={Mapping} width="600"/>

Если вам нужны теги с большим количеством значений, которые являются 32-битными числами, (например, тег `user_ID`), 
используйте [Raw](../guides/design-metric.md#сырые-raw-теги) теги, чтобы избежать ошибок `mapping flood`.

Если вам нужен тег с разнообразными строковыми значениями (например, тег `search_request`), используйте 
тег [String top (Топ строк)](#тег-string-top-топ-строк).

#### Тег String top (Топ строк)

Тег _String top_ отличается от других тем, что его значения _не добавляются в маппинг `string`↔`int32`_. Это отдельный
столбец `tag_s` в таблице ClickHouse:

| timestamp | metric           | tag_1                                                           | tag_2                                                         | <text className="orange-text">tag_s</text>                                  | counter   | sum    | min   | max   | 
|-----------|------------------|-----------------------------------------------------------------|---------------------------------------------------------------|-----------------------------------------------------------------------------|-----------|--------|-------|-------|
| 13:45:05  | toy_packets_size | JSON<br/><text className="orange-text">mapped to `int32`</text> | ok<br/><text className="orange-text">mapped to `int32`</text> | my-tag-value<br/><text className="orange-text">NOT mapped to `int32`</text> | 100       | 1300   | 20    | 1200  | 

Поскольку строки, не добавленные в маппинг, занимают много места и дольше читаются, StatsHouse ограничивает их 
количество (например, до сотни). Это ограничение настраивать нельзя. Что же происходит с остальными 
строками, не поместившимися в эту сотню?

:::important
StatsHouse сохраняет только строки с наиболее часто используемыми значениями тега _String top_ — строки с наибольшим 
_счётчиком_. Остальные значения тега _String top_ превращаются в _empty_ и агрегируются.
:::

Как это работает? Посмотрим на примере.
Представим, что ограничение на тег _String top_ равно не сотне, а четырём. А данные для нашей метрики выглядят так:

| timestamp | metric      | tag_1 | tag_2 | <text className="orange-text">tag_s</text> | counter | sum | min | max |
|-----------|-------------|-------|-------|--------------------------------------------|---------|-----|-----|-----|
| 13:45:05  | toy_metric  | ...   | ...   | a                                          | 100     | ... | ... | ... |
| 13:45:05  | toy_mextric | ...   | ...   | b                                          | 3       | ... | ... | ... |
| 13:45:05  | toy_metric  | ...   | ...   | c                                          | 100     | ... | ... | ... |
| 13:45:05  | toy_metric  | ...   | ...   | d                                          | 88      | ... | ... | ... |

Приходят новые данные: строка со значением тега _String top_, равным `e`, и счётчиком, равным `55`.
Механизм _String top_ выбирает значение тега с наименьшим счётчиком (`b` — менее популярный) и превращает его в
_empty_:

| timestamp | metric     | tag_1 | tag_2 | <text className="orange-text">tag_s</text> | counter | sum | min | max |
|-----------|------------|-------|-------|--------------------------------------------|---------|-----|-----|-----|
| 13:45:05  | toy_metric | ...   | ...   | a                                          | 100     | ... | ... | ... |
| 13:45:05  | toy_metric | ...   | ...   | **b** → _empty string_                     | **3**   | ... | ... | ... |
| 13:45:05  | toy_metric | ...   | ...   | c                                          | 100     | ... | ... | ... |
| 13:45:05  | toy_metric | ...   | ...   | d                                          | 88      | ... | ... | ... |
| 13:45:05  | toy_metric | ...   | ...   | **e**                                      | **55**  | ... | ... | ... |

Затем добавляется строка со значением `f` в теге и счётчиком, равным `2`.

| timestamp | metric     | tag_1 | tag_2 | <text className="orange-text">tag_s</text> | counter | sum | min | max |
|-----------|------------|-------|-------|--------------------------------------------|---------|-----|-----|-----|
| 13:45:05  | toy_metric | ...   | ...   | a                                          | 100     | ... | ... | ... |
| 13:45:05  | toy_metric | ...   | ...   | _empty string_                             | 3       | ... | ... | ... |
| 13:45:05  | toy_metric | ...   | ...   | c                                          | 100     | ... | ... | ... |
| 13:45:05  | toy_metric | ...   | ...   | d                                          | 88      | ... | ... | ... |
| 13:45:05  | toy_metric | ...   | ...   | e                                          | 55      | ... | ... | ... |
| 13:45:05  | toy_metric | ...   | ...   | **f** → _empty string_                     | **2**   | ... | ... | ... |

Поскольку значение `f` используется редко (значение счётчика меньше, чем у других), оно тоже превращается в 
_empty_ и агрегируется с предыдущей пустой строкой:

| timestamp | metric     | tag_1 | tag_2 | <text className="orange-text">tag_s</text> | counter | sum | min | max |
|-----------|------------|-------|-------|--------------------------------------------|---------|-----|-----|-----|
| 13:45:05  | toy_metric | ...   | ...   | a                                          | 100     | ... | ... | ... |
| 13:45:05  | toy_metric | ...   | ...   | _empty string_                             | **3+2** | ... | ... | ... |
| 13:45:05  | toy_metric | ...   | ...   | c                                          | 100     | ... | ... | ... |
| 13:45:05  | toy_metric | ...   | ...   | d                                          | 88      | ... | ... | ... |
| 13:45:05  | toy_metric | ...   | ...   | e                                          | 55      | ... | ... | ... |

#### "Сырые" (_Raw_) теги

Если значения тегов изначально являются 32-битными числами, вы можете пометить их как "сырые" (_Raw_),
чтобы избежать переполнения маппинга.
Такие значения тегов (_Raw_) StatsHouse будет воспринимать как `(u)int32` (возможные значения: `-2^31..2^32-1`)
и вставлять в базу ClickHouse, не добавляя в маппинг.
Узнайте, как [настроить "сырые" (_Raw_) теги](../guides/edit-metrics.md#настройка-сырых-raw-тегов).

### Бюджет на создание метрик

Пользователи могут создавать сколько угодно метрик — вручную через пользовательский интерфейс StatsHouse.
Как правило, автоматизировать создание метрик нельзя.

StatsHouse предполагает, что метрик не так много: сотни тысяч. Система не защищёна от 
неконтролируемого роста числа метрик.

:::tip
Если вы переходите на StatsHouse с другой системы мониторинга, обратитесь к администраторам StatsHouse в вашей 
организации, чтобы включить режим автосоздания (по завершении миграции его нужно отключить).
:::

<details>
    <summary>Подробнее</summary>
  <p>**Получение свойств метрики из сервиса метаданных**</p>

  <p>Агрегаторы получают содержание маппинга непосредственно от сервиса метаданных. Агенты работают с маппингом через 
агрегаторы. И агенты, и агрегаторы кэшируют содержимое маппинга в памяти или файле и хранят в течение месяца.</p>

  <p>При первом запуске агенты используют специальный bootstrap-запрос, чтобы получить 100 000 наиболее часто 
используемых строк из маппинга. В противном случае при развертывании большого количества агентов
StatsHouse должен был бы загрузить огромное чилос значений одно за другим. Это заняло бы много времени, в течение 
которого StatsHouse не мог бы записывать данные.</p>

  <p>Агрегаторы используют TL/RPC long polling для получения информации о метриках из сервиса метаданных. Агенты 
используют long polling для получения информации от агрегаторов. Таким образом, все агенты получают 
информацию об изменениях в свойствах метрик практически мгновенно (за секунду).</p>

  <p>**Удаление метрик**</p>

  <p>Удалить метрику нельзя, потому что в базе данных ClickHouse нет эффективного способа сделать это.
StatsHouse использует флаг `visible` для отключения метрики, т.е. для скрытия метрики из списка метрик
(это действие обратимо). Отключение метрики прекращает запись данных для нее в базу данных.</p>
</details>
