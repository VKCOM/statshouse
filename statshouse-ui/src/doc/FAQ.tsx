// Copyright 2022 V Kontakte LLC
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

import React from 'react';
import { useLocation } from 'react-router-dom';

const FAQ = React.memo(function FAQ_(props: { yAxisSize: number }) {
  const { yAxisSize } = props;
  const location = useLocation();

  // update document title
  React.useEffect(() => {
    document.title = `FAQ — StatsHouse`;
  }, []);

  React.useEffect(() => {
    if (location.hash) {
      document.querySelector(location.hash)?.scrollIntoView({ behavior: 'smooth' });
    }
  }, [location.hash]);

  return (
    <div className="container-xl pt-3 pb-3">
      <div className="faq-page d-flex flex-column" style={{ paddingLeft: `${yAxisSize}px`, boxSizing: 'border-box' }}>
        <h5 id="metric-vs-stat">
          Чем метрика отличается от статы <a href="#metric-vs-stat">#</a>
        </h5>
        <p>
          Эти понятия взаимозаменяемы, по историческим причинам внутри ВКонтакте обычно используется "стата". В
          StatsHouse мы везде используем термин "метрика".
        </p>
        <h5 id="create-metric">
          Как создать новую метрику <a href="#create-metric">#</a>
        </h5>
        <p>
          Нажать кнопку рядом с кнопкой FAQ). После создания метрика готова к записи и просмотру данных, обычно стоит
          отредактировать её свойства кнопкой Edit.
        </p>
        <h5 id="metric-kind">
          Что такое тип метрики, какой тип мне нужен <a href="#metric-kind">#</a>
        </h5>
        <ul>
          <li>
            <mark>counter</mark>— простой счётчик, <code>statlogsXCountEvent</code> подсчитает сумму числа событий в
            секунду.
          </li>
          <li>
            <mark>value</mark>— <mark>counter</mark> плюс значение. <code>statlogsXValueEvent</code> подсчитает в
            дополнение к сумме числа событий ещё и минимальное, максимальное, среднее от значений. Значения имеют тип{' '}
            <code>float64</code>.
          </li>
          <li>
            <mark>percentile</mark>— <mark>value</mark> с разбивкой по перцентилям, дорогое удовольствие, так что такой
            тип можно задать только с помощью админа. Записывается идентичным с value образом —{' '}
            <code>statlogsXValueEvent</code>, перцентили будут писаться если в свойствах метрики установлен
            соответствующий тип.
          </li>
          <li>
            <mark>unique</mark>— <mark>counter</mark> плюс кардинальность (уники). <code>statlogsXUniqueCount</code>{' '}
            подсчитает в дополнение к сумме числа событий ещё и оценку количества разных значений. Значения имеют тип{' '}
            <code>int64</code>.
          </li>
          <li>
            <mark>string top</mark>— топ строк. <code>statlogsXStringTop</code> выберет самые популярные строки и
            подсчитает количество каждой, плюс количество невошедших в топ.
          </li>
        </ul>
        <p>
          В новом коде всегда используйте функции семейства <code>statlogsX*</code>, принимающие массив ключей,
          например, <code>statlogsXCountEvent</code>, а не <code>statlogsCountEvent</code>.
        </p>
        <p>
          Все метрики в StatsHouse содержат счётчик событий, так что не нужно писать его отдельно. В данном примере
          первая строчка не нужна, так как <mark>unique</mark> и так содержит число событий:
        </p>
        <pre>
          <code>{`    statlogsCountEvent(self::STATS_KEY, $block, $action, test_getFeedRightAppsBlockGroup($user_id)); // WRONG
    statlogsUniqueCount(self::STATS_USERS_KEY, $user_id, $block, $action, test_getFeedRightAppsBlockGroup($user_id));`}</code>
        </pre>
        <p>
          Лучше так не делать, но разные комбинации ключей могут одной метрики могут записываться функциями для разных
          типов, тогда можно указать тип метрики как <mark>mixed</mark> или <mark>mixed_p</mark> (с записью
          перцентилей). В этом случае система позволит писать и отображать все типы данных для этой метрики. Некоторые
          любят создавать одну метрику для подсистемы, и разбить её на "под-метрики" с помощью разных значений
          <mark>key1</mark>. Можно и так, но тогда тип метрики придётся задать, как <mark>mixed</mark>. Также для такой
          метрики будет выбран единый фактор сэмплирования и будет невозможно задать описания ключей (ведь они скорее
          всего будет зависеть от <mark>key1</mark>). В новом коде <mark>mixed</mark> метрик следует избегать.
        </p>
        <h5 id="data-quality">
          Я выплачиваю комиссии на основе данных статлогов и... <a href="#data-quality">#</a>
        </h5>
        <p>
          Стоп-стоп! Так нельзя. Даже если не произойдёт включения сэмплирования для твоей метрики, система статистики
          это не транзакционная база, здесь нет гарантий доставки, данные могут пропасть или вставиться более одного
          раза.
        </p>
        <p>
          Важная бизнес-логика должна пользоваться каким-то транзакционным движком. События, которые нужно доставить 1
          раз должны сохраняться после генерации в надёжное хранилище (с fsync) на источнике данных, и т.д.
        </p>
        <h5 id="mapping-limits">
          Правда ли что в сутки можно писать только 200 комбинаций ключей? <a href="#mapping-limits">#</a>
        </h5>
        <p>
          Не правда, у нас есть 2 механизма ограничений, первый связан с отображениями строковых значений ключей в
          целые, второй с лимитом записи в базу под каждую метрику.
        </p>
        <p>
          В ClickHouse мы используем для хранения ключей тип <mark>int32</mark>, это в 10-20 раз быстрее, чем хранить
          строки. При записи метрики строковые значения нужно превратить в целочисленные. Для этого используется
          глобальное отображение <code>string &lt;-&gt; int32</code>. Это общий ресурс, а значит есть ограничение на
          создание элементов в нём, но только на создание.
        </p>
        <p>
          Установлено ограничение в 300 ключей, который восполняется по 48, ключей в день. То есть если вы долго не
          создавали ключей, можете сразу создать 300, но после этого только 48 в день. Если не создавать ключи долго,
          бюджет восстановится.
        </p>
        <p>
          После того, как строковые ключи отображены в целочисленные, при вставке в базу получится какое-то количество
          строк, по одной на каждую использованную комбинацию ключей. На каждую метрику выделяется бюджет, зависящий от
          других метрик и других условий. Если попытаться вставлять больше данных, чем бюджет - произойдет
          сэмплирование, то есть часть рядов будет выкинуты, а оставшиеся умножены на выбранный фактор
        </p>
        <h5 id="sampling">
          Что вообще происходит при сэмплировании? <a href="#sampling">#</a>
        </h5>
        <p>
          Рассмотрим на пример фактора 2. При таком факторе случайная половина рядов (комбинация ключей) будет
          выброшена, а у оставшихся количество событий и сумма значений домножены на 2. Например, если были 2 ряда{' '}
          <mark>key1=cat count=2, min=1, max=5, sum=6</mark> и <mark>key1=Dog count=3, min=1, max=1, sum=3</mark>, после
          сэмплирования останется либо <mark>key1=cat count=4, min=1, max=5, sum=12</mark>, либо{' '}
          <mark>key1=Dog count=6, min=1, max=1, sum=6</mark>.
        </p>
        <p>
          Такое действие сохраняет форму распределения, но только статистически. В статистике за конкретную секунду
          останется или кошечка или собачка, но уже в статистике за минуту будет примерно по 30 рядов с кошечкой и
          собачкой.
        </p>
        <h5 id="resolution">
          Что такое resolution статистики <a href="#resolution">#</a>
        </h5>
        <p>
          В минуту для каждой метрики система выделяет динамически некоторый бюджет. Этот бюджет можно потратить
          по-разному, например каждую секунду отправить по 100 комбинаций ключей, либо раз в 10 секунд 1000 комбинаций,
          либо раз в 60 секунд 6000 комбинаций (все цифры условны). Имеет смысл делать разрешение хуже 1 секунды только
          система выбирает для вашей статистики sample factor выше единицы.
        </p>
        <h5 id="production-staging">
          Разделение метрик со stage и production<a href="#production-staging">#</a>
        </h5>
        <p>
          В StatsHouse PHP окружение записывается как значение отдельного ключа с именем <mark>0</mark>, поэтому оно
          подчиняется обычным правилам для ключей — окружений может быть больше двух, и на одном графике можно
          просматривать любую их комбинацию.
        </p>
        <h5 id="production-staging-2">
          Данные моей метрики теперь пишутся не в окружение production, а в окружение staging{' '}
          <a href="#production-staging-2">#</a>
        </h5>
        <p>
          Скорее всего ваша метрика пишется из крона. А кроны работают в PHP окружении <mark>staging</mark> (сюрприз?).
        </p>
        <h5 id="float-count">
          Почему у меня число событий 1.713 <a href="#float-count">#</a>
        </h5>
        <p>
          Если система перегружена, она может выбрать для метрики не обязательно целый sample factor, например 1.713.
        </p>
        <p>
          Поэтому StatsHouse использует <mark>float64</mark> для <mark>counter</mark> и <mark>value</mark> значений (но{' '}
          <mark>int64</mark> для значений <mark>unique</mark>, с которыми не проводится никаких математических операций
          и которые считаются чем-то вроде хешей).
        </p>
        <h5 id="retention">
          Данные хранятся вечно? <a href="#retention">#</a>
        </h5>
        <p>
          StatsHouse хранит посекундные данные двое суток, поминутные месяц, почасовые вечно или пока не будут удалены
          вручную.
        </p>
        <h5 id="old-data">
          Я записал довольно много статистики за прошлый месяц, но вижу огромный пик за прошлые сутки{' '}
          <a href="#old-data">#</a>
        </h5>
        <p>
          Запрет писать старые данные настолько важен, что установлен нами прямо в свойствах{' '}
          <mark>materialized view</mark> таблиц ClickHouse.
        </p>
        <p>
          ClickHouse это <abbr title="Log Structured Merge tree">LSM</abbr> база, данные хранятся в виде партов, для
          секундной таблицы с правилом <mark>partition by 6 hours</mark>, для остальных с правилом
          <mark>partition by 1 day</mark>. Если вставить старые данные, то придётся создать более 1 парта, например если
          вставить данные за прошлую неделю, то будет создано несколько десятков партов, вместо трёх, что создаст
          огромную нагрузку на ZooKeeper и сам ClickHouse.
        </p>
        <p>
          Вставка старых данных это непропорциональный объём дополнительной работы для базы, в нашем эксперименте
          тестовая запись всего 100 килобайтов данных за старые даты привела к отказу кластера статлогов на 7 часов.
        </p>
        <p>
          Вы можете явно указывать timestamp, однако если он в будущем, то он заменяется текущим временем, а если в если
          если в прошлом более, чем на 26 часов, то заменяется на текущее время минус 26 часов. Таким образом крон,
          запускающийся раз в сутки, может вставить статистику за прошлые сутки с правильным временем, если сам крон
          работает менее двух часов.
        </p>
        <h5 id="raw">
          Как работают raw-ключи <a href="#raw">#</a>
        </h5>
        <p>
          Все значения ключей в протоколе статсхауса являются строками, поэтому даже если в PHP передать в значение
          ключа целое 3, то в статсхаус оно попадёт, как "3". Дальше обычно происходит отображение строк с помощью
          глобального отображения, "iphone" превращается в 8, "3" в 907, и т.д. Если строчка ни разу не встречалась,
          происходит создание нового элемента отображения со следующим выбранным номером. При рисовании обычных значений
          делается обратное отображение и рисуется соответствующая строчка, а если такого элемента нет, рисуется целое
          значение со специальным raw-префиксом #12345.
        </p>
        <p>
          Однако иногда желательно записывать целые значения в базу именно как целые, например, user id или app id.
          Тогда нужно промаркировать данный ключ, как raw, и статсхаус вместо поиска в отображении будет просто делать
          parseInt и записывать в базу результат. В при рисовании будет просто показывать само целое значение со
          специальным raw-префиксом #12345. Однако для удобства можно задать строчки для некоторых значений, тогда для
          этих значений будут отображаться соответствующие им строчки.
        </p>
        <p>
          Если поменять флаг raw для ключа, то изменится способ рисования уже записанных значений, что может вызвать
          удивление.
        </p>
      </div>
    </div>
  );
});

export default FAQ;
