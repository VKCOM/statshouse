// Copyright 2022 V Kontakte LLC
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

import React from 'react';
import { useLocation } from 'react-router-dom';

const FAQ = React.memo(function FAQ_(props: { yAxisSize: number }) {
  const { yAxisSize } = props;
  const location = useLocation();

  // update document title
  React.useEffect(() => {
    document.title = `FAQ — StatsHouse`;
  }, []);

  React.useEffect(() => {
    if (location.hash) {
      document.querySelector(location.hash)?.scrollIntoView({ behavior: 'smooth' });
    }
  }, [location.hash]);

  return (
    <div className="container-xl pt-3 pb-3">
      <div className="faq-page d-flex flex-column" style={{ paddingLeft: `${yAxisSize}px`, boxSizing: 'border-box' }}>
        <h5 id="metric-vs-stat">
          Чем метрика отличается от статы <a href="#metric-vs-stat">#</a>
        </h5>
        <p>
          Эти понятия взаимозаменяемы, по историческим причинам внутри ВКонтакте обычно используется "стата". В
          StatsHouse мы везде используем термин "метрика".
        </p>
        <h5 id="create-metric">
          Как создать новую метрику <a href="#create-metric">#</a>
        </h5>
        <p>
          Нажать кнопку рядом с кнопкой FAQ). После создания метрика готова к записи и просмотру данных, обычно стоит
          отредактировать её свойства кнопкой Edit.
        </p>
        <h5 id="metric-kind">
          Что такое тип метрики, какой тип мне нужен <a href="#metric-kind">#</a>
        </h5>
        <ul>
          <li>
            <mark>counter</mark>— простой счётчик, <code>statlogsXCountEvent</code> подсчитает сумму числа событий в
            секунду.
          </li>
          <li>
            <mark>value</mark>— <mark>counter</mark> плюс значение. <code>statlogsXValueEvent</code> подсчитает в
            дополнение к сумме числа событий ещё и минимальное, максимальное, среднее от значений. Значения имеют тип{' '}
            <code>float64</code>.
          </li>
          <li>
            <mark>percentile</mark>— <mark>value</mark> с разбивкой по перцентилям, дорогое удовольствие, так что такой
            тип можно задать только с помощью админа. Записывается идентичным с value образом —{' '}
            <code>statlogsXValueEvent</code>, перцентили будут писаться если в свойствах метрики установлен
            соответствующий тип.
          </li>
          <li>
            <mark>unique</mark>— <mark>counter</mark> плюс кардинальность (уники). <code>statlogsXUniqueCount</code>{' '}
            подсчитает в дополнение к сумме числа событий ещё и оценку количества разных значений. Значения имеют тип{' '}
            <code>int64</code>.
          </li>
          <li>
            <mark>string top</mark>— топ строк. <code>statlogsXStringTop</code> выберет самые популярные строки и
            подсчитает количество каждой, плюс количество невошедших в топ.
          </li>
        </ul>
        <p>
          В новом коде всегда используйте функции семейства <code>statlogsX*</code>, принимающие массив ключей,
          например, <code>statlogsXCountEvent</code>, а не <code>statlogsCountEvent</code>.
        </p>
        <p>
          Все метрики в StatsHouse содержат счётчик событий, так что не нужно писать его отдельно. В данном примере
          первая строчка не нужна, так как <mark>unique</mark> и так содержит число событий:
        </p>
        <pre>
          <code>{`    statlogsCountEvent(self::STATS_KEY, $block, $action, test_getFeedRightAppsBlockGroup($user_id)); // WRONG
    statlogsUniqueCount(self::STATS_USERS_KEY, $user_id, $block, $action, test_getFeedRightAppsBlockGroup($user_id));`}</code>
        </pre>
        <p>
          Лучше так не делать, но разные комбинации ключей могут одной метрики могут записываться функциями для разных
          типов, тогда можно указать тип метрики как <mark>mixed</mark> или <mark>mixed_p</mark> (с записью
          перцентилей). В этом случае система позволит писать и отображать все типы данных для этой метрики. Некоторые
          любят создавать одну метрику для подсистемы, и разбить её на "под-метрики" с помощью разных значений
          <mark>key1</mark>. Можно и так, но тогда тип метрики придётся задать, как <mark>mixed</mark>. Также для такой
          метрики будет выбран единый фактор сэмплирования и будет невозможно задать описания ключей (ведь они скорее
          всего будет зависеть от <mark>key1</mark>). В новом коде <mark>mixed</mark> метрик следует избегать.
        </p>
        <h5 id="data-quality">
          Я выплачиваю комиссии на основе данных статлогов и... <a href="#data-quality">#</a>
        </h5>
        <p>
          Стоп-стоп! Так нельзя. Даже если не произойдёт включения сэмплирования для твоей метрики, система статистики
          это не транзакционная база, здесь нет гарантий доставки, данные могут пропасть или вставиться более одного
          раза.
        </p>
        <p>
          Важная бизнес-логика должна пользоваться каким-то транзакционным движком. События, которые нужно доставить 1
          раз должны сохраняться после генерации в надёжное хранилище (с fsync) на источнике данных, и т.д.
        </p>
        <h5 id="mapping-limits">
          Правда ли что в сутки можно писать только 200 комбинаций ключей? <a href="#mapping-limits">#</a>
        </h5>
        <p>
          Не правда, у нас есть 2 механизма ограничений, первый связан с отображениями строковых значений ключей в
          целые, второй с лимитом записи в базу под каждую метрику.
        </p>
        <p>
          В ClickHouse мы используем для хранения ключей тип <mark>int32</mark>, это в 10-20 раз быстрее, чем хранить
          строки. При записи метрики строковые значения нужно превратить в целочисленные. Для этого используется
          глобальное отображение <code>string &lt;-&gt; int32</code>. Это общий ресурс, а значит есть ограничение на
          создание элементов в нём, но только на создание.
        </p>
        <p>
          Исторически установлено примитивное ограничение в 100 ключей в день, что позволяет каждой метрике создать
          70000+ ключей в год. Это очень много и привело к чудовищному росту отображения (60+ гигабайтов), поэтому скоро
          мы перейдём на использование бюджета в (например) 300 ключей, который будет восполняться (например) по 5
          ключей в день. То есть если вы долго не создавали ключей, можете сразу создать 600, но после этого только 5 в
          день. Если не создавать ключи 60 дней, бюджет полностью восстановится.
        </p>
        <p>
          После того, как строковые ключи отображены в целочисленные, при вставке в базу получится какое-то количество
          строк, по одной на каждую использованную комбинацию ключей. Сейчас мы разрешаем использовать примерно 50000
          комбинаций в час, если больше - произойдет сэмплирование, то есть часть рядов будет выкинуты а оставшиеся
          умножены на выбранный фактор. Если система перегружена, временно может быть выбран и больший фактор, чтобы
          осталось меньше рядов.
        </p>
        <h5 id="sampling">
          Что вообще происходит при сэмплировании? <a href="#sampling">#</a>
        </h5>
        <p>
          Рассмотрим на пример фактора 2. При таком факторе случайная половина рядов (комбинация ключей) будет
          выброшена, а у оставшихся количество событий и сумма значений домножены на 2. Например, если были 2 ряда{' '}
          <mark>key1=cat count=2, min=1, max=5, sum=6</mark> и <mark>key1=Dog count=3, min=1, max=1, sum=3</mark>, после
          сэмплирования останется либо <mark>key1=cat count=4, min=1, max=5, sum=12</mark>, либо{' '}
          <mark>key1=Dog count=6, min=1, max=1, sum=6</mark>.
        </p>
        <p>
          Такое действие сохраняет форму распределения, но только статистически. В статистике за конкретную секунду
          останется или кошечка или собачка, но уже в статистике за минуту будет примерно по 30 рядов с кошечкой и
          собачкой.
        </p>
        <h5 id="cluster">
          Что такое кластеры статистики <a href="#cluster">#</a>
        </h5>
        <p>
          Никаких кластеров статистики на самом деле не существует, это разграничение сохранилось со времён{' '}
          <mark>meowdb</mark>. Данные метрик хранятся в одной таблице (в старой системе — в двух) по ключу ID метрики,
          поэтому все ID должны быть глобально уникальны.
        </p>
        <p>
          StatsHouse вообще не имеет такой концепции, как кластер, и просто конкатенирует имя метрики, символ{' '}
          <mark>@</mark> и имя кластера для получения полного имени статистики.
        </p>
        <h5 id="resolution">
          Что такое resolution статистики <a href="#resolution">#</a>
        </h5>
        <p>
          В минуту для каждой метрики система выделяет некоторое число бит. Эти биты можно потратить по-разному,
          например каждую секунду отправить по 100 комбинаций ключей, либо раз в 10 секунд 1000 комбинаций, либо раз в
          60 секунд 6000 комбинаций (все цифры условны). Имеет смысл делать разрешение хуже 1 секунды только если
          система выбирает для вашей статистики sample factor выше единицы.
        </p>
        <h5 id="production-staging">
          Данные со stage пишутся в кластер <mark>staging</mark>? <a href="#production-staging">#</a>
        </h5>
        <p>
          Не совсем. То, что называется в коде кластер staging используется в старой системе для маркировки метрик типа{' '}
          <mark>unique</mark> (не спрашивайте, почему).
        </p>
        <p>
          Старая система имеет 2 отдельные таблицы для PHP окружений <mark>staging</mark> и <mark>production</mark>,
          причём в таблицу <mark>staging</mark> пишутся события из окружения <mark>staging</mark>, а в таблицу{' '}
          <mark>production</mark> сумма событий из окружений <mark>staging</mark> и <mark>production</mark>.
        </p>
        <p>
          В StatsHouse PHP окружение записывается как значение нового ключа <mark>key0</mark>, поэтому оно подчиняется
          обычным правилам для ключей — окружений может быть больше двух, и на одном графике можно просматривать любую
          их комбинацию.
        </p>
        <h5 id="production-staging-2">
          Данные моей метрики теперь пишутся не в окружение production, а в окружение staging{' '}
          <a href="#production-staging-2">#</a>
        </h5>
        <p>
          Скорее всего ваша метрика пишется из крона. А кроны работают в PHP окружении <mark>staging</mark> (сюрприз?).
        </p>
        <p>
          В старой системе вы видели эти данные в окружении <mark>production</mark>, потому что туда писались события из
          обоих окружений. В StatsHouse данные пишутся только в правильное окружение.
        </p>
        <h5 id="float-count">
          Почему у меня число событий 1.713 <a href="#float-count">#</a>
        </h5>
        <p>
          Если система перегружена, она может выбрать для метрики не обязательно целый sample factor, например 1.713.
        </p>
        <p>
          Поэтому StatsHouse использует <mark>float64</mark> для <mark>counter</mark> и <mark>value</mark> значений (но{' '}
          <mark>int64</mark> для значений <mark>unique</mark>, с которыми не проводится никаких математических операций
          и которые считаются чем-то вроде хешей).
        </p>
        <h5 id="retention">
          Данные хранятся вечно? <a href="#retention">#</a>
        </h5>
        <p>Старая система хранит поминутные и почасовые данные вечно, или пока не будут удалены вручную.</p>
        <p>
          StatsHouse хранит посекундные данные двое суток, поминутные месяц, почасовые вечно или пока не будут удалены
          вручную.
        </p>
        <h5 id="old-data">
          Я записал довольно много статистики за позавчера, но вижу огромный пик примерно час назад{' '}
          <a href="#old-data">#</a>
        </h5>
        <p>
          Запрет писать старые данные настолько важен, что установлен нами прямо в свойствах{' '}
          <mark>materialized view</mark> таблиц ClickHouse.
        </p>
        <p>
          ClickHouse это <abbr title="Log Structured Merge tree">LSM</abbr> база, данные за позавчера находятся в файле
          размером, например, 60 гигабайтов, а вставлять в середину файла ClickHouse не умеет, этот файл результат
          огромной проделанной работы в виде фоновых слияний меньших по размеру файлов. Если вы вставите даже 1
          позавчерашнее значение, ClickHouse запланирует слияние, считает с диска и разожмёт все 60 гигабайтов, добавит
          в середину ваше значение, сожмёт опять и запишет на диск.
        </p>
        <p>
          Вставка старых данных это непропорциональный объём дополнительной работы для базы, в нашем эксперименте запись
          всего 100 килобайтов данных за старые даты привела к отказу кластера статлогов на 7 часов.
        </p>
        <p>
          Новая система позволяет указывать timestamp, однако если он в будущем, то он заменяется текущим временем, а
          если в прошлом более, чем на 1.5 часа, то заменяется на текущее время минус 1.5 часа. Таким образом крон,
          запускающийся раз в час, может вставить статистику за прошлый час с правильным временем, и при этом замедление
          работы базы незаметно.
        </p>
        <p>
          Это означает, что кронам, которые раньше могли записать статистику раз в сутки за прошедшие сутки, нужно будет
          запускаться раз в час.
        </p>
        <h5 id="deprecation">
          Когда откажемся от старой системы <a href="#deprecation">#</a>
        </h5>
        <p>Сейчас старая и новые системы работают параллельно, одни и те же данные вставляются в обе.</p>
        <p>
          Параллельно идёт процесс переливки часовых данных из старой системы в новую. Также система{' '}
          <mark>watchdogs</mark> и часть бизнес-логики читают данные из старой системы.
        </p>
        <p>
          Когда StatsHouse проработает без отказов какое-то время, данные будут перелиты, а бизнес логика будет
          пользоваться данными из новой системы, мы отключим и разберём старую.
        </p>
        <h5 id="raw">
          Как работают raw-ключи <a href="#raw">#</a>
        </h5>
        <p>
          Все значения ключей в протоколе статсхауса являются строками, поэтому даже если в PHP передать в значение
          ключа целое 3, то в статсхаус оно попадёт, как "3". Дальше обычно происходит отображение строк с помощью
          глобального отображения, "iphone" превращается в 8, "3" в 907, и т.д. Если строчка ни разу не встречалась,
          происходит создание нового элемента отображения со следующим выбранным номером. При рисовании обычных значений
          делается обратное отображение и рисуется соответствующая строчка, а если такого элемента нет, рисуется целое
          значение со специальным raw-префиксом #12345.
        </p>
        <p>
          Однако иногда желательно записывать целые значения в базу именно как целые, например, user id или app id.
          Тогда нужно промаркировать данный ключ, как raw, и статсхаус вместо поиска в отображении будет просто делать
          parseInt и записывать в базу результат. В при рисовании будет просто показывать само целое значение со
          специальным raw-префиксом #12345. Однако для удобства можно задать строчки для некоторых значений, тогда для
          этих значений будут отображаться соответствующие им строчки.
        </p>
        <p>
          Если поменять флаг raw для ключа, то изменится способ рисования уже записанных значений, что может вызвать
          удивление.
        </p>
      </div>
    </div>
  );
});

export default FAQ;
