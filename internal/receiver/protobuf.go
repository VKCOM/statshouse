// Copyright 2022 V Kontakte LLC
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

package receiver

// Code based on the one generated by https://github.com/hrissan/protocute

import (
	"encoding/binary"
	"fmt"
	"math"

	"google.golang.org/protobuf/encoding/protowire"

	"github.com/vkcom/statshouse/internal/data_model/gen2/tl"
	"github.com/vkcom/statshouse/internal/data_model/gen2/tlstatshouse"
)

var errorTsOverflow = fmt.Errorf("ts field overflow, must have range [0..2^32)")

func protobufError(n int) error {
	return protowire.ParseError(n)
}

func protoReadString(buf []byte, result *[]byte) ([]byte, error) {
	data, n := protowire.ConsumeBytes(buf)
	if n < 0 {
		return buf, protobufError(n)
	}
	*result = append((*result)[:0], data...)
	return buf[n:], nil
}

func protoReadFloat64(buf []byte, result *float64) ([]byte, error) {
	data, n := protowire.ConsumeFixed64(buf)
	if n < 0 {
		return buf, protobufError(n)
	}
	*result = math.Float64frombits(data)
	return buf[n:], nil
}

func protoReadInt64(buf []byte, result *int64) ([]byte, error) {
	data, n := protowire.ConsumeVarint(buf)
	if n < 0 {
		return buf, protobufError(n)
	}
	*result = int64(data)
	return buf[n:], nil
}

func protoReadPackedFixedFloat64(buf []byte, result *[]float64) ([]byte, error) {
	data, n := protowire.ConsumeBytes(buf)
	if n < 0 {
		return buf, protobufError(n)
	}
	if len(data)%8 != 0 {
		return buf, fmt.Errorf("packed double is not multiple of 8")
	}
	for i := 0; i < len(data); i += 8 {
		*result = append(*result, math.Float64frombits(binary.LittleEndian.Uint64(data[i:])))
	}
	return buf[n:], nil
}

func protoReadPackedVarInt64(buf []byte, result *[]int64) ([]byte, error) {
	data, n := protowire.ConsumeBytes(buf)
	if n < 0 {
		return buf, protobufError(n)
	}
	var err error
	for len(data) != 0 {
		var val int64
		if data, err = protoReadInt64(data, &val); err != nil {
			return buf, nil
		}
		*result = append(*result, val)
	}
	return buf[n:], nil
}

func protoReadTag(buf []byte) (protowire.Number, protowire.Type, []byte, error) {
	f, t, n := protowire.ConsumeTag(buf)
	if n < 0 {
		return 0, 0, buf, protobufError(n)
	}
	return f, t, buf[n:], nil
}

func protoSkipField(buf []byte, f protowire.Number, t protowire.Type) ([]byte, error) {
	n := protowire.ConsumeFieldValue(f, t, buf)
	if n < 0 {
		return buf, protobufError(n)
	}
	return buf[n:], nil
}

//	void read(::statshouse::MapFieldEntry & v, iterator s, iterator e){
//		while(s != e){
//			auto m = read_varint(&s, e);
//			auto field_type = static_cast<unsigned>(m & 7U);
//			auto field_number = static_cast<unsigned>(m >> 3U);
//			if(field_number == 1 && field_type == 2)
//				v.key = read_string(&s, e);
//			else if(field_number == 2 && field_type == 2)
//				v.value = read_string(&s, e);
//			else
//				skip_by_type(field_type, &s, e);
//		}
func protobufUnmarshalFieldEntry(buf []byte, m *tl.DictionaryFieldStringBytes) ([]byte, error) {
	m.Key = m.Key[:0]
	m.Value = m.Value[:0]
	var f protowire.Number
	var t protowire.Type
	var err error
	for len(buf) != 0 {
		f, t, buf, err = protoReadTag(buf)
		if err != nil {
			return buf, err
		}
		if f == 1 && t == 2 {
			if buf, err = protoReadString(buf, &m.Key); err != nil {
				return buf, err
			}
			continue
		}
		if f == 2 && t == 2 {
			if buf, err = protoReadString(buf, &m.Value); err != nil {
				return buf, err
			}
			continue
		}
		if buf, err = protoSkipField(buf, f, t); err != nil {
			return buf, err
		}
	}
	return buf, nil
}

// void read(::statshouse::Metric & v, iterator s, iterator e){
//	while(s != e){
//		auto m = read_varint(&s, e);
//		auto field_type = static_cast<unsigned>(m & 7U);
//		auto field_number = static_cast<unsigned>(m >> 3U);
//		if(field_number == 1 && field_type == 2)
//			v.name = read_string(&s, e);
//		else if(field_number == 2 && field_type == 2){
//			v.tags.emplace_back();
//			read_message(v.tags.back(), &s, e);
//		}else if(field_number == 3 && field_type == 1)
//			v.counter = read_fixed<double>(&s, e);
//		else if(field_number == 4 && field_type == 2)
//			read_packed_fixed(v.value, &s, e);
//		else if(field_number == 4 && field_type == 1)
//			v.value.push_back(read_fixed<double>(&s, e));
//		else if(field_number == 5 && field_type == 2)
//			read_packed_varint(v.unique, &s, e);
//		else if(field_number == 5 && field_type == 0)
//			v.unique.push_back(read_varint_t<int64_t>(&s, e));
//		else if(field_number == 6 && field_type == 2)
//			v.stop.push_back(read_string(&s, e));
//		else
//			skip_by_type(field_type, &s, e);
//	}

func protobufUnmarshalStatshouseMetric(buf []byte, m *tlstatshouse.MetricBytes) ([]byte, error) {
	m.Reset()
	var f protowire.Number
	var t protowire.Type
	var err error
	for len(buf) != 0 {
		f, t, buf, err = protoReadTag(buf)
		if err != nil {
			return buf, err
		}
		if f == 1 && t == 2 {
			if buf, err = protoReadString(buf, &m.Name); err != nil {
				return buf, err
			}
			continue
		}
		if f == 2 && t == 2 {
			data, n := protowire.ConsumeBytes(buf)
			if n < 0 {
				return buf, protobufError(n)
			}

			if cap(m.Tags) > len(m.Tags) {
				m.Tags = m.Tags[:len(m.Tags)+1]
			} else {
				m.Tags = append(m.Tags, tl.DictionaryFieldStringBytes{})
			}
			buf = buf[n:]
			if _, err = protobufUnmarshalFieldEntry(data, &m.Tags[len(m.Tags)-1]); err != nil {
				return buf, err
			}
			continue
		}
		if f == 3 && t == 1 {
			var value float64
			if buf, err = protoReadFloat64(buf, &value); err != nil {
				return buf, err
			}
			m.SetCounter(value)
			continue
		}
		if f == 5 && t == 2 {
			value := m.Value
			if buf, err = protoReadPackedFixedFloat64(buf, &value); err != nil {
				return buf, err
			}
			m.SetValue(value)
			continue
		}
		if f == 5 && t == 1 {
			var val float64
			if buf, err = protoReadFloat64(buf, &val); err != nil {
				return buf, err
			}
			m.SetValue(append(m.Value, val))
			continue
		}
		if f == 6 && t == 2 {
			value := m.Unique
			if buf, err = protoReadPackedVarInt64(buf, &value); err != nil {
				return buf, err
			}
			m.SetUnique(value)
			continue
		}
		if f == 6 && t == 1 {
			var val int64
			if buf, err = protoReadInt64(buf, &val); err != nil {
				return buf, err
			}
			m.SetUnique(append(m.Unique, val))
			continue
		}
		if f == 4 && t == 0 {
			var ts int64
			if buf, err = protoReadInt64(buf, &ts); err != nil {
				return buf, err
			}
			if ts < 0 || ts > math.MaxUint32 {
				return buf, errorTsOverflow
			}
			m.SetTs(uint32(ts))
			continue
		}
		if buf, err = protoSkipField(buf, f, t); err != nil {
			return buf, err
		}
	}
	return buf, nil
}

//	void read(::statshouse::MetricBatch & v, iterator s, iterator e){
//		while(s != e){
//			auto m = read_varint(&s, e);
//			auto field_type = static_cast<unsigned>(m & 7U);
//			auto field_number = static_cast<unsigned>(m >> 3U);
//			if(field_number == 1 && field_type == 2){
//				v.metrics.emplace_back();
//				read_message(v.metrics.back(), &s, e);
//			}else
//				skip_by_type(field_type, &s, e);
//		}
func protobufUnmarshalStatshouseAddMetricBatch(mb *tlstatshouse.AddMetricsBatchBytes, buf []byte) ([]byte, error) {
	mb.Reset()
	var f protowire.Number
	var t protowire.Type
	var err error
	for len(buf) != 0 {
		f, t, buf, err = protoReadTag(buf)
		if err != nil {
			return buf, err
		}
		if f == 13337 && t == 2 {
			data, n := protowire.ConsumeBytes(buf)
			if n < 0 {
				return buf, protobufError(n)
			}
			if cap(mb.Metrics) > len(mb.Metrics) {
				mb.Metrics = mb.Metrics[:len(mb.Metrics)+1]
			} else {
				mb.Metrics = append(mb.Metrics, tlstatshouse.MetricBytes{})
			}
			_, err = protobufUnmarshalStatshouseMetric(data, &mb.Metrics[len(mb.Metrics)-1])
			buf = buf[n:]
			if err != nil {
				return buf, err
			}
			continue
		}
		if buf, err = protoSkipField(buf, f, t); err != nil {
			return buf, err
		}
	}
	return buf, nil
}
