// Copyright 2022 V Kontakte LLC
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

// Code generated by vktl/cmd/tlgen2; DO NOT EDIT.
package internal

import (
	"github.com/vkcom/statshouse/internal/vkgo/basictl"
)

var _ = basictl.NatWrite

type StatshouseMultiValue struct {
	Counter float64 // Conditional: nat_fields_mask.0
	// CounterEq1 (TrueType) // Conditional: nat_fields_mask.1
	// ValueSet (TrueType) // Conditional: nat_fields_mask.2
	ValueMin       float64              // Conditional: nat_fields_mask.3
	ValueMax       float64              // Conditional: nat_fields_mask.4
	ValueSum       float64              // Conditional: nat_fields_mask.4
	ValueSumSquare float64              // Conditional: nat_fields_mask.4
	Uniques        string               // Conditional: nat_fields_mask.5
	Centroids      []StatshouseCentroid // Conditional: nat_fields_mask.6
	HostTag        int32                // Conditional: nat_fields_mask.7
}

func (StatshouseMultiValue) TLName() string { return "statshouse.multi_value" }
func (StatshouseMultiValue) TLTag() uint32  { return 0xc803e06 }

func (item *StatshouseMultiValue) SetCounter(v float64, nat_fields_mask *uint32) {
	item.Counter = v
	if nat_fields_mask != nil {
		*nat_fields_mask |= 1 << 0
	}
}
func (item *StatshouseMultiValue) ClearCounter(nat_fields_mask *uint32) {
	item.Counter = 0
	if nat_fields_mask != nil {
		*nat_fields_mask &^= 1 << 0
	}
}
func (item StatshouseMultiValue) IsSetCounter(nat_fields_mask uint32) bool {
	return nat_fields_mask&(1<<0) != 0
}

func (item *StatshouseMultiValue) SetCounterEq1(v bool, nat_fields_mask *uint32) {
	if nat_fields_mask != nil {
		if v {
			*nat_fields_mask |= 1 << 1
		} else {
			*nat_fields_mask &^= 1 << 1
		}
	}
}
func (item StatshouseMultiValue) IsSetCounterEq1(nat_fields_mask uint32) bool {
	return nat_fields_mask&(1<<1) != 0
}

func (item *StatshouseMultiValue) SetValueSet(v bool, nat_fields_mask *uint32) {
	if nat_fields_mask != nil {
		if v {
			*nat_fields_mask |= 1 << 2
		} else {
			*nat_fields_mask &^= 1 << 2
		}
	}
}
func (item StatshouseMultiValue) IsSetValueSet(nat_fields_mask uint32) bool {
	return nat_fields_mask&(1<<2) != 0
}

func (item *StatshouseMultiValue) SetValueMin(v float64, nat_fields_mask *uint32) {
	item.ValueMin = v
	if nat_fields_mask != nil {
		*nat_fields_mask |= 1 << 3
	}
}
func (item *StatshouseMultiValue) ClearValueMin(nat_fields_mask *uint32) {
	item.ValueMin = 0
	if nat_fields_mask != nil {
		*nat_fields_mask &^= 1 << 3
	}
}
func (item StatshouseMultiValue) IsSetValueMin(nat_fields_mask uint32) bool {
	return nat_fields_mask&(1<<3) != 0
}

func (item *StatshouseMultiValue) SetValueMax(v float64, nat_fields_mask *uint32) {
	item.ValueMax = v
	if nat_fields_mask != nil {
		*nat_fields_mask |= 1 << 4
	}
}
func (item *StatshouseMultiValue) ClearValueMax(nat_fields_mask *uint32) {
	item.ValueMax = 0
	if nat_fields_mask != nil {
		*nat_fields_mask &^= 1 << 4
	}
}
func (item StatshouseMultiValue) IsSetValueMax(nat_fields_mask uint32) bool {
	return nat_fields_mask&(1<<4) != 0
}

func (item *StatshouseMultiValue) SetValueSum(v float64, nat_fields_mask *uint32) {
	item.ValueSum = v
	if nat_fields_mask != nil {
		*nat_fields_mask |= 1 << 4
	}
}
func (item *StatshouseMultiValue) ClearValueSum(nat_fields_mask *uint32) {
	item.ValueSum = 0
	if nat_fields_mask != nil {
		*nat_fields_mask &^= 1 << 4
	}
}
func (item StatshouseMultiValue) IsSetValueSum(nat_fields_mask uint32) bool {
	return nat_fields_mask&(1<<4) != 0
}

func (item *StatshouseMultiValue) SetValueSumSquare(v float64, nat_fields_mask *uint32) {
	item.ValueSumSquare = v
	if nat_fields_mask != nil {
		*nat_fields_mask |= 1 << 4
	}
}
func (item *StatshouseMultiValue) ClearValueSumSquare(nat_fields_mask *uint32) {
	item.ValueSumSquare = 0
	if nat_fields_mask != nil {
		*nat_fields_mask &^= 1 << 4
	}
}
func (item StatshouseMultiValue) IsSetValueSumSquare(nat_fields_mask uint32) bool {
	return nat_fields_mask&(1<<4) != 0
}

func (item *StatshouseMultiValue) SetUniques(v string, nat_fields_mask *uint32) {
	item.Uniques = v
	if nat_fields_mask != nil {
		*nat_fields_mask |= 1 << 5
	}
}
func (item *StatshouseMultiValue) ClearUniques(nat_fields_mask *uint32) {
	item.Uniques = ""
	if nat_fields_mask != nil {
		*nat_fields_mask &^= 1 << 5
	}
}
func (item StatshouseMultiValue) IsSetUniques(nat_fields_mask uint32) bool {
	return nat_fields_mask&(1<<5) != 0
}

func (item *StatshouseMultiValue) SetCentroids(v []StatshouseCentroid, nat_fields_mask *uint32) {
	item.Centroids = v
	if nat_fields_mask != nil {
		*nat_fields_mask |= 1 << 6
	}
}
func (item *StatshouseMultiValue) ClearCentroids(nat_fields_mask *uint32) {
	item.Centroids = item.Centroids[:0]
	if nat_fields_mask != nil {
		*nat_fields_mask &^= 1 << 6
	}
}
func (item StatshouseMultiValue) IsSetCentroids(nat_fields_mask uint32) bool {
	return nat_fields_mask&(1<<6) != 0
}

func (item *StatshouseMultiValue) SetHostTag(v int32, nat_fields_mask *uint32) {
	item.HostTag = v
	if nat_fields_mask != nil {
		*nat_fields_mask |= 1 << 7
	}
}
func (item *StatshouseMultiValue) ClearHostTag(nat_fields_mask *uint32) {
	item.HostTag = 0
	if nat_fields_mask != nil {
		*nat_fields_mask &^= 1 << 7
	}
}
func (item StatshouseMultiValue) IsSetHostTag(nat_fields_mask uint32) bool {
	return nat_fields_mask&(1<<7) != 0
}

func (item *StatshouseMultiValue) Reset() {
	item.Counter = 0
	item.ValueMin = 0
	item.ValueMax = 0
	item.ValueSum = 0
	item.ValueSumSquare = 0
	item.Uniques = ""
	item.Centroids = item.Centroids[:0]
	item.HostTag = 0
}

func (item *StatshouseMultiValue) Read(w []byte, nat_fields_mask uint32) (_ []byte, err error) {
	if nat_fields_mask&(1<<0) != 0 {
		if w, err = basictl.DoubleRead(w, &item.Counter); err != nil {
			return w, err
		}
	} else {
		item.Counter = 0
	}
	if nat_fields_mask&(1<<3) != 0 {
		if w, err = basictl.DoubleRead(w, &item.ValueMin); err != nil {
			return w, err
		}
	} else {
		item.ValueMin = 0
	}
	if nat_fields_mask&(1<<4) != 0 {
		if w, err = basictl.DoubleRead(w, &item.ValueMax); err != nil {
			return w, err
		}
	} else {
		item.ValueMax = 0
	}
	if nat_fields_mask&(1<<4) != 0 {
		if w, err = basictl.DoubleRead(w, &item.ValueSum); err != nil {
			return w, err
		}
	} else {
		item.ValueSum = 0
	}
	if nat_fields_mask&(1<<4) != 0 {
		if w, err = basictl.DoubleRead(w, &item.ValueSumSquare); err != nil {
			return w, err
		}
	} else {
		item.ValueSumSquare = 0
	}
	if nat_fields_mask&(1<<5) != 0 {
		if w, err = basictl.StringRead(w, &item.Uniques); err != nil {
			return w, err
		}
	} else {
		item.Uniques = ""
	}
	if nat_fields_mask&(1<<6) != 0 {
		if w, err = VectorStatshouseCentroid0Read(w, &item.Centroids); err != nil {
			return w, err
		}
	} else {
		item.Centroids = item.Centroids[:0]
	}
	if nat_fields_mask&(1<<7) != 0 {
		if w, err = basictl.IntRead(w, &item.HostTag); err != nil {
			return w, err
		}
	} else {
		item.HostTag = 0
	}
	return w, nil
}

func (item *StatshouseMultiValue) Write(w []byte, nat_fields_mask uint32) (_ []byte, err error) {
	if nat_fields_mask&(1<<0) != 0 {
		w = basictl.DoubleWrite(w, item.Counter)
	}
	if nat_fields_mask&(1<<3) != 0 {
		w = basictl.DoubleWrite(w, item.ValueMin)
	}
	if nat_fields_mask&(1<<4) != 0 {
		w = basictl.DoubleWrite(w, item.ValueMax)
	}
	if nat_fields_mask&(1<<4) != 0 {
		w = basictl.DoubleWrite(w, item.ValueSum)
	}
	if nat_fields_mask&(1<<4) != 0 {
		w = basictl.DoubleWrite(w, item.ValueSumSquare)
	}
	if nat_fields_mask&(1<<5) != 0 {
		if w, err = basictl.StringWrite(w, item.Uniques); err != nil {
			return w, err
		}
	}
	if nat_fields_mask&(1<<6) != 0 {
		if w, err = VectorStatshouseCentroid0Write(w, item.Centroids); err != nil {
			return w, err
		}
	}
	if nat_fields_mask&(1<<7) != 0 {
		w = basictl.IntWrite(w, item.HostTag)
	}
	return w, nil
}

func (item *StatshouseMultiValue) ReadBoxed(w []byte, nat_fields_mask uint32) (_ []byte, err error) {
	if w, err = basictl.NatReadExactTag(w, 0xc803e06); err != nil {
		return w, err
	}
	return item.Read(w, nat_fields_mask)
}

func (item *StatshouseMultiValue) WriteBoxed(w []byte, nat_fields_mask uint32) ([]byte, error) {
	w = basictl.NatWrite(w, 0xc803e06)
	return item.Write(w, nat_fields_mask)
}

func StatshouseMultiValue__ReadJSON(item *StatshouseMultiValue, j interface{}, nat_fields_mask uint32) error {
	return item.readJSON(j, nat_fields_mask)
}
func (item *StatshouseMultiValue) readJSON(j interface{}, nat_fields_mask uint32) error {
	_jm, _ok := j.(map[string]interface{})
	if j != nil && !_ok {
		return ErrorInvalidJSON("statshouse.multi_value", "expected json object")
	}
	_jCounter := _jm["counter"]
	delete(_jm, "counter")
	_jCounterEq1 := _jm["counter_eq_1"]
	delete(_jm, "counter_eq_1")
	_jValueSet := _jm["value_set"]
	delete(_jm, "value_set")
	_jValueMin := _jm["value_min"]
	delete(_jm, "value_min")
	_jValueMax := _jm["value_max"]
	delete(_jm, "value_max")
	_jValueSum := _jm["value_sum"]
	delete(_jm, "value_sum")
	_jValueSumSquare := _jm["value_sum_square"]
	delete(_jm, "value_sum_square")
	_jUniques := _jm["uniques"]
	delete(_jm, "uniques")
	_jCentroids := _jm["centroids"]
	delete(_jm, "centroids")
	_jHostTag := _jm["host_tag"]
	delete(_jm, "host_tag")
	for k := range _jm {
		return ErrorInvalidJSONExcessElement("statshouse.multi_value", k)
	}
	if nat_fields_mask&(1<<0) == 0 && _jCounter != nil {
		return ErrorInvalidJSON("statshouse.multi_value", "field 'counter' is defined, while corresponding implicit fieldmask bit is 0")
	}
	if _jCounterEq1 != nil {
		return ErrorInvalidJSON("statshouse.multi_value", "implicit true field 'counter_eq_1' cannot be defined, set fieldmask instead")
	}
	if _jValueSet != nil {
		return ErrorInvalidJSON("statshouse.multi_value", "implicit true field 'value_set' cannot be defined, set fieldmask instead")
	}
	if nat_fields_mask&(1<<3) == 0 && _jValueMin != nil {
		return ErrorInvalidJSON("statshouse.multi_value", "field 'value_min' is defined, while corresponding implicit fieldmask bit is 0")
	}
	if nat_fields_mask&(1<<4) == 0 && _jValueMax != nil {
		return ErrorInvalidJSON("statshouse.multi_value", "field 'value_max' is defined, while corresponding implicit fieldmask bit is 0")
	}
	if nat_fields_mask&(1<<4) == 0 && _jValueSum != nil {
		return ErrorInvalidJSON("statshouse.multi_value", "field 'value_sum' is defined, while corresponding implicit fieldmask bit is 0")
	}
	if nat_fields_mask&(1<<4) == 0 && _jValueSumSquare != nil {
		return ErrorInvalidJSON("statshouse.multi_value", "field 'value_sum_square' is defined, while corresponding implicit fieldmask bit is 0")
	}
	if nat_fields_mask&(1<<5) == 0 && _jUniques != nil {
		return ErrorInvalidJSON("statshouse.multi_value", "field 'uniques' is defined, while corresponding implicit fieldmask bit is 0")
	}
	if nat_fields_mask&(1<<6) == 0 && _jCentroids != nil {
		return ErrorInvalidJSON("statshouse.multi_value", "field 'centroids' is defined, while corresponding implicit fieldmask bit is 0")
	}
	if nat_fields_mask&(1<<7) == 0 && _jHostTag != nil {
		return ErrorInvalidJSON("statshouse.multi_value", "field 'host_tag' is defined, while corresponding implicit fieldmask bit is 0")
	}
	if nat_fields_mask&(1<<0) != 0 {
		if err := JsonReadFloat64(_jCounter, &item.Counter); err != nil {
			return err
		}
	} else {
		item.Counter = 0
	}
	if nat_fields_mask&(1<<3) != 0 {
		if err := JsonReadFloat64(_jValueMin, &item.ValueMin); err != nil {
			return err
		}
	} else {
		item.ValueMin = 0
	}
	if nat_fields_mask&(1<<4) != 0 {
		if err := JsonReadFloat64(_jValueMax, &item.ValueMax); err != nil {
			return err
		}
	} else {
		item.ValueMax = 0
	}
	if nat_fields_mask&(1<<4) != 0 {
		if err := JsonReadFloat64(_jValueSum, &item.ValueSum); err != nil {
			return err
		}
	} else {
		item.ValueSum = 0
	}
	if nat_fields_mask&(1<<4) != 0 {
		if err := JsonReadFloat64(_jValueSumSquare, &item.ValueSumSquare); err != nil {
			return err
		}
	} else {
		item.ValueSumSquare = 0
	}
	if nat_fields_mask&(1<<5) != 0 {
		if err := JsonReadString(_jUniques, &item.Uniques); err != nil {
			return err
		}
	} else {
		item.Uniques = ""
	}
	if nat_fields_mask&(1<<6) != 0 {
		if err := VectorStatshouseCentroid0ReadJSON(_jCentroids, &item.Centroids); err != nil {
			return err
		}
	} else {
		item.Centroids = item.Centroids[:0]
	}
	if nat_fields_mask&(1<<7) != 0 {
		if err := JsonReadInt32(_jHostTag, &item.HostTag); err != nil {
			return err
		}
	} else {
		item.HostTag = 0
	}
	return nil
}

func (item *StatshouseMultiValue) WriteJSON(w []byte, nat_fields_mask uint32) (_ []byte, err error) {
	w = append(w, '{')
	if nat_fields_mask&(1<<0) != 0 {
		if item.Counter != 0 {
			w = basictl.JSONAddCommaIfNeeded(w)
			w = append(w, `"counter":`...)
			w = basictl.JSONWriteFloat64(w, item.Counter)
		}
	}
	if nat_fields_mask&(1<<3) != 0 {
		if item.ValueMin != 0 {
			w = basictl.JSONAddCommaIfNeeded(w)
			w = append(w, `"value_min":`...)
			w = basictl.JSONWriteFloat64(w, item.ValueMin)
		}
	}
	if nat_fields_mask&(1<<4) != 0 {
		if item.ValueMax != 0 {
			w = basictl.JSONAddCommaIfNeeded(w)
			w = append(w, `"value_max":`...)
			w = basictl.JSONWriteFloat64(w, item.ValueMax)
		}
	}
	if nat_fields_mask&(1<<4) != 0 {
		if item.ValueSum != 0 {
			w = basictl.JSONAddCommaIfNeeded(w)
			w = append(w, `"value_sum":`...)
			w = basictl.JSONWriteFloat64(w, item.ValueSum)
		}
	}
	if nat_fields_mask&(1<<4) != 0 {
		if item.ValueSumSquare != 0 {
			w = basictl.JSONAddCommaIfNeeded(w)
			w = append(w, `"value_sum_square":`...)
			w = basictl.JSONWriteFloat64(w, item.ValueSumSquare)
		}
	}
	if nat_fields_mask&(1<<5) != 0 {
		if len(item.Uniques) != 0 {
			w = basictl.JSONAddCommaIfNeeded(w)
			w = append(w, `"uniques":`...)
			w = basictl.JSONWriteString(w, item.Uniques)
		}
	}
	if nat_fields_mask&(1<<6) != 0 {
		if len(item.Centroids) != 0 {
			w = basictl.JSONAddCommaIfNeeded(w)
			w = append(w, `"centroids":`...)
			if w, err = VectorStatshouseCentroid0WriteJSON(w, item.Centroids); err != nil {
				return w, err
			}
		}
	}
	if nat_fields_mask&(1<<7) != 0 {
		if item.HostTag != 0 {
			w = basictl.JSONAddCommaIfNeeded(w)
			w = append(w, `"host_tag":`...)
			w = basictl.JSONWriteInt32(w, item.HostTag)
		}
	}
	return append(w, '}'), nil
}

type StatshouseMultiValueBytes struct {
	Counter float64 // Conditional: nat_fields_mask.0
	// CounterEq1 (TrueType) // Conditional: nat_fields_mask.1
	// ValueSet (TrueType) // Conditional: nat_fields_mask.2
	ValueMin       float64              // Conditional: nat_fields_mask.3
	ValueMax       float64              // Conditional: nat_fields_mask.4
	ValueSum       float64              // Conditional: nat_fields_mask.4
	ValueSumSquare float64              // Conditional: nat_fields_mask.4
	Uniques        []byte               // Conditional: nat_fields_mask.5
	Centroids      []StatshouseCentroid // Conditional: nat_fields_mask.6
	HostTag        int32                // Conditional: nat_fields_mask.7
}

func (StatshouseMultiValueBytes) TLName() string { return "statshouse.multi_value" }
func (StatshouseMultiValueBytes) TLTag() uint32  { return 0xc803e06 }

func (item *StatshouseMultiValueBytes) SetCounter(v float64, nat_fields_mask *uint32) {
	item.Counter = v
	if nat_fields_mask != nil {
		*nat_fields_mask |= 1 << 0
	}
}
func (item *StatshouseMultiValueBytes) ClearCounter(nat_fields_mask *uint32) {
	item.Counter = 0
	if nat_fields_mask != nil {
		*nat_fields_mask &^= 1 << 0
	}
}
func (item StatshouseMultiValueBytes) IsSetCounter(nat_fields_mask uint32) bool {
	return nat_fields_mask&(1<<0) != 0
}

func (item *StatshouseMultiValueBytes) SetCounterEq1(v bool, nat_fields_mask *uint32) {
	if nat_fields_mask != nil {
		if v {
			*nat_fields_mask |= 1 << 1
		} else {
			*nat_fields_mask &^= 1 << 1
		}
	}
}
func (item StatshouseMultiValueBytes) IsSetCounterEq1(nat_fields_mask uint32) bool {
	return nat_fields_mask&(1<<1) != 0
}

func (item *StatshouseMultiValueBytes) SetValueSet(v bool, nat_fields_mask *uint32) {
	if nat_fields_mask != nil {
		if v {
			*nat_fields_mask |= 1 << 2
		} else {
			*nat_fields_mask &^= 1 << 2
		}
	}
}
func (item StatshouseMultiValueBytes) IsSetValueSet(nat_fields_mask uint32) bool {
	return nat_fields_mask&(1<<2) != 0
}

func (item *StatshouseMultiValueBytes) SetValueMin(v float64, nat_fields_mask *uint32) {
	item.ValueMin = v
	if nat_fields_mask != nil {
		*nat_fields_mask |= 1 << 3
	}
}
func (item *StatshouseMultiValueBytes) ClearValueMin(nat_fields_mask *uint32) {
	item.ValueMin = 0
	if nat_fields_mask != nil {
		*nat_fields_mask &^= 1 << 3
	}
}
func (item StatshouseMultiValueBytes) IsSetValueMin(nat_fields_mask uint32) bool {
	return nat_fields_mask&(1<<3) != 0
}

func (item *StatshouseMultiValueBytes) SetValueMax(v float64, nat_fields_mask *uint32) {
	item.ValueMax = v
	if nat_fields_mask != nil {
		*nat_fields_mask |= 1 << 4
	}
}
func (item *StatshouseMultiValueBytes) ClearValueMax(nat_fields_mask *uint32) {
	item.ValueMax = 0
	if nat_fields_mask != nil {
		*nat_fields_mask &^= 1 << 4
	}
}
func (item StatshouseMultiValueBytes) IsSetValueMax(nat_fields_mask uint32) bool {
	return nat_fields_mask&(1<<4) != 0
}

func (item *StatshouseMultiValueBytes) SetValueSum(v float64, nat_fields_mask *uint32) {
	item.ValueSum = v
	if nat_fields_mask != nil {
		*nat_fields_mask |= 1 << 4
	}
}
func (item *StatshouseMultiValueBytes) ClearValueSum(nat_fields_mask *uint32) {
	item.ValueSum = 0
	if nat_fields_mask != nil {
		*nat_fields_mask &^= 1 << 4
	}
}
func (item StatshouseMultiValueBytes) IsSetValueSum(nat_fields_mask uint32) bool {
	return nat_fields_mask&(1<<4) != 0
}

func (item *StatshouseMultiValueBytes) SetValueSumSquare(v float64, nat_fields_mask *uint32) {
	item.ValueSumSquare = v
	if nat_fields_mask != nil {
		*nat_fields_mask |= 1 << 4
	}
}
func (item *StatshouseMultiValueBytes) ClearValueSumSquare(nat_fields_mask *uint32) {
	item.ValueSumSquare = 0
	if nat_fields_mask != nil {
		*nat_fields_mask &^= 1 << 4
	}
}
func (item StatshouseMultiValueBytes) IsSetValueSumSquare(nat_fields_mask uint32) bool {
	return nat_fields_mask&(1<<4) != 0
}

func (item *StatshouseMultiValueBytes) SetUniques(v []byte, nat_fields_mask *uint32) {
	item.Uniques = v
	if nat_fields_mask != nil {
		*nat_fields_mask |= 1 << 5
	}
}
func (item *StatshouseMultiValueBytes) ClearUniques(nat_fields_mask *uint32) {
	item.Uniques = item.Uniques[:0]
	if nat_fields_mask != nil {
		*nat_fields_mask &^= 1 << 5
	}
}
func (item StatshouseMultiValueBytes) IsSetUniques(nat_fields_mask uint32) bool {
	return nat_fields_mask&(1<<5) != 0
}

func (item *StatshouseMultiValueBytes) SetCentroids(v []StatshouseCentroid, nat_fields_mask *uint32) {
	item.Centroids = v
	if nat_fields_mask != nil {
		*nat_fields_mask |= 1 << 6
	}
}
func (item *StatshouseMultiValueBytes) ClearCentroids(nat_fields_mask *uint32) {
	item.Centroids = item.Centroids[:0]
	if nat_fields_mask != nil {
		*nat_fields_mask &^= 1 << 6
	}
}
func (item StatshouseMultiValueBytes) IsSetCentroids(nat_fields_mask uint32) bool {
	return nat_fields_mask&(1<<6) != 0
}

func (item *StatshouseMultiValueBytes) SetHostTag(v int32, nat_fields_mask *uint32) {
	item.HostTag = v
	if nat_fields_mask != nil {
		*nat_fields_mask |= 1 << 7
	}
}
func (item *StatshouseMultiValueBytes) ClearHostTag(nat_fields_mask *uint32) {
	item.HostTag = 0
	if nat_fields_mask != nil {
		*nat_fields_mask &^= 1 << 7
	}
}
func (item StatshouseMultiValueBytes) IsSetHostTag(nat_fields_mask uint32) bool {
	return nat_fields_mask&(1<<7) != 0
}

func (item *StatshouseMultiValueBytes) Reset() {
	item.Counter = 0
	item.ValueMin = 0
	item.ValueMax = 0
	item.ValueSum = 0
	item.ValueSumSquare = 0
	item.Uniques = item.Uniques[:0]
	item.Centroids = item.Centroids[:0]
	item.HostTag = 0
}

func (item *StatshouseMultiValueBytes) Read(w []byte, nat_fields_mask uint32) (_ []byte, err error) {
	if nat_fields_mask&(1<<0) != 0 {
		if w, err = basictl.DoubleRead(w, &item.Counter); err != nil {
			return w, err
		}
	} else {
		item.Counter = 0
	}
	if nat_fields_mask&(1<<3) != 0 {
		if w, err = basictl.DoubleRead(w, &item.ValueMin); err != nil {
			return w, err
		}
	} else {
		item.ValueMin = 0
	}
	if nat_fields_mask&(1<<4) != 0 {
		if w, err = basictl.DoubleRead(w, &item.ValueMax); err != nil {
			return w, err
		}
	} else {
		item.ValueMax = 0
	}
	if nat_fields_mask&(1<<4) != 0 {
		if w, err = basictl.DoubleRead(w, &item.ValueSum); err != nil {
			return w, err
		}
	} else {
		item.ValueSum = 0
	}
	if nat_fields_mask&(1<<4) != 0 {
		if w, err = basictl.DoubleRead(w, &item.ValueSumSquare); err != nil {
			return w, err
		}
	} else {
		item.ValueSumSquare = 0
	}
	if nat_fields_mask&(1<<5) != 0 {
		if w, err = basictl.StringReadBytes(w, &item.Uniques); err != nil {
			return w, err
		}
	} else {
		item.Uniques = item.Uniques[:0]
	}
	if nat_fields_mask&(1<<6) != 0 {
		if w, err = VectorStatshouseCentroid0Read(w, &item.Centroids); err != nil {
			return w, err
		}
	} else {
		item.Centroids = item.Centroids[:0]
	}
	if nat_fields_mask&(1<<7) != 0 {
		if w, err = basictl.IntRead(w, &item.HostTag); err != nil {
			return w, err
		}
	} else {
		item.HostTag = 0
	}
	return w, nil
}

func (item *StatshouseMultiValueBytes) Write(w []byte, nat_fields_mask uint32) (_ []byte, err error) {
	if nat_fields_mask&(1<<0) != 0 {
		w = basictl.DoubleWrite(w, item.Counter)
	}
	if nat_fields_mask&(1<<3) != 0 {
		w = basictl.DoubleWrite(w, item.ValueMin)
	}
	if nat_fields_mask&(1<<4) != 0 {
		w = basictl.DoubleWrite(w, item.ValueMax)
	}
	if nat_fields_mask&(1<<4) != 0 {
		w = basictl.DoubleWrite(w, item.ValueSum)
	}
	if nat_fields_mask&(1<<4) != 0 {
		w = basictl.DoubleWrite(w, item.ValueSumSquare)
	}
	if nat_fields_mask&(1<<5) != 0 {
		if w, err = basictl.StringWriteBytes(w, item.Uniques); err != nil {
			return w, err
		}
	}
	if nat_fields_mask&(1<<6) != 0 {
		if w, err = VectorStatshouseCentroid0Write(w, item.Centroids); err != nil {
			return w, err
		}
	}
	if nat_fields_mask&(1<<7) != 0 {
		w = basictl.IntWrite(w, item.HostTag)
	}
	return w, nil
}

func (item *StatshouseMultiValueBytes) ReadBoxed(w []byte, nat_fields_mask uint32) (_ []byte, err error) {
	if w, err = basictl.NatReadExactTag(w, 0xc803e06); err != nil {
		return w, err
	}
	return item.Read(w, nat_fields_mask)
}

func (item *StatshouseMultiValueBytes) WriteBoxed(w []byte, nat_fields_mask uint32) ([]byte, error) {
	w = basictl.NatWrite(w, 0xc803e06)
	return item.Write(w, nat_fields_mask)
}

func StatshouseMultiValueBytes__ReadJSON(item *StatshouseMultiValueBytes, j interface{}, nat_fields_mask uint32) error {
	return item.readJSON(j, nat_fields_mask)
}
func (item *StatshouseMultiValueBytes) readJSON(j interface{}, nat_fields_mask uint32) error {
	_jm, _ok := j.(map[string]interface{})
	if j != nil && !_ok {
		return ErrorInvalidJSON("statshouse.multi_value", "expected json object")
	}
	_jCounter := _jm["counter"]
	delete(_jm, "counter")
	_jCounterEq1 := _jm["counter_eq_1"]
	delete(_jm, "counter_eq_1")
	_jValueSet := _jm["value_set"]
	delete(_jm, "value_set")
	_jValueMin := _jm["value_min"]
	delete(_jm, "value_min")
	_jValueMax := _jm["value_max"]
	delete(_jm, "value_max")
	_jValueSum := _jm["value_sum"]
	delete(_jm, "value_sum")
	_jValueSumSquare := _jm["value_sum_square"]
	delete(_jm, "value_sum_square")
	_jUniques := _jm["uniques"]
	delete(_jm, "uniques")
	_jCentroids := _jm["centroids"]
	delete(_jm, "centroids")
	_jHostTag := _jm["host_tag"]
	delete(_jm, "host_tag")
	for k := range _jm {
		return ErrorInvalidJSONExcessElement("statshouse.multi_value", k)
	}
	if nat_fields_mask&(1<<0) == 0 && _jCounter != nil {
		return ErrorInvalidJSON("statshouse.multi_value", "field 'counter' is defined, while corresponding implicit fieldmask bit is 0")
	}
	if _jCounterEq1 != nil {
		return ErrorInvalidJSON("statshouse.multi_value", "implicit true field 'counter_eq_1' cannot be defined, set fieldmask instead")
	}
	if _jValueSet != nil {
		return ErrorInvalidJSON("statshouse.multi_value", "implicit true field 'value_set' cannot be defined, set fieldmask instead")
	}
	if nat_fields_mask&(1<<3) == 0 && _jValueMin != nil {
		return ErrorInvalidJSON("statshouse.multi_value", "field 'value_min' is defined, while corresponding implicit fieldmask bit is 0")
	}
	if nat_fields_mask&(1<<4) == 0 && _jValueMax != nil {
		return ErrorInvalidJSON("statshouse.multi_value", "field 'value_max' is defined, while corresponding implicit fieldmask bit is 0")
	}
	if nat_fields_mask&(1<<4) == 0 && _jValueSum != nil {
		return ErrorInvalidJSON("statshouse.multi_value", "field 'value_sum' is defined, while corresponding implicit fieldmask bit is 0")
	}
	if nat_fields_mask&(1<<4) == 0 && _jValueSumSquare != nil {
		return ErrorInvalidJSON("statshouse.multi_value", "field 'value_sum_square' is defined, while corresponding implicit fieldmask bit is 0")
	}
	if nat_fields_mask&(1<<5) == 0 && _jUniques != nil {
		return ErrorInvalidJSON("statshouse.multi_value", "field 'uniques' is defined, while corresponding implicit fieldmask bit is 0")
	}
	if nat_fields_mask&(1<<6) == 0 && _jCentroids != nil {
		return ErrorInvalidJSON("statshouse.multi_value", "field 'centroids' is defined, while corresponding implicit fieldmask bit is 0")
	}
	if nat_fields_mask&(1<<7) == 0 && _jHostTag != nil {
		return ErrorInvalidJSON("statshouse.multi_value", "field 'host_tag' is defined, while corresponding implicit fieldmask bit is 0")
	}
	if nat_fields_mask&(1<<0) != 0 {
		if err := JsonReadFloat64(_jCounter, &item.Counter); err != nil {
			return err
		}
	} else {
		item.Counter = 0
	}
	if nat_fields_mask&(1<<3) != 0 {
		if err := JsonReadFloat64(_jValueMin, &item.ValueMin); err != nil {
			return err
		}
	} else {
		item.ValueMin = 0
	}
	if nat_fields_mask&(1<<4) != 0 {
		if err := JsonReadFloat64(_jValueMax, &item.ValueMax); err != nil {
			return err
		}
	} else {
		item.ValueMax = 0
	}
	if nat_fields_mask&(1<<4) != 0 {
		if err := JsonReadFloat64(_jValueSum, &item.ValueSum); err != nil {
			return err
		}
	} else {
		item.ValueSum = 0
	}
	if nat_fields_mask&(1<<4) != 0 {
		if err := JsonReadFloat64(_jValueSumSquare, &item.ValueSumSquare); err != nil {
			return err
		}
	} else {
		item.ValueSumSquare = 0
	}
	if nat_fields_mask&(1<<5) != 0 {
		if err := JsonReadStringBytes(_jUniques, &item.Uniques); err != nil {
			return err
		}
	} else {
		item.Uniques = item.Uniques[:0]
	}
	if nat_fields_mask&(1<<6) != 0 {
		if err := VectorStatshouseCentroid0ReadJSON(_jCentroids, &item.Centroids); err != nil {
			return err
		}
	} else {
		item.Centroids = item.Centroids[:0]
	}
	if nat_fields_mask&(1<<7) != 0 {
		if err := JsonReadInt32(_jHostTag, &item.HostTag); err != nil {
			return err
		}
	} else {
		item.HostTag = 0
	}
	return nil
}

func (item *StatshouseMultiValueBytes) WriteJSON(w []byte, nat_fields_mask uint32) (_ []byte, err error) {
	w = append(w, '{')
	if nat_fields_mask&(1<<0) != 0 {
		if item.Counter != 0 {
			w = basictl.JSONAddCommaIfNeeded(w)
			w = append(w, `"counter":`...)
			w = basictl.JSONWriteFloat64(w, item.Counter)
		}
	}
	if nat_fields_mask&(1<<3) != 0 {
		if item.ValueMin != 0 {
			w = basictl.JSONAddCommaIfNeeded(w)
			w = append(w, `"value_min":`...)
			w = basictl.JSONWriteFloat64(w, item.ValueMin)
		}
	}
	if nat_fields_mask&(1<<4) != 0 {
		if item.ValueMax != 0 {
			w = basictl.JSONAddCommaIfNeeded(w)
			w = append(w, `"value_max":`...)
			w = basictl.JSONWriteFloat64(w, item.ValueMax)
		}
	}
	if nat_fields_mask&(1<<4) != 0 {
		if item.ValueSum != 0 {
			w = basictl.JSONAddCommaIfNeeded(w)
			w = append(w, `"value_sum":`...)
			w = basictl.JSONWriteFloat64(w, item.ValueSum)
		}
	}
	if nat_fields_mask&(1<<4) != 0 {
		if item.ValueSumSquare != 0 {
			w = basictl.JSONAddCommaIfNeeded(w)
			w = append(w, `"value_sum_square":`...)
			w = basictl.JSONWriteFloat64(w, item.ValueSumSquare)
		}
	}
	if nat_fields_mask&(1<<5) != 0 {
		if len(item.Uniques) != 0 {
			w = basictl.JSONAddCommaIfNeeded(w)
			w = append(w, `"uniques":`...)
			w = basictl.JSONWriteStringBytes(w, item.Uniques)
		}
	}
	if nat_fields_mask&(1<<6) != 0 {
		if len(item.Centroids) != 0 {
			w = basictl.JSONAddCommaIfNeeded(w)
			w = append(w, `"centroids":`...)
			if w, err = VectorStatshouseCentroid0WriteJSON(w, item.Centroids); err != nil {
				return w, err
			}
		}
	}
	if nat_fields_mask&(1<<7) != 0 {
		if item.HostTag != 0 {
			w = basictl.JSONAddCommaIfNeeded(w)
			w = append(w, `"host_tag":`...)
			w = basictl.JSONWriteInt32(w, item.HostTag)
		}
	}
	return append(w, '}'), nil
}
