// Copyright 2023 V Kontakte LLC
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

// Code generated by vktl/cmd/tlgen2; DO NOT EDIT.
package internal

import (
	"github.com/vkcom/statshouse/internal/vkgo/basictl"
)

var _ = basictl.NatWrite

type StatshouseMultiValue struct {
	Counter float64 // Conditional: nat_fields_mask.0
	// CounterEq1 (TrueType) // Conditional: nat_fields_mask.1
	// ValueSet (TrueType) // Conditional: nat_fields_mask.2
	ValueMin          float64                   // Conditional: nat_fields_mask.3
	ValueMax          float64                   // Conditional: nat_fields_mask.4
	ValueSum          float64                   // Conditional: nat_fields_mask.4
	ValueSumSquare    float64                   // Conditional: nat_fields_mask.4
	Uniques           string                    // Conditional: nat_fields_mask.5
	Centroids         []StatshouseCentroidFloat // Conditional: nat_fields_mask.6
	MaxHostTag        int32                     // Conditional: nat_fields_mask.7
	MinHostTag        int32                     // Conditional: nat_fields_mask.8
	MaxCounterHostTag int32                     // Conditional: nat_fields_mask.9
}

func (StatshouseMultiValue) TLName() string { return "statshouse.multi_value" }
func (StatshouseMultiValue) TLTag() uint32  { return 0x0c803e06 }

func (item *StatshouseMultiValue) SetCounter(v float64, nat_fields_mask *uint32) {
	item.Counter = v
	if nat_fields_mask != nil {
		*nat_fields_mask |= 1 << 0
	}
}
func (item *StatshouseMultiValue) ClearCounter(nat_fields_mask *uint32) {
	item.Counter = 0
	if nat_fields_mask != nil {
		*nat_fields_mask &^= 1 << 0
	}
}
func (item StatshouseMultiValue) IsSetCounter(nat_fields_mask uint32) bool {
	return nat_fields_mask&(1<<0) != 0
}

func (item *StatshouseMultiValue) SetCounterEq1(v bool, nat_fields_mask *uint32) {
	if nat_fields_mask != nil {
		if v {
			*nat_fields_mask |= 1 << 1
		} else {
			*nat_fields_mask &^= 1 << 1
		}
	}
}
func (item StatshouseMultiValue) IsSetCounterEq1(nat_fields_mask uint32) bool {
	return nat_fields_mask&(1<<1) != 0
}

func (item *StatshouseMultiValue) SetValueSet(v bool, nat_fields_mask *uint32) {
	if nat_fields_mask != nil {
		if v {
			*nat_fields_mask |= 1 << 2
		} else {
			*nat_fields_mask &^= 1 << 2
		}
	}
}
func (item StatshouseMultiValue) IsSetValueSet(nat_fields_mask uint32) bool {
	return nat_fields_mask&(1<<2) != 0
}

func (item *StatshouseMultiValue) SetValueMin(v float64, nat_fields_mask *uint32) {
	item.ValueMin = v
	if nat_fields_mask != nil {
		*nat_fields_mask |= 1 << 3
	}
}
func (item *StatshouseMultiValue) ClearValueMin(nat_fields_mask *uint32) {
	item.ValueMin = 0
	if nat_fields_mask != nil {
		*nat_fields_mask &^= 1 << 3
	}
}
func (item StatshouseMultiValue) IsSetValueMin(nat_fields_mask uint32) bool {
	return nat_fields_mask&(1<<3) != 0
}

func (item *StatshouseMultiValue) SetValueMax(v float64, nat_fields_mask *uint32) {
	item.ValueMax = v
	if nat_fields_mask != nil {
		*nat_fields_mask |= 1 << 4
	}
}
func (item *StatshouseMultiValue) ClearValueMax(nat_fields_mask *uint32) {
	item.ValueMax = 0
	if nat_fields_mask != nil {
		*nat_fields_mask &^= 1 << 4
	}
}
func (item StatshouseMultiValue) IsSetValueMax(nat_fields_mask uint32) bool {
	return nat_fields_mask&(1<<4) != 0
}

func (item *StatshouseMultiValue) SetValueSum(v float64, nat_fields_mask *uint32) {
	item.ValueSum = v
	if nat_fields_mask != nil {
		*nat_fields_mask |= 1 << 4
	}
}
func (item *StatshouseMultiValue) ClearValueSum(nat_fields_mask *uint32) {
	item.ValueSum = 0
	if nat_fields_mask != nil {
		*nat_fields_mask &^= 1 << 4
	}
}
func (item StatshouseMultiValue) IsSetValueSum(nat_fields_mask uint32) bool {
	return nat_fields_mask&(1<<4) != 0
}

func (item *StatshouseMultiValue) SetValueSumSquare(v float64, nat_fields_mask *uint32) {
	item.ValueSumSquare = v
	if nat_fields_mask != nil {
		*nat_fields_mask |= 1 << 4
	}
}
func (item *StatshouseMultiValue) ClearValueSumSquare(nat_fields_mask *uint32) {
	item.ValueSumSquare = 0
	if nat_fields_mask != nil {
		*nat_fields_mask &^= 1 << 4
	}
}
func (item StatshouseMultiValue) IsSetValueSumSquare(nat_fields_mask uint32) bool {
	return nat_fields_mask&(1<<4) != 0
}

func (item *StatshouseMultiValue) SetUniques(v string, nat_fields_mask *uint32) {
	item.Uniques = v
	if nat_fields_mask != nil {
		*nat_fields_mask |= 1 << 5
	}
}
func (item *StatshouseMultiValue) ClearUniques(nat_fields_mask *uint32) {
	item.Uniques = ""
	if nat_fields_mask != nil {
		*nat_fields_mask &^= 1 << 5
	}
}
func (item StatshouseMultiValue) IsSetUniques(nat_fields_mask uint32) bool {
	return nat_fields_mask&(1<<5) != 0
}

func (item *StatshouseMultiValue) SetCentroids(v []StatshouseCentroidFloat, nat_fields_mask *uint32) {
	item.Centroids = v
	if nat_fields_mask != nil {
		*nat_fields_mask |= 1 << 6
	}
}
func (item *StatshouseMultiValue) ClearCentroids(nat_fields_mask *uint32) {
	item.Centroids = item.Centroids[:0]
	if nat_fields_mask != nil {
		*nat_fields_mask &^= 1 << 6
	}
}
func (item StatshouseMultiValue) IsSetCentroids(nat_fields_mask uint32) bool {
	return nat_fields_mask&(1<<6) != 0
}

func (item *StatshouseMultiValue) SetMaxHostTag(v int32, nat_fields_mask *uint32) {
	item.MaxHostTag = v
	if nat_fields_mask != nil {
		*nat_fields_mask |= 1 << 7
	}
}
func (item *StatshouseMultiValue) ClearMaxHostTag(nat_fields_mask *uint32) {
	item.MaxHostTag = 0
	if nat_fields_mask != nil {
		*nat_fields_mask &^= 1 << 7
	}
}
func (item StatshouseMultiValue) IsSetMaxHostTag(nat_fields_mask uint32) bool {
	return nat_fields_mask&(1<<7) != 0
}

func (item *StatshouseMultiValue) SetMinHostTag(v int32, nat_fields_mask *uint32) {
	item.MinHostTag = v
	if nat_fields_mask != nil {
		*nat_fields_mask |= 1 << 8
	}
}
func (item *StatshouseMultiValue) ClearMinHostTag(nat_fields_mask *uint32) {
	item.MinHostTag = 0
	if nat_fields_mask != nil {
		*nat_fields_mask &^= 1 << 8
	}
}
func (item StatshouseMultiValue) IsSetMinHostTag(nat_fields_mask uint32) bool {
	return nat_fields_mask&(1<<8) != 0
}

func (item *StatshouseMultiValue) SetMaxCounterHostTag(v int32, nat_fields_mask *uint32) {
	item.MaxCounterHostTag = v
	if nat_fields_mask != nil {
		*nat_fields_mask |= 1 << 9
	}
}
func (item *StatshouseMultiValue) ClearMaxCounterHostTag(nat_fields_mask *uint32) {
	item.MaxCounterHostTag = 0
	if nat_fields_mask != nil {
		*nat_fields_mask &^= 1 << 9
	}
}
func (item StatshouseMultiValue) IsSetMaxCounterHostTag(nat_fields_mask uint32) bool {
	return nat_fields_mask&(1<<9) != 0
}

func (item *StatshouseMultiValue) Reset() {
	item.Counter = 0
	item.ValueMin = 0
	item.ValueMax = 0
	item.ValueSum = 0
	item.ValueSumSquare = 0
	item.Uniques = ""
	item.Centroids = item.Centroids[:0]
	item.MaxHostTag = 0
	item.MinHostTag = 0
	item.MaxCounterHostTag = 0
}

func (item *StatshouseMultiValue) Read(w []byte, nat_fields_mask uint32) (_ []byte, err error) {
	if nat_fields_mask&(1<<0) != 0 {
		if w, err = basictl.DoubleRead(w, &item.Counter); err != nil {
			return w, err
		}
	} else {
		item.Counter = 0
	}
	if nat_fields_mask&(1<<3) != 0 {
		if w, err = basictl.DoubleRead(w, &item.ValueMin); err != nil {
			return w, err
		}
	} else {
		item.ValueMin = 0
	}
	if nat_fields_mask&(1<<4) != 0 {
		if w, err = basictl.DoubleRead(w, &item.ValueMax); err != nil {
			return w, err
		}
	} else {
		item.ValueMax = 0
	}
	if nat_fields_mask&(1<<4) != 0 {
		if w, err = basictl.DoubleRead(w, &item.ValueSum); err != nil {
			return w, err
		}
	} else {
		item.ValueSum = 0
	}
	if nat_fields_mask&(1<<4) != 0 {
		if w, err = basictl.DoubleRead(w, &item.ValueSumSquare); err != nil {
			return w, err
		}
	} else {
		item.ValueSumSquare = 0
	}
	if nat_fields_mask&(1<<5) != 0 {
		if w, err = basictl.StringRead(w, &item.Uniques); err != nil {
			return w, err
		}
	} else {
		item.Uniques = ""
	}
	if nat_fields_mask&(1<<6) != 0 {
		if w, err = BuiltinVectorStatshouseCentroidFloatRead(w, &item.Centroids); err != nil {
			return w, err
		}
	} else {
		item.Centroids = item.Centroids[:0]
	}
	if nat_fields_mask&(1<<7) != 0 {
		if w, err = basictl.IntRead(w, &item.MaxHostTag); err != nil {
			return w, err
		}
	} else {
		item.MaxHostTag = 0
	}
	if nat_fields_mask&(1<<8) != 0 {
		if w, err = basictl.IntRead(w, &item.MinHostTag); err != nil {
			return w, err
		}
	} else {
		item.MinHostTag = 0
	}
	if nat_fields_mask&(1<<9) != 0 {
		if w, err = basictl.IntRead(w, &item.MaxCounterHostTag); err != nil {
			return w, err
		}
	} else {
		item.MaxCounterHostTag = 0
	}
	return w, nil
}

// This method is general version of Write, use it instead!
func (item *StatshouseMultiValue) WriteGeneral(w []byte, nat_fields_mask uint32) (_ []byte, err error) {
	return item.Write(w, nat_fields_mask), nil
}

func (item *StatshouseMultiValue) Write(w []byte, nat_fields_mask uint32) []byte {
	if nat_fields_mask&(1<<0) != 0 {
		w = basictl.DoubleWrite(w, item.Counter)
	}
	if nat_fields_mask&(1<<3) != 0 {
		w = basictl.DoubleWrite(w, item.ValueMin)
	}
	if nat_fields_mask&(1<<4) != 0 {
		w = basictl.DoubleWrite(w, item.ValueMax)
	}
	if nat_fields_mask&(1<<4) != 0 {
		w = basictl.DoubleWrite(w, item.ValueSum)
	}
	if nat_fields_mask&(1<<4) != 0 {
		w = basictl.DoubleWrite(w, item.ValueSumSquare)
	}
	if nat_fields_mask&(1<<5) != 0 {
		w = basictl.StringWrite(w, item.Uniques)
	}
	if nat_fields_mask&(1<<6) != 0 {
		w = BuiltinVectorStatshouseCentroidFloatWrite(w, item.Centroids)
	}
	if nat_fields_mask&(1<<7) != 0 {
		w = basictl.IntWrite(w, item.MaxHostTag)
	}
	if nat_fields_mask&(1<<8) != 0 {
		w = basictl.IntWrite(w, item.MinHostTag)
	}
	if nat_fields_mask&(1<<9) != 0 {
		w = basictl.IntWrite(w, item.MaxCounterHostTag)
	}
	return w
}

func (item *StatshouseMultiValue) ReadBoxed(w []byte, nat_fields_mask uint32) (_ []byte, err error) {
	if w, err = basictl.NatReadExactTag(w, 0x0c803e06); err != nil {
		return w, err
	}
	return item.Read(w, nat_fields_mask)
}

// This method is general version of WriteBoxed, use it instead!
func (item *StatshouseMultiValue) WriteBoxedGeneral(w []byte, nat_fields_mask uint32) (_ []byte, err error) {
	return item.WriteBoxed(w, nat_fields_mask), nil
}

func (item *StatshouseMultiValue) WriteBoxed(w []byte, nat_fields_mask uint32) []byte {
	w = basictl.NatWrite(w, 0x0c803e06)
	return item.Write(w, nat_fields_mask)
}

func (item *StatshouseMultiValue) ReadJSON(legacyTypeNames bool, in *basictl.JsonLexer, nat_fields_mask uint32) error {
	var propCounterPresented bool
	var propValueMinPresented bool
	var propValueMaxPresented bool
	var propValueSumPresented bool
	var propValueSumSquarePresented bool
	var propUniquesPresented bool
	var propCentroidsPresented bool
	var propMaxHostTagPresented bool
	var propMinHostTagPresented bool
	var propMaxCounterHostTagPresented bool

	if in != nil {
		in.Delim('{')
		if !in.Ok() {
			return in.Error()
		}
		for !in.IsDelim('}') {
			key := in.UnsafeFieldName(true)
			in.WantColon()
			switch key {
			case "counter":
				if propCounterPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.multi_value", "counter")
				}
				if nat_fields_mask&(1<<0) == 0 {
					return ErrorInvalidJSON("statshouse.multi_value", "field 'counter' is defined, while corresponding implicit fieldmask bit is 0")
				}
				if err := Json2ReadFloat64(in, &item.Counter); err != nil {
					return err
				}
				propCounterPresented = true
			case "counter_eq_1":
				return ErrorInvalidJSON("statshouse.multi_value", "implicit true field 'counter_eq_1' cannot be defined, set fieldmask instead")
			case "value_set":
				return ErrorInvalidJSON("statshouse.multi_value", "implicit true field 'value_set' cannot be defined, set fieldmask instead")
			case "value_min":
				if propValueMinPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.multi_value", "value_min")
				}
				if nat_fields_mask&(1<<3) == 0 {
					return ErrorInvalidJSON("statshouse.multi_value", "field 'value_min' is defined, while corresponding implicit fieldmask bit is 0")
				}
				if err := Json2ReadFloat64(in, &item.ValueMin); err != nil {
					return err
				}
				propValueMinPresented = true
			case "value_max":
				if propValueMaxPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.multi_value", "value_max")
				}
				if nat_fields_mask&(1<<4) == 0 {
					return ErrorInvalidJSON("statshouse.multi_value", "field 'value_max' is defined, while corresponding implicit fieldmask bit is 0")
				}
				if err := Json2ReadFloat64(in, &item.ValueMax); err != nil {
					return err
				}
				propValueMaxPresented = true
			case "value_sum":
				if propValueSumPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.multi_value", "value_sum")
				}
				if nat_fields_mask&(1<<4) == 0 {
					return ErrorInvalidJSON("statshouse.multi_value", "field 'value_sum' is defined, while corresponding implicit fieldmask bit is 0")
				}
				if err := Json2ReadFloat64(in, &item.ValueSum); err != nil {
					return err
				}
				propValueSumPresented = true
			case "value_sum_square":
				if propValueSumSquarePresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.multi_value", "value_sum_square")
				}
				if nat_fields_mask&(1<<4) == 0 {
					return ErrorInvalidJSON("statshouse.multi_value", "field 'value_sum_square' is defined, while corresponding implicit fieldmask bit is 0")
				}
				if err := Json2ReadFloat64(in, &item.ValueSumSquare); err != nil {
					return err
				}
				propValueSumSquarePresented = true
			case "uniques":
				if propUniquesPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.multi_value", "uniques")
				}
				if nat_fields_mask&(1<<5) == 0 {
					return ErrorInvalidJSON("statshouse.multi_value", "field 'uniques' is defined, while corresponding implicit fieldmask bit is 0")
				}
				if err := Json2ReadString(in, &item.Uniques); err != nil {
					return err
				}
				propUniquesPresented = true
			case "centroids":
				if propCentroidsPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.multi_value", "centroids")
				}
				if nat_fields_mask&(1<<6) == 0 {
					return ErrorInvalidJSON("statshouse.multi_value", "field 'centroids' is defined, while corresponding implicit fieldmask bit is 0")
				}
				if err := BuiltinVectorStatshouseCentroidFloatReadJSON(legacyTypeNames, in, &item.Centroids); err != nil {
					return err
				}
				propCentroidsPresented = true
			case "max_host_tag":
				if propMaxHostTagPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.multi_value", "max_host_tag")
				}
				if nat_fields_mask&(1<<7) == 0 {
					return ErrorInvalidJSON("statshouse.multi_value", "field 'max_host_tag' is defined, while corresponding implicit fieldmask bit is 0")
				}
				if err := Json2ReadInt32(in, &item.MaxHostTag); err != nil {
					return err
				}
				propMaxHostTagPresented = true
			case "min_host_tag":
				if propMinHostTagPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.multi_value", "min_host_tag")
				}
				if nat_fields_mask&(1<<8) == 0 {
					return ErrorInvalidJSON("statshouse.multi_value", "field 'min_host_tag' is defined, while corresponding implicit fieldmask bit is 0")
				}
				if err := Json2ReadInt32(in, &item.MinHostTag); err != nil {
					return err
				}
				propMinHostTagPresented = true
			case "max_counter_host_tag":
				if propMaxCounterHostTagPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.multi_value", "max_counter_host_tag")
				}
				if nat_fields_mask&(1<<9) == 0 {
					return ErrorInvalidJSON("statshouse.multi_value", "field 'max_counter_host_tag' is defined, while corresponding implicit fieldmask bit is 0")
				}
				if err := Json2ReadInt32(in, &item.MaxCounterHostTag); err != nil {
					return err
				}
				propMaxCounterHostTagPresented = true
			default:
				return ErrorInvalidJSONExcessElement("statshouse.multi_value", key)
			}
			in.WantComma()
		}
		in.Delim('}')
		if !in.Ok() {
			return in.Error()
		}
	}
	if !propCounterPresented {
		item.Counter = 0
	}
	if !propValueMinPresented {
		item.ValueMin = 0
	}
	if !propValueMaxPresented {
		item.ValueMax = 0
	}
	if !propValueSumPresented {
		item.ValueSum = 0
	}
	if !propValueSumSquarePresented {
		item.ValueSumSquare = 0
	}
	if !propUniquesPresented {
		item.Uniques = ""
	}
	if !propCentroidsPresented {
		item.Centroids = item.Centroids[:0]
	}
	if !propMaxHostTagPresented {
		item.MaxHostTag = 0
	}
	if !propMinHostTagPresented {
		item.MinHostTag = 0
	}
	if !propMaxCounterHostTagPresented {
		item.MaxCounterHostTag = 0
	}
	return nil
}

// This method is general version of WriteJSON, use it instead!
func (item *StatshouseMultiValue) WriteJSONGeneral(w []byte, nat_fields_mask uint32) (_ []byte, err error) {
	return item.WriteJSONOpt(true, false, w, nat_fields_mask), nil
}

func (item *StatshouseMultiValue) WriteJSON(w []byte, nat_fields_mask uint32) []byte {
	return item.WriteJSONOpt(true, false, w, nat_fields_mask)
}
func (item *StatshouseMultiValue) WriteJSONOpt(newTypeNames bool, short bool, w []byte, nat_fields_mask uint32) []byte {
	w = append(w, '{')
	if nat_fields_mask&(1<<0) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"counter":`...)
		w = basictl.JSONWriteFloat64(w, item.Counter)
	}
	if nat_fields_mask&(1<<3) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"value_min":`...)
		w = basictl.JSONWriteFloat64(w, item.ValueMin)
	}
	if nat_fields_mask&(1<<4) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"value_max":`...)
		w = basictl.JSONWriteFloat64(w, item.ValueMax)
	}
	if nat_fields_mask&(1<<4) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"value_sum":`...)
		w = basictl.JSONWriteFloat64(w, item.ValueSum)
	}
	if nat_fields_mask&(1<<4) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"value_sum_square":`...)
		w = basictl.JSONWriteFloat64(w, item.ValueSumSquare)
	}
	if nat_fields_mask&(1<<5) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"uniques":`...)
		w = basictl.JSONWriteString(w, item.Uniques)
	}
	if nat_fields_mask&(1<<6) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"centroids":`...)
		w = BuiltinVectorStatshouseCentroidFloatWriteJSONOpt(newTypeNames, short, w, item.Centroids)
	}
	if nat_fields_mask&(1<<7) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"max_host_tag":`...)
		w = basictl.JSONWriteInt32(w, item.MaxHostTag)
	}
	if nat_fields_mask&(1<<8) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"min_host_tag":`...)
		w = basictl.JSONWriteInt32(w, item.MinHostTag)
	}
	if nat_fields_mask&(1<<9) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"max_counter_host_tag":`...)
		w = basictl.JSONWriteInt32(w, item.MaxCounterHostTag)
	}
	return append(w, '}')
}

type StatshouseMultiValueBytes struct {
	Counter float64 // Conditional: nat_fields_mask.0
	// CounterEq1 (TrueType) // Conditional: nat_fields_mask.1
	// ValueSet (TrueType) // Conditional: nat_fields_mask.2
	ValueMin          float64                   // Conditional: nat_fields_mask.3
	ValueMax          float64                   // Conditional: nat_fields_mask.4
	ValueSum          float64                   // Conditional: nat_fields_mask.4
	ValueSumSquare    float64                   // Conditional: nat_fields_mask.4
	Uniques           []byte                    // Conditional: nat_fields_mask.5
	Centroids         []StatshouseCentroidFloat // Conditional: nat_fields_mask.6
	MaxHostTag        int32                     // Conditional: nat_fields_mask.7
	MinHostTag        int32                     // Conditional: nat_fields_mask.8
	MaxCounterHostTag int32                     // Conditional: nat_fields_mask.9
}

func (StatshouseMultiValueBytes) TLName() string { return "statshouse.multi_value" }
func (StatshouseMultiValueBytes) TLTag() uint32  { return 0x0c803e06 }

func (item *StatshouseMultiValueBytes) SetCounter(v float64, nat_fields_mask *uint32) {
	item.Counter = v
	if nat_fields_mask != nil {
		*nat_fields_mask |= 1 << 0
	}
}
func (item *StatshouseMultiValueBytes) ClearCounter(nat_fields_mask *uint32) {
	item.Counter = 0
	if nat_fields_mask != nil {
		*nat_fields_mask &^= 1 << 0
	}
}
func (item StatshouseMultiValueBytes) IsSetCounter(nat_fields_mask uint32) bool {
	return nat_fields_mask&(1<<0) != 0
}

func (item *StatshouseMultiValueBytes) SetCounterEq1(v bool, nat_fields_mask *uint32) {
	if nat_fields_mask != nil {
		if v {
			*nat_fields_mask |= 1 << 1
		} else {
			*nat_fields_mask &^= 1 << 1
		}
	}
}
func (item StatshouseMultiValueBytes) IsSetCounterEq1(nat_fields_mask uint32) bool {
	return nat_fields_mask&(1<<1) != 0
}

func (item *StatshouseMultiValueBytes) SetValueSet(v bool, nat_fields_mask *uint32) {
	if nat_fields_mask != nil {
		if v {
			*nat_fields_mask |= 1 << 2
		} else {
			*nat_fields_mask &^= 1 << 2
		}
	}
}
func (item StatshouseMultiValueBytes) IsSetValueSet(nat_fields_mask uint32) bool {
	return nat_fields_mask&(1<<2) != 0
}

func (item *StatshouseMultiValueBytes) SetValueMin(v float64, nat_fields_mask *uint32) {
	item.ValueMin = v
	if nat_fields_mask != nil {
		*nat_fields_mask |= 1 << 3
	}
}
func (item *StatshouseMultiValueBytes) ClearValueMin(nat_fields_mask *uint32) {
	item.ValueMin = 0
	if nat_fields_mask != nil {
		*nat_fields_mask &^= 1 << 3
	}
}
func (item StatshouseMultiValueBytes) IsSetValueMin(nat_fields_mask uint32) bool {
	return nat_fields_mask&(1<<3) != 0
}

func (item *StatshouseMultiValueBytes) SetValueMax(v float64, nat_fields_mask *uint32) {
	item.ValueMax = v
	if nat_fields_mask != nil {
		*nat_fields_mask |= 1 << 4
	}
}
func (item *StatshouseMultiValueBytes) ClearValueMax(nat_fields_mask *uint32) {
	item.ValueMax = 0
	if nat_fields_mask != nil {
		*nat_fields_mask &^= 1 << 4
	}
}
func (item StatshouseMultiValueBytes) IsSetValueMax(nat_fields_mask uint32) bool {
	return nat_fields_mask&(1<<4) != 0
}

func (item *StatshouseMultiValueBytes) SetValueSum(v float64, nat_fields_mask *uint32) {
	item.ValueSum = v
	if nat_fields_mask != nil {
		*nat_fields_mask |= 1 << 4
	}
}
func (item *StatshouseMultiValueBytes) ClearValueSum(nat_fields_mask *uint32) {
	item.ValueSum = 0
	if nat_fields_mask != nil {
		*nat_fields_mask &^= 1 << 4
	}
}
func (item StatshouseMultiValueBytes) IsSetValueSum(nat_fields_mask uint32) bool {
	return nat_fields_mask&(1<<4) != 0
}

func (item *StatshouseMultiValueBytes) SetValueSumSquare(v float64, nat_fields_mask *uint32) {
	item.ValueSumSquare = v
	if nat_fields_mask != nil {
		*nat_fields_mask |= 1 << 4
	}
}
func (item *StatshouseMultiValueBytes) ClearValueSumSquare(nat_fields_mask *uint32) {
	item.ValueSumSquare = 0
	if nat_fields_mask != nil {
		*nat_fields_mask &^= 1 << 4
	}
}
func (item StatshouseMultiValueBytes) IsSetValueSumSquare(nat_fields_mask uint32) bool {
	return nat_fields_mask&(1<<4) != 0
}

func (item *StatshouseMultiValueBytes) SetUniques(v []byte, nat_fields_mask *uint32) {
	item.Uniques = v
	if nat_fields_mask != nil {
		*nat_fields_mask |= 1 << 5
	}
}
func (item *StatshouseMultiValueBytes) ClearUniques(nat_fields_mask *uint32) {
	item.Uniques = item.Uniques[:0]
	if nat_fields_mask != nil {
		*nat_fields_mask &^= 1 << 5
	}
}
func (item StatshouseMultiValueBytes) IsSetUniques(nat_fields_mask uint32) bool {
	return nat_fields_mask&(1<<5) != 0
}

func (item *StatshouseMultiValueBytes) SetCentroids(v []StatshouseCentroidFloat, nat_fields_mask *uint32) {
	item.Centroids = v
	if nat_fields_mask != nil {
		*nat_fields_mask |= 1 << 6
	}
}
func (item *StatshouseMultiValueBytes) ClearCentroids(nat_fields_mask *uint32) {
	item.Centroids = item.Centroids[:0]
	if nat_fields_mask != nil {
		*nat_fields_mask &^= 1 << 6
	}
}
func (item StatshouseMultiValueBytes) IsSetCentroids(nat_fields_mask uint32) bool {
	return nat_fields_mask&(1<<6) != 0
}

func (item *StatshouseMultiValueBytes) SetMaxHostTag(v int32, nat_fields_mask *uint32) {
	item.MaxHostTag = v
	if nat_fields_mask != nil {
		*nat_fields_mask |= 1 << 7
	}
}
func (item *StatshouseMultiValueBytes) ClearMaxHostTag(nat_fields_mask *uint32) {
	item.MaxHostTag = 0
	if nat_fields_mask != nil {
		*nat_fields_mask &^= 1 << 7
	}
}
func (item StatshouseMultiValueBytes) IsSetMaxHostTag(nat_fields_mask uint32) bool {
	return nat_fields_mask&(1<<7) != 0
}

func (item *StatshouseMultiValueBytes) SetMinHostTag(v int32, nat_fields_mask *uint32) {
	item.MinHostTag = v
	if nat_fields_mask != nil {
		*nat_fields_mask |= 1 << 8
	}
}
func (item *StatshouseMultiValueBytes) ClearMinHostTag(nat_fields_mask *uint32) {
	item.MinHostTag = 0
	if nat_fields_mask != nil {
		*nat_fields_mask &^= 1 << 8
	}
}
func (item StatshouseMultiValueBytes) IsSetMinHostTag(nat_fields_mask uint32) bool {
	return nat_fields_mask&(1<<8) != 0
}

func (item *StatshouseMultiValueBytes) SetMaxCounterHostTag(v int32, nat_fields_mask *uint32) {
	item.MaxCounterHostTag = v
	if nat_fields_mask != nil {
		*nat_fields_mask |= 1 << 9
	}
}
func (item *StatshouseMultiValueBytes) ClearMaxCounterHostTag(nat_fields_mask *uint32) {
	item.MaxCounterHostTag = 0
	if nat_fields_mask != nil {
		*nat_fields_mask &^= 1 << 9
	}
}
func (item StatshouseMultiValueBytes) IsSetMaxCounterHostTag(nat_fields_mask uint32) bool {
	return nat_fields_mask&(1<<9) != 0
}

func (item *StatshouseMultiValueBytes) Reset() {
	item.Counter = 0
	item.ValueMin = 0
	item.ValueMax = 0
	item.ValueSum = 0
	item.ValueSumSquare = 0
	item.Uniques = item.Uniques[:0]
	item.Centroids = item.Centroids[:0]
	item.MaxHostTag = 0
	item.MinHostTag = 0
	item.MaxCounterHostTag = 0
}

func (item *StatshouseMultiValueBytes) Read(w []byte, nat_fields_mask uint32) (_ []byte, err error) {
	if nat_fields_mask&(1<<0) != 0 {
		if w, err = basictl.DoubleRead(w, &item.Counter); err != nil {
			return w, err
		}
	} else {
		item.Counter = 0
	}
	if nat_fields_mask&(1<<3) != 0 {
		if w, err = basictl.DoubleRead(w, &item.ValueMin); err != nil {
			return w, err
		}
	} else {
		item.ValueMin = 0
	}
	if nat_fields_mask&(1<<4) != 0 {
		if w, err = basictl.DoubleRead(w, &item.ValueMax); err != nil {
			return w, err
		}
	} else {
		item.ValueMax = 0
	}
	if nat_fields_mask&(1<<4) != 0 {
		if w, err = basictl.DoubleRead(w, &item.ValueSum); err != nil {
			return w, err
		}
	} else {
		item.ValueSum = 0
	}
	if nat_fields_mask&(1<<4) != 0 {
		if w, err = basictl.DoubleRead(w, &item.ValueSumSquare); err != nil {
			return w, err
		}
	} else {
		item.ValueSumSquare = 0
	}
	if nat_fields_mask&(1<<5) != 0 {
		if w, err = basictl.StringReadBytes(w, &item.Uniques); err != nil {
			return w, err
		}
	} else {
		item.Uniques = item.Uniques[:0]
	}
	if nat_fields_mask&(1<<6) != 0 {
		if w, err = BuiltinVectorStatshouseCentroidFloatRead(w, &item.Centroids); err != nil {
			return w, err
		}
	} else {
		item.Centroids = item.Centroids[:0]
	}
	if nat_fields_mask&(1<<7) != 0 {
		if w, err = basictl.IntRead(w, &item.MaxHostTag); err != nil {
			return w, err
		}
	} else {
		item.MaxHostTag = 0
	}
	if nat_fields_mask&(1<<8) != 0 {
		if w, err = basictl.IntRead(w, &item.MinHostTag); err != nil {
			return w, err
		}
	} else {
		item.MinHostTag = 0
	}
	if nat_fields_mask&(1<<9) != 0 {
		if w, err = basictl.IntRead(w, &item.MaxCounterHostTag); err != nil {
			return w, err
		}
	} else {
		item.MaxCounterHostTag = 0
	}
	return w, nil
}

// This method is general version of Write, use it instead!
func (item *StatshouseMultiValueBytes) WriteGeneral(w []byte, nat_fields_mask uint32) (_ []byte, err error) {
	return item.Write(w, nat_fields_mask), nil
}

func (item *StatshouseMultiValueBytes) Write(w []byte, nat_fields_mask uint32) []byte {
	if nat_fields_mask&(1<<0) != 0 {
		w = basictl.DoubleWrite(w, item.Counter)
	}
	if nat_fields_mask&(1<<3) != 0 {
		w = basictl.DoubleWrite(w, item.ValueMin)
	}
	if nat_fields_mask&(1<<4) != 0 {
		w = basictl.DoubleWrite(w, item.ValueMax)
	}
	if nat_fields_mask&(1<<4) != 0 {
		w = basictl.DoubleWrite(w, item.ValueSum)
	}
	if nat_fields_mask&(1<<4) != 0 {
		w = basictl.DoubleWrite(w, item.ValueSumSquare)
	}
	if nat_fields_mask&(1<<5) != 0 {
		w = basictl.StringWriteBytes(w, item.Uniques)
	}
	if nat_fields_mask&(1<<6) != 0 {
		w = BuiltinVectorStatshouseCentroidFloatWrite(w, item.Centroids)
	}
	if nat_fields_mask&(1<<7) != 0 {
		w = basictl.IntWrite(w, item.MaxHostTag)
	}
	if nat_fields_mask&(1<<8) != 0 {
		w = basictl.IntWrite(w, item.MinHostTag)
	}
	if nat_fields_mask&(1<<9) != 0 {
		w = basictl.IntWrite(w, item.MaxCounterHostTag)
	}
	return w
}

func (item *StatshouseMultiValueBytes) ReadBoxed(w []byte, nat_fields_mask uint32) (_ []byte, err error) {
	if w, err = basictl.NatReadExactTag(w, 0x0c803e06); err != nil {
		return w, err
	}
	return item.Read(w, nat_fields_mask)
}

// This method is general version of WriteBoxed, use it instead!
func (item *StatshouseMultiValueBytes) WriteBoxedGeneral(w []byte, nat_fields_mask uint32) (_ []byte, err error) {
	return item.WriteBoxed(w, nat_fields_mask), nil
}

func (item *StatshouseMultiValueBytes) WriteBoxed(w []byte, nat_fields_mask uint32) []byte {
	w = basictl.NatWrite(w, 0x0c803e06)
	return item.Write(w, nat_fields_mask)
}

func (item *StatshouseMultiValueBytes) ReadJSON(legacyTypeNames bool, in *basictl.JsonLexer, nat_fields_mask uint32) error {
	var propCounterPresented bool
	var propValueMinPresented bool
	var propValueMaxPresented bool
	var propValueSumPresented bool
	var propValueSumSquarePresented bool
	var propUniquesPresented bool
	var propCentroidsPresented bool
	var propMaxHostTagPresented bool
	var propMinHostTagPresented bool
	var propMaxCounterHostTagPresented bool

	if in != nil {
		in.Delim('{')
		if !in.Ok() {
			return in.Error()
		}
		for !in.IsDelim('}') {
			key := in.UnsafeFieldName(true)
			in.WantColon()
			switch key {
			case "counter":
				if propCounterPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.multi_value", "counter")
				}
				if nat_fields_mask&(1<<0) == 0 {
					return ErrorInvalidJSON("statshouse.multi_value", "field 'counter' is defined, while corresponding implicit fieldmask bit is 0")
				}
				if err := Json2ReadFloat64(in, &item.Counter); err != nil {
					return err
				}
				propCounterPresented = true
			case "counter_eq_1":
				return ErrorInvalidJSON("statshouse.multi_value", "implicit true field 'counter_eq_1' cannot be defined, set fieldmask instead")
			case "value_set":
				return ErrorInvalidJSON("statshouse.multi_value", "implicit true field 'value_set' cannot be defined, set fieldmask instead")
			case "value_min":
				if propValueMinPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.multi_value", "value_min")
				}
				if nat_fields_mask&(1<<3) == 0 {
					return ErrorInvalidJSON("statshouse.multi_value", "field 'value_min' is defined, while corresponding implicit fieldmask bit is 0")
				}
				if err := Json2ReadFloat64(in, &item.ValueMin); err != nil {
					return err
				}
				propValueMinPresented = true
			case "value_max":
				if propValueMaxPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.multi_value", "value_max")
				}
				if nat_fields_mask&(1<<4) == 0 {
					return ErrorInvalidJSON("statshouse.multi_value", "field 'value_max' is defined, while corresponding implicit fieldmask bit is 0")
				}
				if err := Json2ReadFloat64(in, &item.ValueMax); err != nil {
					return err
				}
				propValueMaxPresented = true
			case "value_sum":
				if propValueSumPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.multi_value", "value_sum")
				}
				if nat_fields_mask&(1<<4) == 0 {
					return ErrorInvalidJSON("statshouse.multi_value", "field 'value_sum' is defined, while corresponding implicit fieldmask bit is 0")
				}
				if err := Json2ReadFloat64(in, &item.ValueSum); err != nil {
					return err
				}
				propValueSumPresented = true
			case "value_sum_square":
				if propValueSumSquarePresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.multi_value", "value_sum_square")
				}
				if nat_fields_mask&(1<<4) == 0 {
					return ErrorInvalidJSON("statshouse.multi_value", "field 'value_sum_square' is defined, while corresponding implicit fieldmask bit is 0")
				}
				if err := Json2ReadFloat64(in, &item.ValueSumSquare); err != nil {
					return err
				}
				propValueSumSquarePresented = true
			case "uniques":
				if propUniquesPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.multi_value", "uniques")
				}
				if nat_fields_mask&(1<<5) == 0 {
					return ErrorInvalidJSON("statshouse.multi_value", "field 'uniques' is defined, while corresponding implicit fieldmask bit is 0")
				}
				if err := Json2ReadStringBytes(in, &item.Uniques); err != nil {
					return err
				}
				propUniquesPresented = true
			case "centroids":
				if propCentroidsPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.multi_value", "centroids")
				}
				if nat_fields_mask&(1<<6) == 0 {
					return ErrorInvalidJSON("statshouse.multi_value", "field 'centroids' is defined, while corresponding implicit fieldmask bit is 0")
				}
				if err := BuiltinVectorStatshouseCentroidFloatReadJSON(legacyTypeNames, in, &item.Centroids); err != nil {
					return err
				}
				propCentroidsPresented = true
			case "max_host_tag":
				if propMaxHostTagPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.multi_value", "max_host_tag")
				}
				if nat_fields_mask&(1<<7) == 0 {
					return ErrorInvalidJSON("statshouse.multi_value", "field 'max_host_tag' is defined, while corresponding implicit fieldmask bit is 0")
				}
				if err := Json2ReadInt32(in, &item.MaxHostTag); err != nil {
					return err
				}
				propMaxHostTagPresented = true
			case "min_host_tag":
				if propMinHostTagPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.multi_value", "min_host_tag")
				}
				if nat_fields_mask&(1<<8) == 0 {
					return ErrorInvalidJSON("statshouse.multi_value", "field 'min_host_tag' is defined, while corresponding implicit fieldmask bit is 0")
				}
				if err := Json2ReadInt32(in, &item.MinHostTag); err != nil {
					return err
				}
				propMinHostTagPresented = true
			case "max_counter_host_tag":
				if propMaxCounterHostTagPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.multi_value", "max_counter_host_tag")
				}
				if nat_fields_mask&(1<<9) == 0 {
					return ErrorInvalidJSON("statshouse.multi_value", "field 'max_counter_host_tag' is defined, while corresponding implicit fieldmask bit is 0")
				}
				if err := Json2ReadInt32(in, &item.MaxCounterHostTag); err != nil {
					return err
				}
				propMaxCounterHostTagPresented = true
			default:
				return ErrorInvalidJSONExcessElement("statshouse.multi_value", key)
			}
			in.WantComma()
		}
		in.Delim('}')
		if !in.Ok() {
			return in.Error()
		}
	}
	if !propCounterPresented {
		item.Counter = 0
	}
	if !propValueMinPresented {
		item.ValueMin = 0
	}
	if !propValueMaxPresented {
		item.ValueMax = 0
	}
	if !propValueSumPresented {
		item.ValueSum = 0
	}
	if !propValueSumSquarePresented {
		item.ValueSumSquare = 0
	}
	if !propUniquesPresented {
		item.Uniques = item.Uniques[:0]
	}
	if !propCentroidsPresented {
		item.Centroids = item.Centroids[:0]
	}
	if !propMaxHostTagPresented {
		item.MaxHostTag = 0
	}
	if !propMinHostTagPresented {
		item.MinHostTag = 0
	}
	if !propMaxCounterHostTagPresented {
		item.MaxCounterHostTag = 0
	}
	return nil
}

// This method is general version of WriteJSON, use it instead!
func (item *StatshouseMultiValueBytes) WriteJSONGeneral(w []byte, nat_fields_mask uint32) (_ []byte, err error) {
	return item.WriteJSONOpt(true, false, w, nat_fields_mask), nil
}

func (item *StatshouseMultiValueBytes) WriteJSON(w []byte, nat_fields_mask uint32) []byte {
	return item.WriteJSONOpt(true, false, w, nat_fields_mask)
}
func (item *StatshouseMultiValueBytes) WriteJSONOpt(newTypeNames bool, short bool, w []byte, nat_fields_mask uint32) []byte {
	w = append(w, '{')
	if nat_fields_mask&(1<<0) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"counter":`...)
		w = basictl.JSONWriteFloat64(w, item.Counter)
	}
	if nat_fields_mask&(1<<3) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"value_min":`...)
		w = basictl.JSONWriteFloat64(w, item.ValueMin)
	}
	if nat_fields_mask&(1<<4) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"value_max":`...)
		w = basictl.JSONWriteFloat64(w, item.ValueMax)
	}
	if nat_fields_mask&(1<<4) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"value_sum":`...)
		w = basictl.JSONWriteFloat64(w, item.ValueSum)
	}
	if nat_fields_mask&(1<<4) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"value_sum_square":`...)
		w = basictl.JSONWriteFloat64(w, item.ValueSumSquare)
	}
	if nat_fields_mask&(1<<5) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"uniques":`...)
		w = basictl.JSONWriteStringBytes(w, item.Uniques)
	}
	if nat_fields_mask&(1<<6) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"centroids":`...)
		w = BuiltinVectorStatshouseCentroidFloatWriteJSONOpt(newTypeNames, short, w, item.Centroids)
	}
	if nat_fields_mask&(1<<7) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"max_host_tag":`...)
		w = basictl.JSONWriteInt32(w, item.MaxHostTag)
	}
	if nat_fields_mask&(1<<8) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"min_host_tag":`...)
		w = basictl.JSONWriteInt32(w, item.MinHostTag)
	}
	if nat_fields_mask&(1<<9) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"max_counter_host_tag":`...)
		w = basictl.JSONWriteInt32(w, item.MaxCounterHostTag)
	}
	return append(w, '}')
}
