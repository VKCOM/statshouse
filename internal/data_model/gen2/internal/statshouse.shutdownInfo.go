// Copyright 2025 V Kontakte LLC
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

// Code generated by vktl/cmd/tlgen2; DO NOT EDIT.
package internal

import (
	"github.com/VKCOM/statshouse/internal/vkgo/basictl"
)

var _ = basictl.NatWrite

type StatshouseShutdownInfo struct {
	StartShutdownTime  int64
	FinishShutdownTime int64
	StopRecentSenders  int64
	StopReceivers      int64
	StopFlusher        int64
	StopFlushing       int64
	StopPreprocessor   int64
	StopInserters      int64
	StopRPCServer      int64
	SaveMappings       int64
	SaveJournal        int64
	C                  int64
	D                  int64
	E                  int64
	F                  int64
	G                  int64
	H                  int64
	I                  int64
	J                  int64
	K                  int64
	L                  int64
	M                  int64
	N                  int64
}

func (StatshouseShutdownInfo) TLName() string { return "statshouse.shutdownInfo" }
func (StatshouseShutdownInfo) TLTag() uint32  { return 0x4124cf9c }

func (item *StatshouseShutdownInfo) Reset() {
	item.StartShutdownTime = 0
	item.FinishShutdownTime = 0
	item.StopRecentSenders = 0
	item.StopReceivers = 0
	item.StopFlusher = 0
	item.StopFlushing = 0
	item.StopPreprocessor = 0
	item.StopInserters = 0
	item.StopRPCServer = 0
	item.SaveMappings = 0
	item.SaveJournal = 0
	item.C = 0
	item.D = 0
	item.E = 0
	item.F = 0
	item.G = 0
	item.H = 0
	item.I = 0
	item.J = 0
	item.K = 0
	item.L = 0
	item.M = 0
	item.N = 0
}

func (item *StatshouseShutdownInfo) Read(w []byte) (_ []byte, err error) {
	if w, err = basictl.LongRead(w, &item.StartShutdownTime); err != nil {
		return w, err
	}
	if w, err = basictl.LongRead(w, &item.FinishShutdownTime); err != nil {
		return w, err
	}
	if w, err = basictl.LongRead(w, &item.StopRecentSenders); err != nil {
		return w, err
	}
	if w, err = basictl.LongRead(w, &item.StopReceivers); err != nil {
		return w, err
	}
	if w, err = basictl.LongRead(w, &item.StopFlusher); err != nil {
		return w, err
	}
	if w, err = basictl.LongRead(w, &item.StopFlushing); err != nil {
		return w, err
	}
	if w, err = basictl.LongRead(w, &item.StopPreprocessor); err != nil {
		return w, err
	}
	if w, err = basictl.LongRead(w, &item.StopInserters); err != nil {
		return w, err
	}
	if w, err = basictl.LongRead(w, &item.StopRPCServer); err != nil {
		return w, err
	}
	if w, err = basictl.LongRead(w, &item.SaveMappings); err != nil {
		return w, err
	}
	if w, err = basictl.LongRead(w, &item.SaveJournal); err != nil {
		return w, err
	}
	if w, err = basictl.LongRead(w, &item.C); err != nil {
		return w, err
	}
	if w, err = basictl.LongRead(w, &item.D); err != nil {
		return w, err
	}
	if w, err = basictl.LongRead(w, &item.E); err != nil {
		return w, err
	}
	if w, err = basictl.LongRead(w, &item.F); err != nil {
		return w, err
	}
	if w, err = basictl.LongRead(w, &item.G); err != nil {
		return w, err
	}
	if w, err = basictl.LongRead(w, &item.H); err != nil {
		return w, err
	}
	if w, err = basictl.LongRead(w, &item.I); err != nil {
		return w, err
	}
	if w, err = basictl.LongRead(w, &item.J); err != nil {
		return w, err
	}
	if w, err = basictl.LongRead(w, &item.K); err != nil {
		return w, err
	}
	if w, err = basictl.LongRead(w, &item.L); err != nil {
		return w, err
	}
	if w, err = basictl.LongRead(w, &item.M); err != nil {
		return w, err
	}
	return basictl.LongRead(w, &item.N)
}

// This method is general version of Write, use it instead!
func (item *StatshouseShutdownInfo) WriteGeneral(w []byte) (_ []byte, err error) {
	return item.Write(w), nil
}

func (item *StatshouseShutdownInfo) Write(w []byte) []byte {
	w = basictl.LongWrite(w, item.StartShutdownTime)
	w = basictl.LongWrite(w, item.FinishShutdownTime)
	w = basictl.LongWrite(w, item.StopRecentSenders)
	w = basictl.LongWrite(w, item.StopReceivers)
	w = basictl.LongWrite(w, item.StopFlusher)
	w = basictl.LongWrite(w, item.StopFlushing)
	w = basictl.LongWrite(w, item.StopPreprocessor)
	w = basictl.LongWrite(w, item.StopInserters)
	w = basictl.LongWrite(w, item.StopRPCServer)
	w = basictl.LongWrite(w, item.SaveMappings)
	w = basictl.LongWrite(w, item.SaveJournal)
	w = basictl.LongWrite(w, item.C)
	w = basictl.LongWrite(w, item.D)
	w = basictl.LongWrite(w, item.E)
	w = basictl.LongWrite(w, item.F)
	w = basictl.LongWrite(w, item.G)
	w = basictl.LongWrite(w, item.H)
	w = basictl.LongWrite(w, item.I)
	w = basictl.LongWrite(w, item.J)
	w = basictl.LongWrite(w, item.K)
	w = basictl.LongWrite(w, item.L)
	w = basictl.LongWrite(w, item.M)
	w = basictl.LongWrite(w, item.N)
	return w
}

func (item *StatshouseShutdownInfo) ReadBoxed(w []byte) (_ []byte, err error) {
	if w, err = basictl.NatReadExactTag(w, 0x4124cf9c); err != nil {
		return w, err
	}
	return item.Read(w)
}

// This method is general version of WriteBoxed, use it instead!
func (item *StatshouseShutdownInfo) WriteBoxedGeneral(w []byte) (_ []byte, err error) {
	return item.WriteBoxed(w), nil
}

func (item *StatshouseShutdownInfo) WriteBoxed(w []byte) []byte {
	w = basictl.NatWrite(w, 0x4124cf9c)
	return item.Write(w)
}

func (item StatshouseShutdownInfo) String() string {
	return string(item.WriteJSON(nil))
}

func (item *StatshouseShutdownInfo) ReadJSON(legacyTypeNames bool, in *basictl.JsonLexer) error {
	var propStartShutdownTimePresented bool
	var propFinishShutdownTimePresented bool
	var propStopRecentSendersPresented bool
	var propStopReceiversPresented bool
	var propStopFlusherPresented bool
	var propStopFlushingPresented bool
	var propStopPreprocessorPresented bool
	var propStopInsertersPresented bool
	var propStopRPCServerPresented bool
	var propSaveMappingsPresented bool
	var propSaveJournalPresented bool
	var propCPresented bool
	var propDPresented bool
	var propEPresented bool
	var propFPresented bool
	var propGPresented bool
	var propHPresented bool
	var propIPresented bool
	var propJPresented bool
	var propKPresented bool
	var propLPresented bool
	var propMPresented bool
	var propNPresented bool

	if in != nil {
		in.Delim('{')
		if !in.Ok() {
			return in.Error()
		}
		for !in.IsDelim('}') {
			key := in.UnsafeFieldName(true)
			in.WantColon()
			switch key {
			case "startShutdownTime":
				if propStartShutdownTimePresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.shutdownInfo", "startShutdownTime")
				}
				if err := Json2ReadInt64(in, &item.StartShutdownTime); err != nil {
					return err
				}
				propStartShutdownTimePresented = true
			case "finishShutdownTime":
				if propFinishShutdownTimePresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.shutdownInfo", "finishShutdownTime")
				}
				if err := Json2ReadInt64(in, &item.FinishShutdownTime); err != nil {
					return err
				}
				propFinishShutdownTimePresented = true
			case "stopRecentSenders":
				if propStopRecentSendersPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.shutdownInfo", "stopRecentSenders")
				}
				if err := Json2ReadInt64(in, &item.StopRecentSenders); err != nil {
					return err
				}
				propStopRecentSendersPresented = true
			case "stopReceivers":
				if propStopReceiversPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.shutdownInfo", "stopReceivers")
				}
				if err := Json2ReadInt64(in, &item.StopReceivers); err != nil {
					return err
				}
				propStopReceiversPresented = true
			case "stopFlusher":
				if propStopFlusherPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.shutdownInfo", "stopFlusher")
				}
				if err := Json2ReadInt64(in, &item.StopFlusher); err != nil {
					return err
				}
				propStopFlusherPresented = true
			case "stopFlushing":
				if propStopFlushingPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.shutdownInfo", "stopFlushing")
				}
				if err := Json2ReadInt64(in, &item.StopFlushing); err != nil {
					return err
				}
				propStopFlushingPresented = true
			case "stopPreprocessor":
				if propStopPreprocessorPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.shutdownInfo", "stopPreprocessor")
				}
				if err := Json2ReadInt64(in, &item.StopPreprocessor); err != nil {
					return err
				}
				propStopPreprocessorPresented = true
			case "stopInserters":
				if propStopInsertersPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.shutdownInfo", "stopInserters")
				}
				if err := Json2ReadInt64(in, &item.StopInserters); err != nil {
					return err
				}
				propStopInsertersPresented = true
			case "stopRPCServer":
				if propStopRPCServerPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.shutdownInfo", "stopRPCServer")
				}
				if err := Json2ReadInt64(in, &item.StopRPCServer); err != nil {
					return err
				}
				propStopRPCServerPresented = true
			case "saveMappings":
				if propSaveMappingsPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.shutdownInfo", "saveMappings")
				}
				if err := Json2ReadInt64(in, &item.SaveMappings); err != nil {
					return err
				}
				propSaveMappingsPresented = true
			case "saveJournal":
				if propSaveJournalPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.shutdownInfo", "saveJournal")
				}
				if err := Json2ReadInt64(in, &item.SaveJournal); err != nil {
					return err
				}
				propSaveJournalPresented = true
			case "c":
				if propCPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.shutdownInfo", "c")
				}
				if err := Json2ReadInt64(in, &item.C); err != nil {
					return err
				}
				propCPresented = true
			case "d":
				if propDPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.shutdownInfo", "d")
				}
				if err := Json2ReadInt64(in, &item.D); err != nil {
					return err
				}
				propDPresented = true
			case "e":
				if propEPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.shutdownInfo", "e")
				}
				if err := Json2ReadInt64(in, &item.E); err != nil {
					return err
				}
				propEPresented = true
			case "f":
				if propFPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.shutdownInfo", "f")
				}
				if err := Json2ReadInt64(in, &item.F); err != nil {
					return err
				}
				propFPresented = true
			case "g":
				if propGPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.shutdownInfo", "g")
				}
				if err := Json2ReadInt64(in, &item.G); err != nil {
					return err
				}
				propGPresented = true
			case "h":
				if propHPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.shutdownInfo", "h")
				}
				if err := Json2ReadInt64(in, &item.H); err != nil {
					return err
				}
				propHPresented = true
			case "i":
				if propIPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.shutdownInfo", "i")
				}
				if err := Json2ReadInt64(in, &item.I); err != nil {
					return err
				}
				propIPresented = true
			case "j":
				if propJPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.shutdownInfo", "j")
				}
				if err := Json2ReadInt64(in, &item.J); err != nil {
					return err
				}
				propJPresented = true
			case "k":
				if propKPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.shutdownInfo", "k")
				}
				if err := Json2ReadInt64(in, &item.K); err != nil {
					return err
				}
				propKPresented = true
			case "l":
				if propLPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.shutdownInfo", "l")
				}
				if err := Json2ReadInt64(in, &item.L); err != nil {
					return err
				}
				propLPresented = true
			case "m":
				if propMPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.shutdownInfo", "m")
				}
				if err := Json2ReadInt64(in, &item.M); err != nil {
					return err
				}
				propMPresented = true
			case "n":
				if propNPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.shutdownInfo", "n")
				}
				if err := Json2ReadInt64(in, &item.N); err != nil {
					return err
				}
				propNPresented = true
			default:
				return ErrorInvalidJSONExcessElement("statshouse.shutdownInfo", key)
			}
			in.WantComma()
		}
		in.Delim('}')
		if !in.Ok() {
			return in.Error()
		}
	}
	if !propStartShutdownTimePresented {
		item.StartShutdownTime = 0
	}
	if !propFinishShutdownTimePresented {
		item.FinishShutdownTime = 0
	}
	if !propStopRecentSendersPresented {
		item.StopRecentSenders = 0
	}
	if !propStopReceiversPresented {
		item.StopReceivers = 0
	}
	if !propStopFlusherPresented {
		item.StopFlusher = 0
	}
	if !propStopFlushingPresented {
		item.StopFlushing = 0
	}
	if !propStopPreprocessorPresented {
		item.StopPreprocessor = 0
	}
	if !propStopInsertersPresented {
		item.StopInserters = 0
	}
	if !propStopRPCServerPresented {
		item.StopRPCServer = 0
	}
	if !propSaveMappingsPresented {
		item.SaveMappings = 0
	}
	if !propSaveJournalPresented {
		item.SaveJournal = 0
	}
	if !propCPresented {
		item.C = 0
	}
	if !propDPresented {
		item.D = 0
	}
	if !propEPresented {
		item.E = 0
	}
	if !propFPresented {
		item.F = 0
	}
	if !propGPresented {
		item.G = 0
	}
	if !propHPresented {
		item.H = 0
	}
	if !propIPresented {
		item.I = 0
	}
	if !propJPresented {
		item.J = 0
	}
	if !propKPresented {
		item.K = 0
	}
	if !propLPresented {
		item.L = 0
	}
	if !propMPresented {
		item.M = 0
	}
	if !propNPresented {
		item.N = 0
	}
	return nil
}

// This method is general version of WriteJSON, use it instead!
func (item *StatshouseShutdownInfo) WriteJSONGeneral(w []byte) (_ []byte, err error) {
	return item.WriteJSONOpt(true, false, w), nil
}

func (item *StatshouseShutdownInfo) WriteJSON(w []byte) []byte {
	return item.WriteJSONOpt(true, false, w)
}
func (item *StatshouseShutdownInfo) WriteJSONOpt(newTypeNames bool, short bool, w []byte) []byte {
	w = append(w, '{')
	backupIndexStartShutdownTime := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"startShutdownTime":`...)
	w = basictl.JSONWriteInt64(w, item.StartShutdownTime)
	if (item.StartShutdownTime != 0) == false {
		w = w[:backupIndexStartShutdownTime]
	}
	backupIndexFinishShutdownTime := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"finishShutdownTime":`...)
	w = basictl.JSONWriteInt64(w, item.FinishShutdownTime)
	if (item.FinishShutdownTime != 0) == false {
		w = w[:backupIndexFinishShutdownTime]
	}
	backupIndexStopRecentSenders := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"stopRecentSenders":`...)
	w = basictl.JSONWriteInt64(w, item.StopRecentSenders)
	if (item.StopRecentSenders != 0) == false {
		w = w[:backupIndexStopRecentSenders]
	}
	backupIndexStopReceivers := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"stopReceivers":`...)
	w = basictl.JSONWriteInt64(w, item.StopReceivers)
	if (item.StopReceivers != 0) == false {
		w = w[:backupIndexStopReceivers]
	}
	backupIndexStopFlusher := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"stopFlusher":`...)
	w = basictl.JSONWriteInt64(w, item.StopFlusher)
	if (item.StopFlusher != 0) == false {
		w = w[:backupIndexStopFlusher]
	}
	backupIndexStopFlushing := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"stopFlushing":`...)
	w = basictl.JSONWriteInt64(w, item.StopFlushing)
	if (item.StopFlushing != 0) == false {
		w = w[:backupIndexStopFlushing]
	}
	backupIndexStopPreprocessor := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"stopPreprocessor":`...)
	w = basictl.JSONWriteInt64(w, item.StopPreprocessor)
	if (item.StopPreprocessor != 0) == false {
		w = w[:backupIndexStopPreprocessor]
	}
	backupIndexStopInserters := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"stopInserters":`...)
	w = basictl.JSONWriteInt64(w, item.StopInserters)
	if (item.StopInserters != 0) == false {
		w = w[:backupIndexStopInserters]
	}
	backupIndexStopRPCServer := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"stopRPCServer":`...)
	w = basictl.JSONWriteInt64(w, item.StopRPCServer)
	if (item.StopRPCServer != 0) == false {
		w = w[:backupIndexStopRPCServer]
	}
	backupIndexSaveMappings := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"saveMappings":`...)
	w = basictl.JSONWriteInt64(w, item.SaveMappings)
	if (item.SaveMappings != 0) == false {
		w = w[:backupIndexSaveMappings]
	}
	backupIndexSaveJournal := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"saveJournal":`...)
	w = basictl.JSONWriteInt64(w, item.SaveJournal)
	if (item.SaveJournal != 0) == false {
		w = w[:backupIndexSaveJournal]
	}
	backupIndexC := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"c":`...)
	w = basictl.JSONWriteInt64(w, item.C)
	if (item.C != 0) == false {
		w = w[:backupIndexC]
	}
	backupIndexD := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"d":`...)
	w = basictl.JSONWriteInt64(w, item.D)
	if (item.D != 0) == false {
		w = w[:backupIndexD]
	}
	backupIndexE := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"e":`...)
	w = basictl.JSONWriteInt64(w, item.E)
	if (item.E != 0) == false {
		w = w[:backupIndexE]
	}
	backupIndexF := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"f":`...)
	w = basictl.JSONWriteInt64(w, item.F)
	if (item.F != 0) == false {
		w = w[:backupIndexF]
	}
	backupIndexG := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"g":`...)
	w = basictl.JSONWriteInt64(w, item.G)
	if (item.G != 0) == false {
		w = w[:backupIndexG]
	}
	backupIndexH := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"h":`...)
	w = basictl.JSONWriteInt64(w, item.H)
	if (item.H != 0) == false {
		w = w[:backupIndexH]
	}
	backupIndexI := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"i":`...)
	w = basictl.JSONWriteInt64(w, item.I)
	if (item.I != 0) == false {
		w = w[:backupIndexI]
	}
	backupIndexJ := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"j":`...)
	w = basictl.JSONWriteInt64(w, item.J)
	if (item.J != 0) == false {
		w = w[:backupIndexJ]
	}
	backupIndexK := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"k":`...)
	w = basictl.JSONWriteInt64(w, item.K)
	if (item.K != 0) == false {
		w = w[:backupIndexK]
	}
	backupIndexL := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"l":`...)
	w = basictl.JSONWriteInt64(w, item.L)
	if (item.L != 0) == false {
		w = w[:backupIndexL]
	}
	backupIndexM := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"m":`...)
	w = basictl.JSONWriteInt64(w, item.M)
	if (item.M != 0) == false {
		w = w[:backupIndexM]
	}
	backupIndexN := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"n":`...)
	w = basictl.JSONWriteInt64(w, item.N)
	if (item.N != 0) == false {
		w = w[:backupIndexN]
	}
	return append(w, '}')
}

func (item *StatshouseShutdownInfo) MarshalJSON() ([]byte, error) {
	return item.WriteJSON(nil), nil
}

func (item *StatshouseShutdownInfo) UnmarshalJSON(b []byte) error {
	if err := item.ReadJSON(true, &basictl.JsonLexer{Data: b}); err != nil {
		return ErrorInvalidJSON("statshouse.shutdownInfo", err.Error())
	}
	return nil
}
