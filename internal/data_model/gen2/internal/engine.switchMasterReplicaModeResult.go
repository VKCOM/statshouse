// Copyright 2025 V Kontakte LLC
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

// Code generated by vktl/cmd/tlgen2; DO NOT EDIT.
package internal

import (
	"github.com/VKCOM/statshouse/internal/vkgo/basictl"
)

var _ = basictl.NatWrite

func (item EngineAlreadyInMasterMode) AsUnion() EngineSwitchMasterReplicaModeResult {
	var ret EngineSwitchMasterReplicaModeResult
	ret.SetAlreadyInMasterMode()
	return ret
}

type EngineAlreadyInMasterMode struct {
}

func (EngineAlreadyInMasterMode) TLName() string { return "engine.alreadyInMasterMode" }
func (EngineAlreadyInMasterMode) TLTag() uint32  { return 0x402409cb }

func (item *EngineAlreadyInMasterMode) Reset() {}

func (item *EngineAlreadyInMasterMode) FillRandom(rg *basictl.RandGenerator) {}

func (item *EngineAlreadyInMasterMode) Read(w []byte) (_ []byte, err error) { return w, nil }

func (item *EngineAlreadyInMasterMode) WriteGeneral(w []byte) (_ []byte, err error) {
	return item.Write(w), nil
}

func (item *EngineAlreadyInMasterMode) Write(w []byte) []byte {
	return w
}

func (item *EngineAlreadyInMasterMode) ReadBoxed(w []byte) (_ []byte, err error) {
	if w, err = basictl.NatReadExactTag(w, 0x402409cb); err != nil {
		return w, err
	}
	return item.Read(w)
}

func (item *EngineAlreadyInMasterMode) WriteBoxedGeneral(w []byte) (_ []byte, err error) {
	return item.WriteBoxed(w), nil
}

func (item *EngineAlreadyInMasterMode) WriteBoxed(w []byte) []byte {
	w = basictl.NatWrite(w, 0x402409cb)
	return item.Write(w)
}

func (item EngineAlreadyInMasterMode) String() string {
	return string(item.WriteJSON(nil))
}

func (item *EngineAlreadyInMasterMode) ReadJSON(legacyTypeNames bool, in *basictl.JsonLexer) error {
	tctx := basictl.JSONReadContext{LegacyTypeNames: legacyTypeNames}
	return item.ReadJSONGeneral(&tctx, in)
}

func (item *EngineAlreadyInMasterMode) ReadJSONGeneral(tctx *basictl.JSONReadContext, in *basictl.JsonLexer) error {
	if in != nil {
		in.Delim('{')
		if !in.Ok() {
			return in.Error()
		}
		for !in.IsDelim('}') {
			return ErrorInvalidJSON("engine.alreadyInMasterMode", "this object can't have properties")
		}
		in.Delim('}')
		if !in.Ok() {
			return in.Error()
		}
	}
	return nil
}

// This method is general version of WriteJSON, use it instead!
func (item *EngineAlreadyInMasterMode) WriteJSONGeneral(tctx *basictl.JSONWriteContext, w []byte) (_ []byte, err error) {
	return item.WriteJSONOpt(tctx, w), nil
}

func (item *EngineAlreadyInMasterMode) WriteJSON(w []byte) []byte {
	tctx := basictl.JSONWriteContext{}
	return item.WriteJSONOpt(&tctx, w)
}
func (item *EngineAlreadyInMasterMode) WriteJSONOpt(tctx *basictl.JSONWriteContext, w []byte) []byte {
	w = append(w, '{')
	return append(w, '}')
}

func (item *EngineAlreadyInMasterMode) MarshalJSON() ([]byte, error) {
	return item.WriteJSON(nil), nil
}

func (item *EngineAlreadyInMasterMode) UnmarshalJSON(b []byte) error {
	if err := item.ReadJSON(true, &basictl.JsonLexer{Data: b}); err != nil {
		return ErrorInvalidJSON("engine.alreadyInMasterMode", err.Error())
	}
	return nil
}

func (item *EngineAlreadyInMasterMode) WriteTL2(w []byte, ctx *basictl.TL2WriteContext) []byte {
	panic(ErrorTL2SerializersNotGenerated("engine.alreadyInMasterMode"))
}

func (item *EngineAlreadyInMasterMode) ReadTL2(r []byte, ctx *basictl.TL2ReadContext) (_ []byte, err error) {
	return r, ErrorTL2SerializersNotGenerated("engine.alreadyInMasterMode")
}

func (item EngineAlreadyInReplicaMode) AsUnion() EngineSwitchMasterReplicaModeResult {
	var ret EngineSwitchMasterReplicaModeResult
	ret.SetAlreadyInReplicaMode()
	return ret
}

type EngineAlreadyInReplicaMode struct {
}

func (EngineAlreadyInReplicaMode) TLName() string { return "engine.alreadyInReplicaMode" }
func (EngineAlreadyInReplicaMode) TLTag() uint32  { return 0xebd80142 }

func (item *EngineAlreadyInReplicaMode) Reset() {}

func (item *EngineAlreadyInReplicaMode) FillRandom(rg *basictl.RandGenerator) {}

func (item *EngineAlreadyInReplicaMode) Read(w []byte) (_ []byte, err error) { return w, nil }

func (item *EngineAlreadyInReplicaMode) WriteGeneral(w []byte) (_ []byte, err error) {
	return item.Write(w), nil
}

func (item *EngineAlreadyInReplicaMode) Write(w []byte) []byte {
	return w
}

func (item *EngineAlreadyInReplicaMode) ReadBoxed(w []byte) (_ []byte, err error) {
	if w, err = basictl.NatReadExactTag(w, 0xebd80142); err != nil {
		return w, err
	}
	return item.Read(w)
}

func (item *EngineAlreadyInReplicaMode) WriteBoxedGeneral(w []byte) (_ []byte, err error) {
	return item.WriteBoxed(w), nil
}

func (item *EngineAlreadyInReplicaMode) WriteBoxed(w []byte) []byte {
	w = basictl.NatWrite(w, 0xebd80142)
	return item.Write(w)
}

func (item EngineAlreadyInReplicaMode) String() string {
	return string(item.WriteJSON(nil))
}

func (item *EngineAlreadyInReplicaMode) ReadJSON(legacyTypeNames bool, in *basictl.JsonLexer) error {
	tctx := basictl.JSONReadContext{LegacyTypeNames: legacyTypeNames}
	return item.ReadJSONGeneral(&tctx, in)
}

func (item *EngineAlreadyInReplicaMode) ReadJSONGeneral(tctx *basictl.JSONReadContext, in *basictl.JsonLexer) error {
	if in != nil {
		in.Delim('{')
		if !in.Ok() {
			return in.Error()
		}
		for !in.IsDelim('}') {
			return ErrorInvalidJSON("engine.alreadyInReplicaMode", "this object can't have properties")
		}
		in.Delim('}')
		if !in.Ok() {
			return in.Error()
		}
	}
	return nil
}

// This method is general version of WriteJSON, use it instead!
func (item *EngineAlreadyInReplicaMode) WriteJSONGeneral(tctx *basictl.JSONWriteContext, w []byte) (_ []byte, err error) {
	return item.WriteJSONOpt(tctx, w), nil
}

func (item *EngineAlreadyInReplicaMode) WriteJSON(w []byte) []byte {
	tctx := basictl.JSONWriteContext{}
	return item.WriteJSONOpt(&tctx, w)
}
func (item *EngineAlreadyInReplicaMode) WriteJSONOpt(tctx *basictl.JSONWriteContext, w []byte) []byte {
	w = append(w, '{')
	return append(w, '}')
}

func (item *EngineAlreadyInReplicaMode) MarshalJSON() ([]byte, error) {
	return item.WriteJSON(nil), nil
}

func (item *EngineAlreadyInReplicaMode) UnmarshalJSON(b []byte) error {
	if err := item.ReadJSON(true, &basictl.JsonLexer{Data: b}); err != nil {
		return ErrorInvalidJSON("engine.alreadyInReplicaMode", err.Error())
	}
	return nil
}

func (item *EngineAlreadyInReplicaMode) WriteTL2(w []byte, ctx *basictl.TL2WriteContext) []byte {
	panic(ErrorTL2SerializersNotGenerated("engine.alreadyInReplicaMode"))
}

func (item *EngineAlreadyInReplicaMode) ReadTL2(r []byte, ctx *basictl.TL2ReadContext) (_ []byte, err error) {
	return r, ErrorTL2SerializersNotGenerated("engine.alreadyInReplicaMode")
}

func (item EngineFailedToSwitchMode) AsUnion() EngineSwitchMasterReplicaModeResult {
	var ret EngineSwitchMasterReplicaModeResult
	ret.SetFailedToSwitchMode(item)
	return ret
}

type EngineFailedToSwitchMode struct {
	Error string
}

func (EngineFailedToSwitchMode) TLName() string { return "engine.failedToSwitchMode" }
func (EngineFailedToSwitchMode) TLTag() uint32  { return 0x17418662 }

func (item *EngineFailedToSwitchMode) Reset() {
	item.Error = ""
}

func (item *EngineFailedToSwitchMode) FillRandom(rg *basictl.RandGenerator) {
	item.Error = basictl.RandomString(rg)
}

func (item *EngineFailedToSwitchMode) Read(w []byte) (_ []byte, err error) {
	return basictl.StringRead(w, &item.Error)
}

func (item *EngineFailedToSwitchMode) WriteGeneral(w []byte) (_ []byte, err error) {
	return item.Write(w), nil
}

func (item *EngineFailedToSwitchMode) Write(w []byte) []byte {
	w = basictl.StringWrite(w, item.Error)
	return w
}

func (item *EngineFailedToSwitchMode) ReadBoxed(w []byte) (_ []byte, err error) {
	if w, err = basictl.NatReadExactTag(w, 0x17418662); err != nil {
		return w, err
	}
	return item.Read(w)
}

func (item *EngineFailedToSwitchMode) WriteBoxedGeneral(w []byte) (_ []byte, err error) {
	return item.WriteBoxed(w), nil
}

func (item *EngineFailedToSwitchMode) WriteBoxed(w []byte) []byte {
	w = basictl.NatWrite(w, 0x17418662)
	return item.Write(w)
}

func (item EngineFailedToSwitchMode) String() string {
	return string(item.WriteJSON(nil))
}

func (item *EngineFailedToSwitchMode) ReadJSON(legacyTypeNames bool, in *basictl.JsonLexer) error {
	tctx := basictl.JSONReadContext{LegacyTypeNames: legacyTypeNames}
	return item.ReadJSONGeneral(&tctx, in)
}

func (item *EngineFailedToSwitchMode) ReadJSONGeneral(tctx *basictl.JSONReadContext, in *basictl.JsonLexer) error {
	var propErrorPresented bool

	if in != nil {
		in.Delim('{')
		if !in.Ok() {
			return in.Error()
		}
		for !in.IsDelim('}') {
			key := in.UnsafeFieldName(true)
			in.WantColon()
			switch key {
			case "error":
				if propErrorPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("engine.failedToSwitchMode", "error")
				}
				if err := Json2ReadString(in, &item.Error); err != nil {
					return err
				}
				propErrorPresented = true
			default:
				return ErrorInvalidJSONExcessElement("engine.failedToSwitchMode", key)
			}
			in.WantComma()
		}
		in.Delim('}')
		if !in.Ok() {
			return in.Error()
		}
	}
	if !propErrorPresented {
		item.Error = ""
	}
	return nil
}

// This method is general version of WriteJSON, use it instead!
func (item *EngineFailedToSwitchMode) WriteJSONGeneral(tctx *basictl.JSONWriteContext, w []byte) (_ []byte, err error) {
	return item.WriteJSONOpt(tctx, w), nil
}

func (item *EngineFailedToSwitchMode) WriteJSON(w []byte) []byte {
	tctx := basictl.JSONWriteContext{}
	return item.WriteJSONOpt(&tctx, w)
}
func (item *EngineFailedToSwitchMode) WriteJSONOpt(tctx *basictl.JSONWriteContext, w []byte) []byte {
	w = append(w, '{')
	backupIndexError := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"error":`...)
	w = basictl.JSONWriteString(w, item.Error)
	if (len(item.Error) != 0) == false {
		w = w[:backupIndexError]
	}
	return append(w, '}')
}

func (item *EngineFailedToSwitchMode) MarshalJSON() ([]byte, error) {
	return item.WriteJSON(nil), nil
}

func (item *EngineFailedToSwitchMode) UnmarshalJSON(b []byte) error {
	if err := item.ReadJSON(true, &basictl.JsonLexer{Data: b}); err != nil {
		return ErrorInvalidJSON("engine.failedToSwitchMode", err.Error())
	}
	return nil
}

func (item *EngineFailedToSwitchMode) WriteTL2(w []byte, ctx *basictl.TL2WriteContext) []byte {
	panic(ErrorTL2SerializersNotGenerated("engine.failedToSwitchMode"))
}

func (item *EngineFailedToSwitchMode) ReadTL2(r []byte, ctx *basictl.TL2ReadContext) (_ []byte, err error) {
	return r, ErrorTL2SerializersNotGenerated("engine.failedToSwitchMode")
}

var _EngineSwitchMasterReplicaModeResult = [6]UnionElement{
	{TLTag: 0x95b13964, TLName: "engine.switchedToMasterMode", TLString: "engine.switchedToMasterMode#95b13964"},
	{TLTag: 0xad642a0b, TLName: "engine.switchedToReplicaMode", TLString: "engine.switchedToReplicaMode#ad642a0b"},
	{TLTag: 0x402409cb, TLName: "engine.alreadyInMasterMode", TLString: "engine.alreadyInMasterMode#402409cb"},
	{TLTag: 0xebd80142, TLName: "engine.alreadyInReplicaMode", TLString: "engine.alreadyInReplicaMode#ebd80142"},
	{TLTag: 0xec61b4be, TLName: "engine.switchedToMasterModeForcefully", TLString: "engine.switchedToMasterModeForcefully#ec61b4be"},
	{TLTag: 0x17418662, TLName: "engine.failedToSwitchMode", TLString: "engine.failedToSwitchMode#17418662"},
}

type EngineSwitchMasterReplicaModeResult struct {
	valueSwitchedToMasterModeForcefully EngineSwitchedToMasterModeForcefully
	valueFailedToSwitchMode             EngineFailedToSwitchMode
	index                               int
}

func (item EngineSwitchMasterReplicaModeResult) TLName() string {
	return _EngineSwitchMasterReplicaModeResult[item.index].TLName
}
func (item EngineSwitchMasterReplicaModeResult) TLTag() uint32 {
	return _EngineSwitchMasterReplicaModeResult[item.index].TLTag
}

func (item *EngineSwitchMasterReplicaModeResult) Reset() { item.index = 0 }
func (item *EngineSwitchMasterReplicaModeResult) FillRandom(rg *basictl.RandGenerator) {
	index := basictl.RandomUint(rg) % 6
	switch index {
	case 0:
		item.index = 0
	case 1:
		item.index = 1
	case 2:
		item.index = 2
	case 3:
		item.index = 3
	case 4:
		item.index = 4
		item.valueSwitchedToMasterModeForcefully.FillRandom(rg)
	case 5:
		item.index = 5
		item.valueFailedToSwitchMode.FillRandom(rg)
	default:
	}
}

func (item *EngineSwitchMasterReplicaModeResult) IsSwitchedToMasterMode() bool {
	return item.index == 0
}

func (item *EngineSwitchMasterReplicaModeResult) AsSwitchedToMasterMode() (EngineSwitchedToMasterMode, bool) {
	var value EngineSwitchedToMasterMode
	return value, item.index == 0
}
func (item *EngineSwitchMasterReplicaModeResult) ResetToSwitchedToMasterMode() { item.index = 0 }
func (item *EngineSwitchMasterReplicaModeResult) SetSwitchedToMasterMode()     { item.index = 0 }

func (item *EngineSwitchMasterReplicaModeResult) IsSwitchedToReplicaMode() bool {
	return item.index == 1
}

func (item *EngineSwitchMasterReplicaModeResult) AsSwitchedToReplicaMode() (EngineSwitchedToReplicaMode, bool) {
	var value EngineSwitchedToReplicaMode
	return value, item.index == 1
}
func (item *EngineSwitchMasterReplicaModeResult) ResetToSwitchedToReplicaMode() { item.index = 1 }
func (item *EngineSwitchMasterReplicaModeResult) SetSwitchedToReplicaMode()     { item.index = 1 }

func (item *EngineSwitchMasterReplicaModeResult) IsAlreadyInMasterMode() bool { return item.index == 2 }

func (item *EngineSwitchMasterReplicaModeResult) AsAlreadyInMasterMode() (EngineAlreadyInMasterMode, bool) {
	var value EngineAlreadyInMasterMode
	return value, item.index == 2
}
func (item *EngineSwitchMasterReplicaModeResult) ResetToAlreadyInMasterMode() { item.index = 2 }
func (item *EngineSwitchMasterReplicaModeResult) SetAlreadyInMasterMode()     { item.index = 2 }

func (item *EngineSwitchMasterReplicaModeResult) IsAlreadyInReplicaMode() bool {
	return item.index == 3
}

func (item *EngineSwitchMasterReplicaModeResult) AsAlreadyInReplicaMode() (EngineAlreadyInReplicaMode, bool) {
	var value EngineAlreadyInReplicaMode
	return value, item.index == 3
}
func (item *EngineSwitchMasterReplicaModeResult) ResetToAlreadyInReplicaMode() { item.index = 3 }
func (item *EngineSwitchMasterReplicaModeResult) SetAlreadyInReplicaMode()     { item.index = 3 }

func (item *EngineSwitchMasterReplicaModeResult) IsSwitchedToMasterModeForcefully() bool {
	return item.index == 4
}

func (item *EngineSwitchMasterReplicaModeResult) AsSwitchedToMasterModeForcefully() (*EngineSwitchedToMasterModeForcefully, bool) {
	if item.index != 4 {
		return nil, false
	}
	return &item.valueSwitchedToMasterModeForcefully, true
}
func (item *EngineSwitchMasterReplicaModeResult) ResetToSwitchedToMasterModeForcefully() *EngineSwitchedToMasterModeForcefully {
	item.index = 4
	item.valueSwitchedToMasterModeForcefully.Reset()
	return &item.valueSwitchedToMasterModeForcefully
}
func (item *EngineSwitchMasterReplicaModeResult) SetSwitchedToMasterModeForcefully(value EngineSwitchedToMasterModeForcefully) {
	item.index = 4
	item.valueSwitchedToMasterModeForcefully = value
}

func (item *EngineSwitchMasterReplicaModeResult) IsFailedToSwitchMode() bool { return item.index == 5 }

func (item *EngineSwitchMasterReplicaModeResult) AsFailedToSwitchMode() (*EngineFailedToSwitchMode, bool) {
	if item.index != 5 {
		return nil, false
	}
	return &item.valueFailedToSwitchMode, true
}
func (item *EngineSwitchMasterReplicaModeResult) ResetToFailedToSwitchMode() *EngineFailedToSwitchMode {
	item.index = 5
	item.valueFailedToSwitchMode.Reset()
	return &item.valueFailedToSwitchMode
}
func (item *EngineSwitchMasterReplicaModeResult) SetFailedToSwitchMode(value EngineFailedToSwitchMode) {
	item.index = 5
	item.valueFailedToSwitchMode = value
}

func (item *EngineSwitchMasterReplicaModeResult) ReadBoxed(w []byte) (_ []byte, err error) {
	var tag uint32
	if w, err = basictl.NatRead(w, &tag); err != nil {
		return w, err
	}
	switch tag {
	case 0x95b13964:
		item.index = 0
		return w, nil
	case 0xad642a0b:
		item.index = 1
		return w, nil
	case 0x402409cb:
		item.index = 2
		return w, nil
	case 0xebd80142:
		item.index = 3
		return w, nil
	case 0xec61b4be:
		item.index = 4
		return item.valueSwitchedToMasterModeForcefully.Read(w)
	case 0x17418662:
		item.index = 5
		return item.valueFailedToSwitchMode.Read(w)
	default:
		return w, ErrorInvalidUnionTag("engine.SwitchMasterReplicaModeResult", tag)
	}
}

func (item *EngineSwitchMasterReplicaModeResult) WriteBoxedGeneral(w []byte) (_ []byte, err error) {
	return item.WriteBoxed(w), nil
}

func (item *EngineSwitchMasterReplicaModeResult) WriteBoxed(w []byte) []byte {
	w = basictl.NatWrite(w, _EngineSwitchMasterReplicaModeResult[item.index].TLTag)
	switch item.index {
	case 0:
		return w
	case 1:
		return w
	case 2:
		return w
	case 3:
		return w
	case 4:
		w = item.valueSwitchedToMasterModeForcefully.Write(w)
	case 5:
		w = item.valueFailedToSwitchMode.Write(w)
	}
	return w
}

func (item *EngineSwitchMasterReplicaModeResult) WriteTL2(w []byte, ctx *basictl.TL2WriteContext) []byte {
	panic(ErrorTL2SerializersNotGenerated("engine.SwitchMasterReplicaModeResult"))
}

func (item *EngineSwitchMasterReplicaModeResult) ReadTL2(r []byte, ctx *basictl.TL2ReadContext) ([]byte, error) {
	return r, ErrorTL2SerializersNotGenerated("engine.SwitchMasterReplicaModeResult")
}

func (item *EngineSwitchMasterReplicaModeResult) ReadJSON(legacyTypeNames bool, in *basictl.JsonLexer) error {
	tctx := basictl.JSONReadContext{LegacyTypeNames: legacyTypeNames}
	return item.ReadJSONGeneral(&tctx, in)
}

func (item *EngineSwitchMasterReplicaModeResult) ReadJSONGeneral(tctx *basictl.JSONReadContext, in *basictl.JsonLexer) error {
	_tag, _value, err := Json2ReadUnion("engine.SwitchMasterReplicaModeResult", in)
	if err != nil {
		return err
	}
	switch _tag {
	case "engine.switchedToMasterMode#95b13964", "engine.switchedToMasterMode", "#95b13964":
		if tctx.IsTL2 && _tag != "engine.switchedToMasterMode" {
			return ErrorInvalidUnionLegacyTagJSON("engine.SwitchMasterReplicaModeResult", _tag)
		}
		if !tctx.LegacyTypeNames && _tag == "engine.switchedToMasterMode#95b13964" {
			return ErrorInvalidUnionLegacyTagJSON("engine.SwitchMasterReplicaModeResult", "engine.switchedToMasterMode#95b13964")
		}
		item.index = 0
	case "engine.switchedToReplicaMode#ad642a0b", "engine.switchedToReplicaMode", "#ad642a0b":
		if tctx.IsTL2 && _tag != "engine.switchedToReplicaMode" {
			return ErrorInvalidUnionLegacyTagJSON("engine.SwitchMasterReplicaModeResult", _tag)
		}
		if !tctx.LegacyTypeNames && _tag == "engine.switchedToReplicaMode#ad642a0b" {
			return ErrorInvalidUnionLegacyTagJSON("engine.SwitchMasterReplicaModeResult", "engine.switchedToReplicaMode#ad642a0b")
		}
		item.index = 1
	case "engine.alreadyInMasterMode#402409cb", "engine.alreadyInMasterMode", "#402409cb":
		if tctx.IsTL2 && _tag != "engine.alreadyInMasterMode" {
			return ErrorInvalidUnionLegacyTagJSON("engine.SwitchMasterReplicaModeResult", _tag)
		}
		if !tctx.LegacyTypeNames && _tag == "engine.alreadyInMasterMode#402409cb" {
			return ErrorInvalidUnionLegacyTagJSON("engine.SwitchMasterReplicaModeResult", "engine.alreadyInMasterMode#402409cb")
		}
		item.index = 2
	case "engine.alreadyInReplicaMode#ebd80142", "engine.alreadyInReplicaMode", "#ebd80142":
		if tctx.IsTL2 && _tag != "engine.alreadyInReplicaMode" {
			return ErrorInvalidUnionLegacyTagJSON("engine.SwitchMasterReplicaModeResult", _tag)
		}
		if !tctx.LegacyTypeNames && _tag == "engine.alreadyInReplicaMode#ebd80142" {
			return ErrorInvalidUnionLegacyTagJSON("engine.SwitchMasterReplicaModeResult", "engine.alreadyInReplicaMode#ebd80142")
		}
		item.index = 3
	case "engine.switchedToMasterModeForcefully#ec61b4be", "engine.switchedToMasterModeForcefully", "#ec61b4be":
		if tctx.IsTL2 && _tag != "engine.switchedToMasterModeForcefully" {
			return ErrorInvalidUnionLegacyTagJSON("engine.SwitchMasterReplicaModeResult", _tag)
		}
		if !tctx.LegacyTypeNames && _tag == "engine.switchedToMasterModeForcefully#ec61b4be" {
			return ErrorInvalidUnionLegacyTagJSON("engine.SwitchMasterReplicaModeResult", "engine.switchedToMasterModeForcefully#ec61b4be")
		}
		item.index = 4
		var in2Pointer *basictl.JsonLexer
		if _value != nil {
			in2 := basictl.JsonLexer{Data: _value}
			in2Pointer = &in2
		}
		if err := item.valueSwitchedToMasterModeForcefully.ReadJSONGeneral(tctx, in2Pointer); err != nil {
			return err
		}
	case "engine.failedToSwitchMode#17418662", "engine.failedToSwitchMode", "#17418662":
		if tctx.IsTL2 && _tag != "engine.failedToSwitchMode" {
			return ErrorInvalidUnionLegacyTagJSON("engine.SwitchMasterReplicaModeResult", _tag)
		}
		if !tctx.LegacyTypeNames && _tag == "engine.failedToSwitchMode#17418662" {
			return ErrorInvalidUnionLegacyTagJSON("engine.SwitchMasterReplicaModeResult", "engine.failedToSwitchMode#17418662")
		}
		item.index = 5
		var in2Pointer *basictl.JsonLexer
		if _value != nil {
			in2 := basictl.JsonLexer{Data: _value}
			in2Pointer = &in2
		}
		if err := item.valueFailedToSwitchMode.ReadJSONGeneral(tctx, in2Pointer); err != nil {
			return err
		}
	default:
		return ErrorInvalidUnionTagJSON("engine.SwitchMasterReplicaModeResult", _tag)
	}
	return nil
}

// This method is general version of WriteJSON, use it instead!
func (item *EngineSwitchMasterReplicaModeResult) WriteJSONGeneral(tctx *basictl.JSONWriteContext, w []byte) ([]byte, error) {
	return item.WriteJSONOpt(tctx, w), nil
}

func (item *EngineSwitchMasterReplicaModeResult) WriteJSON(w []byte) []byte {
	tctx := basictl.JSONWriteContext{}
	return item.WriteJSONOpt(&tctx, w)
}
func (item *EngineSwitchMasterReplicaModeResult) WriteJSONOpt(tctx *basictl.JSONWriteContext, w []byte) []byte {
	switch item.index {
	case 0:
		if tctx.IsTL2 {
			w = append(w, `{"type":"engine.switchedToMasterMode"`...)
		} else {
			if tctx.LegacyTypeNames {
				w = append(w, `{"type":"engine.switchedToMasterMode#95b13964"`...)
			} else {
				w = append(w, `{"type":"engine.switchedToMasterMode"`...)
			}
		}
		return append(w, '}')
	case 1:
		if tctx.IsTL2 {
			w = append(w, `{"type":"engine.switchedToReplicaMode"`...)
		} else {
			if tctx.LegacyTypeNames {
				w = append(w, `{"type":"engine.switchedToReplicaMode#ad642a0b"`...)
			} else {
				w = append(w, `{"type":"engine.switchedToReplicaMode"`...)
			}
		}
		return append(w, '}')
	case 2:
		if tctx.IsTL2 {
			w = append(w, `{"type":"engine.alreadyInMasterMode"`...)
		} else {
			if tctx.LegacyTypeNames {
				w = append(w, `{"type":"engine.alreadyInMasterMode#402409cb"`...)
			} else {
				w = append(w, `{"type":"engine.alreadyInMasterMode"`...)
			}
		}
		return append(w, '}')
	case 3:
		if tctx.IsTL2 {
			w = append(w, `{"type":"engine.alreadyInReplicaMode"`...)
		} else {
			if tctx.LegacyTypeNames {
				w = append(w, `{"type":"engine.alreadyInReplicaMode#ebd80142"`...)
			} else {
				w = append(w, `{"type":"engine.alreadyInReplicaMode"`...)
			}
		}
		return append(w, '}')
	case 4:
		if tctx.IsTL2 {
			w = append(w, `{"type":"engine.switchedToMasterModeForcefully"`...)
		} else {
			if tctx.LegacyTypeNames {
				w = append(w, `{"type":"engine.switchedToMasterModeForcefully#ec61b4be"`...)
			} else {
				w = append(w, `{"type":"engine.switchedToMasterModeForcefully"`...)
			}
		}
		w = append(w, `,"value":`...)
		w = item.valueSwitchedToMasterModeForcefully.WriteJSONOpt(tctx, w)
		return append(w, '}')
	case 5:
		if tctx.IsTL2 {
			w = append(w, `{"type":"engine.failedToSwitchMode"`...)
		} else {
			if tctx.LegacyTypeNames {
				w = append(w, `{"type":"engine.failedToSwitchMode#17418662"`...)
			} else {
				w = append(w, `{"type":"engine.failedToSwitchMode"`...)
			}
		}
		w = append(w, `,"value":`...)
		w = item.valueFailedToSwitchMode.WriteJSONOpt(tctx, w)
		return append(w, '}')
	default: // Impossible due to panic above
		return w
	}
}

func (item EngineSwitchMasterReplicaModeResult) String() string {
	return string(item.WriteJSON(nil))
}

func (item *EngineSwitchMasterReplicaModeResult) MarshalJSON() ([]byte, error) {
	return item.WriteJSON(nil), nil
}

func (item *EngineSwitchMasterReplicaModeResult) UnmarshalJSON(b []byte) error {
	if err := item.ReadJSON(true, &basictl.JsonLexer{Data: b}); err != nil {
		return ErrorInvalidJSON("engine.SwitchMasterReplicaModeResult", err.Error())
	}
	return nil
}

func (item EngineSwitchedToMasterMode) AsUnion() EngineSwitchMasterReplicaModeResult {
	var ret EngineSwitchMasterReplicaModeResult
	ret.SetSwitchedToMasterMode()
	return ret
}

type EngineSwitchedToMasterMode struct {
}

func (EngineSwitchedToMasterMode) TLName() string { return "engine.switchedToMasterMode" }
func (EngineSwitchedToMasterMode) TLTag() uint32  { return 0x95b13964 }

func (item *EngineSwitchedToMasterMode) Reset() {}

func (item *EngineSwitchedToMasterMode) FillRandom(rg *basictl.RandGenerator) {}

func (item *EngineSwitchedToMasterMode) Read(w []byte) (_ []byte, err error) { return w, nil }

func (item *EngineSwitchedToMasterMode) WriteGeneral(w []byte) (_ []byte, err error) {
	return item.Write(w), nil
}

func (item *EngineSwitchedToMasterMode) Write(w []byte) []byte {
	return w
}

func (item *EngineSwitchedToMasterMode) ReadBoxed(w []byte) (_ []byte, err error) {
	if w, err = basictl.NatReadExactTag(w, 0x95b13964); err != nil {
		return w, err
	}
	return item.Read(w)
}

func (item *EngineSwitchedToMasterMode) WriteBoxedGeneral(w []byte) (_ []byte, err error) {
	return item.WriteBoxed(w), nil
}

func (item *EngineSwitchedToMasterMode) WriteBoxed(w []byte) []byte {
	w = basictl.NatWrite(w, 0x95b13964)
	return item.Write(w)
}

func (item EngineSwitchedToMasterMode) String() string {
	return string(item.WriteJSON(nil))
}

func (item *EngineSwitchedToMasterMode) ReadJSON(legacyTypeNames bool, in *basictl.JsonLexer) error {
	tctx := basictl.JSONReadContext{LegacyTypeNames: legacyTypeNames}
	return item.ReadJSONGeneral(&tctx, in)
}

func (item *EngineSwitchedToMasterMode) ReadJSONGeneral(tctx *basictl.JSONReadContext, in *basictl.JsonLexer) error {
	if in != nil {
		in.Delim('{')
		if !in.Ok() {
			return in.Error()
		}
		for !in.IsDelim('}') {
			return ErrorInvalidJSON("engine.switchedToMasterMode", "this object can't have properties")
		}
		in.Delim('}')
		if !in.Ok() {
			return in.Error()
		}
	}
	return nil
}

// This method is general version of WriteJSON, use it instead!
func (item *EngineSwitchedToMasterMode) WriteJSONGeneral(tctx *basictl.JSONWriteContext, w []byte) (_ []byte, err error) {
	return item.WriteJSONOpt(tctx, w), nil
}

func (item *EngineSwitchedToMasterMode) WriteJSON(w []byte) []byte {
	tctx := basictl.JSONWriteContext{}
	return item.WriteJSONOpt(&tctx, w)
}
func (item *EngineSwitchedToMasterMode) WriteJSONOpt(tctx *basictl.JSONWriteContext, w []byte) []byte {
	w = append(w, '{')
	return append(w, '}')
}

func (item *EngineSwitchedToMasterMode) MarshalJSON() ([]byte, error) {
	return item.WriteJSON(nil), nil
}

func (item *EngineSwitchedToMasterMode) UnmarshalJSON(b []byte) error {
	if err := item.ReadJSON(true, &basictl.JsonLexer{Data: b}); err != nil {
		return ErrorInvalidJSON("engine.switchedToMasterMode", err.Error())
	}
	return nil
}

func (item *EngineSwitchedToMasterMode) WriteTL2(w []byte, ctx *basictl.TL2WriteContext) []byte {
	panic(ErrorTL2SerializersNotGenerated("engine.switchedToMasterMode"))
}

func (item *EngineSwitchedToMasterMode) ReadTL2(r []byte, ctx *basictl.TL2ReadContext) (_ []byte, err error) {
	return r, ErrorTL2SerializersNotGenerated("engine.switchedToMasterMode")
}

func (item EngineSwitchedToMasterModeForcefully) AsUnion() EngineSwitchMasterReplicaModeResult {
	var ret EngineSwitchMasterReplicaModeResult
	ret.SetSwitchedToMasterModeForcefully(item)
	return ret
}

type EngineSwitchedToMasterModeForcefully struct {
	BytesTruncated int64
}

func (EngineSwitchedToMasterModeForcefully) TLName() string {
	return "engine.switchedToMasterModeForcefully"
}
func (EngineSwitchedToMasterModeForcefully) TLTag() uint32 { return 0xec61b4be }

func (item *EngineSwitchedToMasterModeForcefully) Reset() {
	item.BytesTruncated = 0
}

func (item *EngineSwitchedToMasterModeForcefully) FillRandom(rg *basictl.RandGenerator) {
	item.BytesTruncated = basictl.RandomLong(rg)
}

func (item *EngineSwitchedToMasterModeForcefully) Read(w []byte) (_ []byte, err error) {
	return basictl.LongRead(w, &item.BytesTruncated)
}

func (item *EngineSwitchedToMasterModeForcefully) WriteGeneral(w []byte) (_ []byte, err error) {
	return item.Write(w), nil
}

func (item *EngineSwitchedToMasterModeForcefully) Write(w []byte) []byte {
	w = basictl.LongWrite(w, item.BytesTruncated)
	return w
}

func (item *EngineSwitchedToMasterModeForcefully) ReadBoxed(w []byte) (_ []byte, err error) {
	if w, err = basictl.NatReadExactTag(w, 0xec61b4be); err != nil {
		return w, err
	}
	return item.Read(w)
}

func (item *EngineSwitchedToMasterModeForcefully) WriteBoxedGeneral(w []byte) (_ []byte, err error) {
	return item.WriteBoxed(w), nil
}

func (item *EngineSwitchedToMasterModeForcefully) WriteBoxed(w []byte) []byte {
	w = basictl.NatWrite(w, 0xec61b4be)
	return item.Write(w)
}

func (item EngineSwitchedToMasterModeForcefully) String() string {
	return string(item.WriteJSON(nil))
}

func (item *EngineSwitchedToMasterModeForcefully) ReadJSON(legacyTypeNames bool, in *basictl.JsonLexer) error {
	tctx := basictl.JSONReadContext{LegacyTypeNames: legacyTypeNames}
	return item.ReadJSONGeneral(&tctx, in)
}

func (item *EngineSwitchedToMasterModeForcefully) ReadJSONGeneral(tctx *basictl.JSONReadContext, in *basictl.JsonLexer) error {
	var propBytesTruncatedPresented bool

	if in != nil {
		in.Delim('{')
		if !in.Ok() {
			return in.Error()
		}
		for !in.IsDelim('}') {
			key := in.UnsafeFieldName(true)
			in.WantColon()
			switch key {
			case "bytes_truncated":
				if propBytesTruncatedPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("engine.switchedToMasterModeForcefully", "bytes_truncated")
				}
				if err := Json2ReadInt64(in, &item.BytesTruncated); err != nil {
					return err
				}
				propBytesTruncatedPresented = true
			default:
				return ErrorInvalidJSONExcessElement("engine.switchedToMasterModeForcefully", key)
			}
			in.WantComma()
		}
		in.Delim('}')
		if !in.Ok() {
			return in.Error()
		}
	}
	if !propBytesTruncatedPresented {
		item.BytesTruncated = 0
	}
	return nil
}

// This method is general version of WriteJSON, use it instead!
func (item *EngineSwitchedToMasterModeForcefully) WriteJSONGeneral(tctx *basictl.JSONWriteContext, w []byte) (_ []byte, err error) {
	return item.WriteJSONOpt(tctx, w), nil
}

func (item *EngineSwitchedToMasterModeForcefully) WriteJSON(w []byte) []byte {
	tctx := basictl.JSONWriteContext{}
	return item.WriteJSONOpt(&tctx, w)
}
func (item *EngineSwitchedToMasterModeForcefully) WriteJSONOpt(tctx *basictl.JSONWriteContext, w []byte) []byte {
	w = append(w, '{')
	backupIndexBytesTruncated := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"bytes_truncated":`...)
	w = basictl.JSONWriteInt64(w, item.BytesTruncated)
	if (item.BytesTruncated != 0) == false {
		w = w[:backupIndexBytesTruncated]
	}
	return append(w, '}')
}

func (item *EngineSwitchedToMasterModeForcefully) MarshalJSON() ([]byte, error) {
	return item.WriteJSON(nil), nil
}

func (item *EngineSwitchedToMasterModeForcefully) UnmarshalJSON(b []byte) error {
	if err := item.ReadJSON(true, &basictl.JsonLexer{Data: b}); err != nil {
		return ErrorInvalidJSON("engine.switchedToMasterModeForcefully", err.Error())
	}
	return nil
}

func (item *EngineSwitchedToMasterModeForcefully) WriteTL2(w []byte, ctx *basictl.TL2WriteContext) []byte {
	panic(ErrorTL2SerializersNotGenerated("engine.switchedToMasterModeForcefully"))
}

func (item *EngineSwitchedToMasterModeForcefully) ReadTL2(r []byte, ctx *basictl.TL2ReadContext) (_ []byte, err error) {
	return r, ErrorTL2SerializersNotGenerated("engine.switchedToMasterModeForcefully")
}

func (item EngineSwitchedToReplicaMode) AsUnion() EngineSwitchMasterReplicaModeResult {
	var ret EngineSwitchMasterReplicaModeResult
	ret.SetSwitchedToReplicaMode()
	return ret
}

type EngineSwitchedToReplicaMode struct {
}

func (EngineSwitchedToReplicaMode) TLName() string { return "engine.switchedToReplicaMode" }
func (EngineSwitchedToReplicaMode) TLTag() uint32  { return 0xad642a0b }

func (item *EngineSwitchedToReplicaMode) Reset() {}

func (item *EngineSwitchedToReplicaMode) FillRandom(rg *basictl.RandGenerator) {}

func (item *EngineSwitchedToReplicaMode) Read(w []byte) (_ []byte, err error) { return w, nil }

func (item *EngineSwitchedToReplicaMode) WriteGeneral(w []byte) (_ []byte, err error) {
	return item.Write(w), nil
}

func (item *EngineSwitchedToReplicaMode) Write(w []byte) []byte {
	return w
}

func (item *EngineSwitchedToReplicaMode) ReadBoxed(w []byte) (_ []byte, err error) {
	if w, err = basictl.NatReadExactTag(w, 0xad642a0b); err != nil {
		return w, err
	}
	return item.Read(w)
}

func (item *EngineSwitchedToReplicaMode) WriteBoxedGeneral(w []byte) (_ []byte, err error) {
	return item.WriteBoxed(w), nil
}

func (item *EngineSwitchedToReplicaMode) WriteBoxed(w []byte) []byte {
	w = basictl.NatWrite(w, 0xad642a0b)
	return item.Write(w)
}

func (item EngineSwitchedToReplicaMode) String() string {
	return string(item.WriteJSON(nil))
}

func (item *EngineSwitchedToReplicaMode) ReadJSON(legacyTypeNames bool, in *basictl.JsonLexer) error {
	tctx := basictl.JSONReadContext{LegacyTypeNames: legacyTypeNames}
	return item.ReadJSONGeneral(&tctx, in)
}

func (item *EngineSwitchedToReplicaMode) ReadJSONGeneral(tctx *basictl.JSONReadContext, in *basictl.JsonLexer) error {
	if in != nil {
		in.Delim('{')
		if !in.Ok() {
			return in.Error()
		}
		for !in.IsDelim('}') {
			return ErrorInvalidJSON("engine.switchedToReplicaMode", "this object can't have properties")
		}
		in.Delim('}')
		if !in.Ok() {
			return in.Error()
		}
	}
	return nil
}

// This method is general version of WriteJSON, use it instead!
func (item *EngineSwitchedToReplicaMode) WriteJSONGeneral(tctx *basictl.JSONWriteContext, w []byte) (_ []byte, err error) {
	return item.WriteJSONOpt(tctx, w), nil
}

func (item *EngineSwitchedToReplicaMode) WriteJSON(w []byte) []byte {
	tctx := basictl.JSONWriteContext{}
	return item.WriteJSONOpt(&tctx, w)
}
func (item *EngineSwitchedToReplicaMode) WriteJSONOpt(tctx *basictl.JSONWriteContext, w []byte) []byte {
	w = append(w, '{')
	return append(w, '}')
}

func (item *EngineSwitchedToReplicaMode) MarshalJSON() ([]byte, error) {
	return item.WriteJSON(nil), nil
}

func (item *EngineSwitchedToReplicaMode) UnmarshalJSON(b []byte) error {
	if err := item.ReadJSON(true, &basictl.JsonLexer{Data: b}); err != nil {
		return ErrorInvalidJSON("engine.switchedToReplicaMode", err.Error())
	}
	return nil
}

func (item *EngineSwitchedToReplicaMode) WriteTL2(w []byte, ctx *basictl.TL2WriteContext) []byte {
	panic(ErrorTL2SerializersNotGenerated("engine.switchedToReplicaMode"))
}

func (item *EngineSwitchedToReplicaMode) ReadTL2(r []byte, ctx *basictl.TL2ReadContext) (_ []byte, err error) {
	return r, ErrorTL2SerializersNotGenerated("engine.switchedToReplicaMode")
}
