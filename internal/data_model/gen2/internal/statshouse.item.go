// Copyright 2022 V Kontakte LLC
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

// Code generated by vktl/cmd/tlgen2; DO NOT EDIT.
package internal

import (
	"github.com/vkcom/statshouse/internal/vkgo/basictl"
)

var _ = basictl.NatWrite

type StatshouseItem struct {
	FieldsMask     uint32
	Metric         int32
	Keys           []int32
	Counter        float64
	T              uint32                       // Conditional: item.FieldsMask.0
	ValueMin       float64                      // Conditional: item.FieldsMask.1
	ValueMax       float64                      // Conditional: item.FieldsMask.2
	ValueSum       float64                      // Conditional: item.FieldsMask.2
	ValueSumSquare float64                      // Conditional: item.FieldsMask.2
	Percentiles    []float32                    // Conditional: item.FieldsMask.3
	Uniques        []int64                      // Conditional: item.FieldsMask.4
	StringTops     []StatshouseStringTopElement // Conditional: item.FieldsMask.5
	Centroids      []StatshouseCentroid         // Conditional: item.FieldsMask.6
}

func (StatshouseItem) TLName() string { return "statshouse.item" }
func (StatshouseItem) TLTag() uint32  { return 0xc803d06 }

func (item *StatshouseItem) SetT(v uint32) {
	item.T = v
	item.FieldsMask |= 1 << 0
}
func (item *StatshouseItem) ClearT() {
	item.T = 0
	item.FieldsMask &^= 1 << 0
}
func (item *StatshouseItem) IsSetT() bool { return item.FieldsMask&(1<<0) != 0 }

func (item *StatshouseItem) SetValueMin(v float64) {
	item.ValueMin = v
	item.FieldsMask |= 1 << 1
}
func (item *StatshouseItem) ClearValueMin() {
	item.ValueMin = 0
	item.FieldsMask &^= 1 << 1
}
func (item *StatshouseItem) IsSetValueMin() bool { return item.FieldsMask&(1<<1) != 0 }

func (item *StatshouseItem) SetValueMax(v float64) {
	item.ValueMax = v
	item.FieldsMask |= 1 << 2
}
func (item *StatshouseItem) ClearValueMax() {
	item.ValueMax = 0
	item.FieldsMask &^= 1 << 2
}
func (item *StatshouseItem) IsSetValueMax() bool { return item.FieldsMask&(1<<2) != 0 }

func (item *StatshouseItem) SetValueSum(v float64) {
	item.ValueSum = v
	item.FieldsMask |= 1 << 2
}
func (item *StatshouseItem) ClearValueSum() {
	item.ValueSum = 0
	item.FieldsMask &^= 1 << 2
}
func (item *StatshouseItem) IsSetValueSum() bool { return item.FieldsMask&(1<<2) != 0 }

func (item *StatshouseItem) SetValueSumSquare(v float64) {
	item.ValueSumSquare = v
	item.FieldsMask |= 1 << 2
}
func (item *StatshouseItem) ClearValueSumSquare() {
	item.ValueSumSquare = 0
	item.FieldsMask &^= 1 << 2
}
func (item *StatshouseItem) IsSetValueSumSquare() bool { return item.FieldsMask&(1<<2) != 0 }

func (item *StatshouseItem) SetPercentiles(v []float32) {
	item.Percentiles = v
	item.FieldsMask |= 1 << 3
}
func (item *StatshouseItem) ClearPercentiles() {
	item.Percentiles = item.Percentiles[:0]
	item.FieldsMask &^= 1 << 3
}
func (item *StatshouseItem) IsSetPercentiles() bool { return item.FieldsMask&(1<<3) != 0 }

func (item *StatshouseItem) SetUniques(v []int64) {
	item.Uniques = v
	item.FieldsMask |= 1 << 4
}
func (item *StatshouseItem) ClearUniques() {
	item.Uniques = item.Uniques[:0]
	item.FieldsMask &^= 1 << 4
}
func (item *StatshouseItem) IsSetUniques() bool { return item.FieldsMask&(1<<4) != 0 }

func (item *StatshouseItem) SetStringTops(v []StatshouseStringTopElement) {
	item.StringTops = v
	item.FieldsMask |= 1 << 5
}
func (item *StatshouseItem) ClearStringTops() {
	item.StringTops = item.StringTops[:0]
	item.FieldsMask &^= 1 << 5
}
func (item *StatshouseItem) IsSetStringTops() bool { return item.FieldsMask&(1<<5) != 0 }

func (item *StatshouseItem) SetCentroids(v []StatshouseCentroid) {
	item.Centroids = v
	item.FieldsMask |= 1 << 6
}
func (item *StatshouseItem) ClearCentroids() {
	item.Centroids = item.Centroids[:0]
	item.FieldsMask &^= 1 << 6
}
func (item *StatshouseItem) IsSetCentroids() bool { return item.FieldsMask&(1<<6) != 0 }

func (item *StatshouseItem) Reset() {
	item.FieldsMask = 0
	item.Metric = 0
	item.Keys = item.Keys[:0]
	item.Counter = 0
	item.T = 0
	item.ValueMin = 0
	item.ValueMax = 0
	item.ValueSum = 0
	item.ValueSumSquare = 0
	item.Percentiles = item.Percentiles[:0]
	item.Uniques = item.Uniques[:0]
	item.StringTops = item.StringTops[:0]
	item.Centroids = item.Centroids[:0]
}

func (item *StatshouseItem) Read(w []byte) (_ []byte, err error) {
	if w, err = basictl.NatRead(w, &item.FieldsMask); err != nil {
		return w, err
	}
	if w, err = basictl.IntRead(w, &item.Metric); err != nil {
		return w, err
	}
	if w, err = VectorInt0Read(w, &item.Keys); err != nil {
		return w, err
	}
	if w, err = basictl.DoubleRead(w, &item.Counter); err != nil {
		return w, err
	}
	if item.FieldsMask&(1<<0) != 0 {
		if w, err = basictl.NatRead(w, &item.T); err != nil {
			return w, err
		}
	} else {
		item.T = 0
	}
	if item.FieldsMask&(1<<1) != 0 {
		if w, err = basictl.DoubleRead(w, &item.ValueMin); err != nil {
			return w, err
		}
	} else {
		item.ValueMin = 0
	}
	if item.FieldsMask&(1<<2) != 0 {
		if w, err = basictl.DoubleRead(w, &item.ValueMax); err != nil {
			return w, err
		}
	} else {
		item.ValueMax = 0
	}
	if item.FieldsMask&(1<<2) != 0 {
		if w, err = basictl.DoubleRead(w, &item.ValueSum); err != nil {
			return w, err
		}
	} else {
		item.ValueSum = 0
	}
	if item.FieldsMask&(1<<2) != 0 {
		if w, err = basictl.DoubleRead(w, &item.ValueSumSquare); err != nil {
			return w, err
		}
	} else {
		item.ValueSumSquare = 0
	}
	if item.FieldsMask&(1<<3) != 0 {
		if w, err = VectorFloat0Read(w, &item.Percentiles); err != nil {
			return w, err
		}
	} else {
		item.Percentiles = item.Percentiles[:0]
	}
	if item.FieldsMask&(1<<4) != 0 {
		if w, err = VectorLong0Read(w, &item.Uniques); err != nil {
			return w, err
		}
	} else {
		item.Uniques = item.Uniques[:0]
	}
	if item.FieldsMask&(1<<5) != 0 {
		if w, err = VectorStatshouseStringTopElement0Read(w, &item.StringTops); err != nil {
			return w, err
		}
	} else {
		item.StringTops = item.StringTops[:0]
	}
	if item.FieldsMask&(1<<6) != 0 {
		if w, err = VectorStatshouseCentroid0Read(w, &item.Centroids); err != nil {
			return w, err
		}
	} else {
		item.Centroids = item.Centroids[:0]
	}
	return w, nil
}

func (item *StatshouseItem) Write(w []byte) (_ []byte, err error) {
	w = basictl.NatWrite(w, item.FieldsMask)
	w = basictl.IntWrite(w, item.Metric)
	if w, err = VectorInt0Write(w, item.Keys); err != nil {
		return w, err
	}
	w = basictl.DoubleWrite(w, item.Counter)
	if item.FieldsMask&(1<<0) != 0 {
		w = basictl.NatWrite(w, item.T)
	}
	if item.FieldsMask&(1<<1) != 0 {
		w = basictl.DoubleWrite(w, item.ValueMin)
	}
	if item.FieldsMask&(1<<2) != 0 {
		w = basictl.DoubleWrite(w, item.ValueMax)
	}
	if item.FieldsMask&(1<<2) != 0 {
		w = basictl.DoubleWrite(w, item.ValueSum)
	}
	if item.FieldsMask&(1<<2) != 0 {
		w = basictl.DoubleWrite(w, item.ValueSumSquare)
	}
	if item.FieldsMask&(1<<3) != 0 {
		if w, err = VectorFloat0Write(w, item.Percentiles); err != nil {
			return w, err
		}
	}
	if item.FieldsMask&(1<<4) != 0 {
		if w, err = VectorLong0Write(w, item.Uniques); err != nil {
			return w, err
		}
	}
	if item.FieldsMask&(1<<5) != 0 {
		if w, err = VectorStatshouseStringTopElement0Write(w, item.StringTops); err != nil {
			return w, err
		}
	}
	if item.FieldsMask&(1<<6) != 0 {
		if w, err = VectorStatshouseCentroid0Write(w, item.Centroids); err != nil {
			return w, err
		}
	}
	return w, nil
}

func (item *StatshouseItem) ReadBoxed(w []byte) (_ []byte, err error) {
	if w, err = basictl.NatReadExactTag(w, 0xc803d06); err != nil {
		return w, err
	}
	return item.Read(w)
}

func (item *StatshouseItem) WriteBoxed(w []byte) ([]byte, error) {
	w = basictl.NatWrite(w, 0xc803d06)
	return item.Write(w)
}

func (item StatshouseItem) String() string {
	w, err := item.WriteJSON(nil)
	if err != nil {
		return err.Error()
	}
	return string(w)
}

func StatshouseItem__ReadJSON(item *StatshouseItem, j interface{}) error { return item.readJSON(j) }
func (item *StatshouseItem) readJSON(j interface{}) error {
	_jm, _ok := j.(map[string]interface{})
	if j != nil && !_ok {
		return ErrorInvalidJSON("statshouse.item", "expected json object")
	}
	_jFieldsMask := _jm["fields_mask"]
	delete(_jm, "fields_mask")
	if err := JsonReadUint32(_jFieldsMask, &item.FieldsMask); err != nil {
		return err
	}
	_jMetric := _jm["metric"]
	delete(_jm, "metric")
	if err := JsonReadInt32(_jMetric, &item.Metric); err != nil {
		return err
	}
	_jKeys := _jm["keys"]
	delete(_jm, "keys")
	_jCounter := _jm["counter"]
	delete(_jm, "counter")
	if err := JsonReadFloat64(_jCounter, &item.Counter); err != nil {
		return err
	}
	_jT := _jm["t"]
	delete(_jm, "t")
	_jValueMin := _jm["value_min"]
	delete(_jm, "value_min")
	_jValueMax := _jm["value_max"]
	delete(_jm, "value_max")
	_jValueSum := _jm["value_sum"]
	delete(_jm, "value_sum")
	_jValueSumSquare := _jm["value_sum_square"]
	delete(_jm, "value_sum_square")
	_jPercentiles := _jm["percentiles"]
	delete(_jm, "percentiles")
	_jUniques := _jm["uniques"]
	delete(_jm, "uniques")
	_jStringTops := _jm["string_tops"]
	delete(_jm, "string_tops")
	_jCentroids := _jm["centroids"]
	delete(_jm, "centroids")
	for k := range _jm {
		return ErrorInvalidJSONExcessElement("statshouse.item", k)
	}
	if _jT != nil {
		item.FieldsMask |= 1 << 0
	}
	if _jValueMin != nil {
		item.FieldsMask |= 1 << 1
	}
	if _jValueMax != nil {
		item.FieldsMask |= 1 << 2
	}
	if _jValueSum != nil {
		item.FieldsMask |= 1 << 2
	}
	if _jValueSumSquare != nil {
		item.FieldsMask |= 1 << 2
	}
	if _jPercentiles != nil {
		item.FieldsMask |= 1 << 3
	}
	if _jUniques != nil {
		item.FieldsMask |= 1 << 4
	}
	if _jStringTops != nil {
		item.FieldsMask |= 1 << 5
	}
	if _jCentroids != nil {
		item.FieldsMask |= 1 << 6
	}
	if err := VectorInt0ReadJSON(_jKeys, &item.Keys); err != nil {
		return err
	}
	if _jT != nil {
		if err := JsonReadUint32(_jT, &item.T); err != nil {
			return err
		}
	} else {
		item.T = 0
	}
	if _jValueMin != nil {
		if err := JsonReadFloat64(_jValueMin, &item.ValueMin); err != nil {
			return err
		}
	} else {
		item.ValueMin = 0
	}
	if _jValueMax != nil {
		if err := JsonReadFloat64(_jValueMax, &item.ValueMax); err != nil {
			return err
		}
	} else {
		item.ValueMax = 0
	}
	if _jValueSum != nil {
		if err := JsonReadFloat64(_jValueSum, &item.ValueSum); err != nil {
			return err
		}
	} else {
		item.ValueSum = 0
	}
	if _jValueSumSquare != nil {
		if err := JsonReadFloat64(_jValueSumSquare, &item.ValueSumSquare); err != nil {
			return err
		}
	} else {
		item.ValueSumSquare = 0
	}
	if _jPercentiles != nil {
		if err := VectorFloat0ReadJSON(_jPercentiles, &item.Percentiles); err != nil {
			return err
		}
	} else {
		item.Percentiles = item.Percentiles[:0]
	}
	if _jUniques != nil {
		if err := VectorLong0ReadJSON(_jUniques, &item.Uniques); err != nil {
			return err
		}
	} else {
		item.Uniques = item.Uniques[:0]
	}
	if _jStringTops != nil {
		if err := VectorStatshouseStringTopElement0ReadJSON(_jStringTops, &item.StringTops); err != nil {
			return err
		}
	} else {
		item.StringTops = item.StringTops[:0]
	}
	if _jCentroids != nil {
		if err := VectorStatshouseCentroid0ReadJSON(_jCentroids, &item.Centroids); err != nil {
			return err
		}
	} else {
		item.Centroids = item.Centroids[:0]
	}
	return nil
}

func (item *StatshouseItem) WriteJSON(w []byte) (_ []byte, err error) {
	w = append(w, '{')
	if item.FieldsMask != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"fields_mask":`...)
		w = basictl.JSONWriteUint32(w, item.FieldsMask)
	}
	if item.Metric != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"metric":`...)
		w = basictl.JSONWriteInt32(w, item.Metric)
	}
	if len(item.Keys) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"keys":`...)
		if w, err = VectorInt0WriteJSON(w, item.Keys); err != nil {
			return w, err
		}
	}
	if item.Counter != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"counter":`...)
		w = basictl.JSONWriteFloat64(w, item.Counter)
	}
	if item.FieldsMask&(1<<0) != 0 {
		if item.T != 0 {
			w = basictl.JSONAddCommaIfNeeded(w)
			w = append(w, `"t":`...)
			w = basictl.JSONWriteUint32(w, item.T)
		}
	}
	if item.FieldsMask&(1<<1) != 0 {
		if item.ValueMin != 0 {
			w = basictl.JSONAddCommaIfNeeded(w)
			w = append(w, `"value_min":`...)
			w = basictl.JSONWriteFloat64(w, item.ValueMin)
		}
	}
	if item.FieldsMask&(1<<2) != 0 {
		if item.ValueMax != 0 {
			w = basictl.JSONAddCommaIfNeeded(w)
			w = append(w, `"value_max":`...)
			w = basictl.JSONWriteFloat64(w, item.ValueMax)
		}
	}
	if item.FieldsMask&(1<<2) != 0 {
		if item.ValueSum != 0 {
			w = basictl.JSONAddCommaIfNeeded(w)
			w = append(w, `"value_sum":`...)
			w = basictl.JSONWriteFloat64(w, item.ValueSum)
		}
	}
	if item.FieldsMask&(1<<2) != 0 {
		if item.ValueSumSquare != 0 {
			w = basictl.JSONAddCommaIfNeeded(w)
			w = append(w, `"value_sum_square":`...)
			w = basictl.JSONWriteFloat64(w, item.ValueSumSquare)
		}
	}
	if item.FieldsMask&(1<<3) != 0 {
		if len(item.Percentiles) != 0 {
			w = basictl.JSONAddCommaIfNeeded(w)
			w = append(w, `"percentiles":`...)
			if w, err = VectorFloat0WriteJSON(w, item.Percentiles); err != nil {
				return w, err
			}
		}
	}
	if item.FieldsMask&(1<<4) != 0 {
		if len(item.Uniques) != 0 {
			w = basictl.JSONAddCommaIfNeeded(w)
			w = append(w, `"uniques":`...)
			if w, err = VectorLong0WriteJSON(w, item.Uniques); err != nil {
				return w, err
			}
		}
	}
	if item.FieldsMask&(1<<5) != 0 {
		if len(item.StringTops) != 0 {
			w = basictl.JSONAddCommaIfNeeded(w)
			w = append(w, `"string_tops":`...)
			if w, err = VectorStatshouseStringTopElement0WriteJSON(w, item.StringTops); err != nil {
				return w, err
			}
		}
	}
	if item.FieldsMask&(1<<6) != 0 {
		if len(item.Centroids) != 0 {
			w = basictl.JSONAddCommaIfNeeded(w)
			w = append(w, `"centroids":`...)
			if w, err = VectorStatshouseCentroid0WriteJSON(w, item.Centroids); err != nil {
				return w, err
			}
		}
	}
	return append(w, '}'), nil
}

func (item *StatshouseItem) MarshalJSON() ([]byte, error) {
	return item.WriteJSON(nil)
}

func (item *StatshouseItem) UnmarshalJSON(b []byte) error {
	j, err := JsonBytesToInterface(b)
	if err != nil {
		return ErrorInvalidJSON("statshouse.item", err.Error())
	}
	if err = item.readJSON(j); err != nil {
		return ErrorInvalidJSON("statshouse.item", err.Error())
	}
	return nil
}

type StatshouseItemBytes struct {
	FieldsMask     uint32
	Metric         int32
	Keys           []int32
	Counter        float64
	T              uint32                            // Conditional: item.FieldsMask.0
	ValueMin       float64                           // Conditional: item.FieldsMask.1
	ValueMax       float64                           // Conditional: item.FieldsMask.2
	ValueSum       float64                           // Conditional: item.FieldsMask.2
	ValueSumSquare float64                           // Conditional: item.FieldsMask.2
	Percentiles    []float32                         // Conditional: item.FieldsMask.3
	Uniques        []int64                           // Conditional: item.FieldsMask.4
	StringTops     []StatshouseStringTopElementBytes // Conditional: item.FieldsMask.5
	Centroids      []StatshouseCentroid              // Conditional: item.FieldsMask.6
}

func (StatshouseItemBytes) TLName() string { return "statshouse.item" }
func (StatshouseItemBytes) TLTag() uint32  { return 0xc803d06 }

func (item *StatshouseItemBytes) SetT(v uint32) {
	item.T = v
	item.FieldsMask |= 1 << 0
}
func (item *StatshouseItemBytes) ClearT() {
	item.T = 0
	item.FieldsMask &^= 1 << 0
}
func (item *StatshouseItemBytes) IsSetT() bool { return item.FieldsMask&(1<<0) != 0 }

func (item *StatshouseItemBytes) SetValueMin(v float64) {
	item.ValueMin = v
	item.FieldsMask |= 1 << 1
}
func (item *StatshouseItemBytes) ClearValueMin() {
	item.ValueMin = 0
	item.FieldsMask &^= 1 << 1
}
func (item *StatshouseItemBytes) IsSetValueMin() bool { return item.FieldsMask&(1<<1) != 0 }

func (item *StatshouseItemBytes) SetValueMax(v float64) {
	item.ValueMax = v
	item.FieldsMask |= 1 << 2
}
func (item *StatshouseItemBytes) ClearValueMax() {
	item.ValueMax = 0
	item.FieldsMask &^= 1 << 2
}
func (item *StatshouseItemBytes) IsSetValueMax() bool { return item.FieldsMask&(1<<2) != 0 }

func (item *StatshouseItemBytes) SetValueSum(v float64) {
	item.ValueSum = v
	item.FieldsMask |= 1 << 2
}
func (item *StatshouseItemBytes) ClearValueSum() {
	item.ValueSum = 0
	item.FieldsMask &^= 1 << 2
}
func (item *StatshouseItemBytes) IsSetValueSum() bool { return item.FieldsMask&(1<<2) != 0 }

func (item *StatshouseItemBytes) SetValueSumSquare(v float64) {
	item.ValueSumSquare = v
	item.FieldsMask |= 1 << 2
}
func (item *StatshouseItemBytes) ClearValueSumSquare() {
	item.ValueSumSquare = 0
	item.FieldsMask &^= 1 << 2
}
func (item *StatshouseItemBytes) IsSetValueSumSquare() bool { return item.FieldsMask&(1<<2) != 0 }

func (item *StatshouseItemBytes) SetPercentiles(v []float32) {
	item.Percentiles = v
	item.FieldsMask |= 1 << 3
}
func (item *StatshouseItemBytes) ClearPercentiles() {
	item.Percentiles = item.Percentiles[:0]
	item.FieldsMask &^= 1 << 3
}
func (item *StatshouseItemBytes) IsSetPercentiles() bool { return item.FieldsMask&(1<<3) != 0 }

func (item *StatshouseItemBytes) SetUniques(v []int64) {
	item.Uniques = v
	item.FieldsMask |= 1 << 4
}
func (item *StatshouseItemBytes) ClearUniques() {
	item.Uniques = item.Uniques[:0]
	item.FieldsMask &^= 1 << 4
}
func (item *StatshouseItemBytes) IsSetUniques() bool { return item.FieldsMask&(1<<4) != 0 }

func (item *StatshouseItemBytes) SetStringTops(v []StatshouseStringTopElementBytes) {
	item.StringTops = v
	item.FieldsMask |= 1 << 5
}
func (item *StatshouseItemBytes) ClearStringTops() {
	item.StringTops = item.StringTops[:0]
	item.FieldsMask &^= 1 << 5
}
func (item *StatshouseItemBytes) IsSetStringTops() bool { return item.FieldsMask&(1<<5) != 0 }

func (item *StatshouseItemBytes) SetCentroids(v []StatshouseCentroid) {
	item.Centroids = v
	item.FieldsMask |= 1 << 6
}
func (item *StatshouseItemBytes) ClearCentroids() {
	item.Centroids = item.Centroids[:0]
	item.FieldsMask &^= 1 << 6
}
func (item *StatshouseItemBytes) IsSetCentroids() bool { return item.FieldsMask&(1<<6) != 0 }

func (item *StatshouseItemBytes) Reset() {
	item.FieldsMask = 0
	item.Metric = 0
	item.Keys = item.Keys[:0]
	item.Counter = 0
	item.T = 0
	item.ValueMin = 0
	item.ValueMax = 0
	item.ValueSum = 0
	item.ValueSumSquare = 0
	item.Percentiles = item.Percentiles[:0]
	item.Uniques = item.Uniques[:0]
	item.StringTops = item.StringTops[:0]
	item.Centroids = item.Centroids[:0]
}

func (item *StatshouseItemBytes) Read(w []byte) (_ []byte, err error) {
	if w, err = basictl.NatRead(w, &item.FieldsMask); err != nil {
		return w, err
	}
	if w, err = basictl.IntRead(w, &item.Metric); err != nil {
		return w, err
	}
	if w, err = VectorInt0Read(w, &item.Keys); err != nil {
		return w, err
	}
	if w, err = basictl.DoubleRead(w, &item.Counter); err != nil {
		return w, err
	}
	if item.FieldsMask&(1<<0) != 0 {
		if w, err = basictl.NatRead(w, &item.T); err != nil {
			return w, err
		}
	} else {
		item.T = 0
	}
	if item.FieldsMask&(1<<1) != 0 {
		if w, err = basictl.DoubleRead(w, &item.ValueMin); err != nil {
			return w, err
		}
	} else {
		item.ValueMin = 0
	}
	if item.FieldsMask&(1<<2) != 0 {
		if w, err = basictl.DoubleRead(w, &item.ValueMax); err != nil {
			return w, err
		}
	} else {
		item.ValueMax = 0
	}
	if item.FieldsMask&(1<<2) != 0 {
		if w, err = basictl.DoubleRead(w, &item.ValueSum); err != nil {
			return w, err
		}
	} else {
		item.ValueSum = 0
	}
	if item.FieldsMask&(1<<2) != 0 {
		if w, err = basictl.DoubleRead(w, &item.ValueSumSquare); err != nil {
			return w, err
		}
	} else {
		item.ValueSumSquare = 0
	}
	if item.FieldsMask&(1<<3) != 0 {
		if w, err = VectorFloat0Read(w, &item.Percentiles); err != nil {
			return w, err
		}
	} else {
		item.Percentiles = item.Percentiles[:0]
	}
	if item.FieldsMask&(1<<4) != 0 {
		if w, err = VectorLong0Read(w, &item.Uniques); err != nil {
			return w, err
		}
	} else {
		item.Uniques = item.Uniques[:0]
	}
	if item.FieldsMask&(1<<5) != 0 {
		if w, err = VectorStatshouseStringTopElement0BytesRead(w, &item.StringTops); err != nil {
			return w, err
		}
	} else {
		item.StringTops = item.StringTops[:0]
	}
	if item.FieldsMask&(1<<6) != 0 {
		if w, err = VectorStatshouseCentroid0Read(w, &item.Centroids); err != nil {
			return w, err
		}
	} else {
		item.Centroids = item.Centroids[:0]
	}
	return w, nil
}

func (item *StatshouseItemBytes) Write(w []byte) (_ []byte, err error) {
	w = basictl.NatWrite(w, item.FieldsMask)
	w = basictl.IntWrite(w, item.Metric)
	if w, err = VectorInt0Write(w, item.Keys); err != nil {
		return w, err
	}
	w = basictl.DoubleWrite(w, item.Counter)
	if item.FieldsMask&(1<<0) != 0 {
		w = basictl.NatWrite(w, item.T)
	}
	if item.FieldsMask&(1<<1) != 0 {
		w = basictl.DoubleWrite(w, item.ValueMin)
	}
	if item.FieldsMask&(1<<2) != 0 {
		w = basictl.DoubleWrite(w, item.ValueMax)
	}
	if item.FieldsMask&(1<<2) != 0 {
		w = basictl.DoubleWrite(w, item.ValueSum)
	}
	if item.FieldsMask&(1<<2) != 0 {
		w = basictl.DoubleWrite(w, item.ValueSumSquare)
	}
	if item.FieldsMask&(1<<3) != 0 {
		if w, err = VectorFloat0Write(w, item.Percentiles); err != nil {
			return w, err
		}
	}
	if item.FieldsMask&(1<<4) != 0 {
		if w, err = VectorLong0Write(w, item.Uniques); err != nil {
			return w, err
		}
	}
	if item.FieldsMask&(1<<5) != 0 {
		if w, err = VectorStatshouseStringTopElement0BytesWrite(w, item.StringTops); err != nil {
			return w, err
		}
	}
	if item.FieldsMask&(1<<6) != 0 {
		if w, err = VectorStatshouseCentroid0Write(w, item.Centroids); err != nil {
			return w, err
		}
	}
	return w, nil
}

func (item *StatshouseItemBytes) ReadBoxed(w []byte) (_ []byte, err error) {
	if w, err = basictl.NatReadExactTag(w, 0xc803d06); err != nil {
		return w, err
	}
	return item.Read(w)
}

func (item *StatshouseItemBytes) WriteBoxed(w []byte) ([]byte, error) {
	w = basictl.NatWrite(w, 0xc803d06)
	return item.Write(w)
}

func (item StatshouseItemBytes) String() string {
	w, err := item.WriteJSON(nil)
	if err != nil {
		return err.Error()
	}
	return string(w)
}

func StatshouseItemBytes__ReadJSON(item *StatshouseItemBytes, j interface{}) error {
	return item.readJSON(j)
}
func (item *StatshouseItemBytes) readJSON(j interface{}) error {
	_jm, _ok := j.(map[string]interface{})
	if j != nil && !_ok {
		return ErrorInvalidJSON("statshouse.item", "expected json object")
	}
	_jFieldsMask := _jm["fields_mask"]
	delete(_jm, "fields_mask")
	if err := JsonReadUint32(_jFieldsMask, &item.FieldsMask); err != nil {
		return err
	}
	_jMetric := _jm["metric"]
	delete(_jm, "metric")
	if err := JsonReadInt32(_jMetric, &item.Metric); err != nil {
		return err
	}
	_jKeys := _jm["keys"]
	delete(_jm, "keys")
	_jCounter := _jm["counter"]
	delete(_jm, "counter")
	if err := JsonReadFloat64(_jCounter, &item.Counter); err != nil {
		return err
	}
	_jT := _jm["t"]
	delete(_jm, "t")
	_jValueMin := _jm["value_min"]
	delete(_jm, "value_min")
	_jValueMax := _jm["value_max"]
	delete(_jm, "value_max")
	_jValueSum := _jm["value_sum"]
	delete(_jm, "value_sum")
	_jValueSumSquare := _jm["value_sum_square"]
	delete(_jm, "value_sum_square")
	_jPercentiles := _jm["percentiles"]
	delete(_jm, "percentiles")
	_jUniques := _jm["uniques"]
	delete(_jm, "uniques")
	_jStringTops := _jm["string_tops"]
	delete(_jm, "string_tops")
	_jCentroids := _jm["centroids"]
	delete(_jm, "centroids")
	for k := range _jm {
		return ErrorInvalidJSONExcessElement("statshouse.item", k)
	}
	if _jT != nil {
		item.FieldsMask |= 1 << 0
	}
	if _jValueMin != nil {
		item.FieldsMask |= 1 << 1
	}
	if _jValueMax != nil {
		item.FieldsMask |= 1 << 2
	}
	if _jValueSum != nil {
		item.FieldsMask |= 1 << 2
	}
	if _jValueSumSquare != nil {
		item.FieldsMask |= 1 << 2
	}
	if _jPercentiles != nil {
		item.FieldsMask |= 1 << 3
	}
	if _jUniques != nil {
		item.FieldsMask |= 1 << 4
	}
	if _jStringTops != nil {
		item.FieldsMask |= 1 << 5
	}
	if _jCentroids != nil {
		item.FieldsMask |= 1 << 6
	}
	if err := VectorInt0ReadJSON(_jKeys, &item.Keys); err != nil {
		return err
	}
	if _jT != nil {
		if err := JsonReadUint32(_jT, &item.T); err != nil {
			return err
		}
	} else {
		item.T = 0
	}
	if _jValueMin != nil {
		if err := JsonReadFloat64(_jValueMin, &item.ValueMin); err != nil {
			return err
		}
	} else {
		item.ValueMin = 0
	}
	if _jValueMax != nil {
		if err := JsonReadFloat64(_jValueMax, &item.ValueMax); err != nil {
			return err
		}
	} else {
		item.ValueMax = 0
	}
	if _jValueSum != nil {
		if err := JsonReadFloat64(_jValueSum, &item.ValueSum); err != nil {
			return err
		}
	} else {
		item.ValueSum = 0
	}
	if _jValueSumSquare != nil {
		if err := JsonReadFloat64(_jValueSumSquare, &item.ValueSumSquare); err != nil {
			return err
		}
	} else {
		item.ValueSumSquare = 0
	}
	if _jPercentiles != nil {
		if err := VectorFloat0ReadJSON(_jPercentiles, &item.Percentiles); err != nil {
			return err
		}
	} else {
		item.Percentiles = item.Percentiles[:0]
	}
	if _jUniques != nil {
		if err := VectorLong0ReadJSON(_jUniques, &item.Uniques); err != nil {
			return err
		}
	} else {
		item.Uniques = item.Uniques[:0]
	}
	if _jStringTops != nil {
		if err := VectorStatshouseStringTopElement0BytesReadJSON(_jStringTops, &item.StringTops); err != nil {
			return err
		}
	} else {
		item.StringTops = item.StringTops[:0]
	}
	if _jCentroids != nil {
		if err := VectorStatshouseCentroid0ReadJSON(_jCentroids, &item.Centroids); err != nil {
			return err
		}
	} else {
		item.Centroids = item.Centroids[:0]
	}
	return nil
}

func (item *StatshouseItemBytes) WriteJSON(w []byte) (_ []byte, err error) {
	w = append(w, '{')
	if item.FieldsMask != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"fields_mask":`...)
		w = basictl.JSONWriteUint32(w, item.FieldsMask)
	}
	if item.Metric != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"metric":`...)
		w = basictl.JSONWriteInt32(w, item.Metric)
	}
	if len(item.Keys) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"keys":`...)
		if w, err = VectorInt0WriteJSON(w, item.Keys); err != nil {
			return w, err
		}
	}
	if item.Counter != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"counter":`...)
		w = basictl.JSONWriteFloat64(w, item.Counter)
	}
	if item.FieldsMask&(1<<0) != 0 {
		if item.T != 0 {
			w = basictl.JSONAddCommaIfNeeded(w)
			w = append(w, `"t":`...)
			w = basictl.JSONWriteUint32(w, item.T)
		}
	}
	if item.FieldsMask&(1<<1) != 0 {
		if item.ValueMin != 0 {
			w = basictl.JSONAddCommaIfNeeded(w)
			w = append(w, `"value_min":`...)
			w = basictl.JSONWriteFloat64(w, item.ValueMin)
		}
	}
	if item.FieldsMask&(1<<2) != 0 {
		if item.ValueMax != 0 {
			w = basictl.JSONAddCommaIfNeeded(w)
			w = append(w, `"value_max":`...)
			w = basictl.JSONWriteFloat64(w, item.ValueMax)
		}
	}
	if item.FieldsMask&(1<<2) != 0 {
		if item.ValueSum != 0 {
			w = basictl.JSONAddCommaIfNeeded(w)
			w = append(w, `"value_sum":`...)
			w = basictl.JSONWriteFloat64(w, item.ValueSum)
		}
	}
	if item.FieldsMask&(1<<2) != 0 {
		if item.ValueSumSquare != 0 {
			w = basictl.JSONAddCommaIfNeeded(w)
			w = append(w, `"value_sum_square":`...)
			w = basictl.JSONWriteFloat64(w, item.ValueSumSquare)
		}
	}
	if item.FieldsMask&(1<<3) != 0 {
		if len(item.Percentiles) != 0 {
			w = basictl.JSONAddCommaIfNeeded(w)
			w = append(w, `"percentiles":`...)
			if w, err = VectorFloat0WriteJSON(w, item.Percentiles); err != nil {
				return w, err
			}
		}
	}
	if item.FieldsMask&(1<<4) != 0 {
		if len(item.Uniques) != 0 {
			w = basictl.JSONAddCommaIfNeeded(w)
			w = append(w, `"uniques":`...)
			if w, err = VectorLong0WriteJSON(w, item.Uniques); err != nil {
				return w, err
			}
		}
	}
	if item.FieldsMask&(1<<5) != 0 {
		if len(item.StringTops) != 0 {
			w = basictl.JSONAddCommaIfNeeded(w)
			w = append(w, `"string_tops":`...)
			if w, err = VectorStatshouseStringTopElement0BytesWriteJSON(w, item.StringTops); err != nil {
				return w, err
			}
		}
	}
	if item.FieldsMask&(1<<6) != 0 {
		if len(item.Centroids) != 0 {
			w = basictl.JSONAddCommaIfNeeded(w)
			w = append(w, `"centroids":`...)
			if w, err = VectorStatshouseCentroid0WriteJSON(w, item.Centroids); err != nil {
				return w, err
			}
		}
	}
	return append(w, '}'), nil
}

func (item *StatshouseItemBytes) MarshalJSON() ([]byte, error) {
	return item.WriteJSON(nil)
}

func (item *StatshouseItemBytes) UnmarshalJSON(b []byte) error {
	j, err := JsonBytesToInterface(b)
	if err != nil {
		return ErrorInvalidJSON("statshouse.item", err.Error())
	}
	if err = item.readJSON(j); err != nil {
		return ErrorInvalidJSON("statshouse.item", err.Error())
	}
	return nil
}

func VectorStatshouseItem0Read(w []byte, vec *[]StatshouseItem) (_ []byte, err error) {
	var l uint32
	if w, err = basictl.NatRead(w, &l); err != nil {
		return w, err
	}
	if err = basictl.CheckLengthSanity(w, l, 4); err != nil {
		return w, err
	}
	if uint32(cap(*vec)) < l {
		*vec = make([]StatshouseItem, l)
	} else {
		*vec = (*vec)[:l]
	}
	for i := range *vec {
		if w, err = (*vec)[i].Read(w); err != nil {
			return w, err
		}
	}
	return w, nil
}

func VectorStatshouseItem0Write(w []byte, vec []StatshouseItem) (_ []byte, err error) {
	w = basictl.NatWrite(w, uint32(len(vec)))
	for _, elem := range vec {
		if w, err = elem.Write(w); err != nil {
			return w, err
		}
	}
	return w, nil
}

func VectorStatshouseItem0ReadJSON(j interface{}, vec *[]StatshouseItem) error {
	l, _arr, err := JsonReadArray("[]StatshouseItem", j)
	if err != nil {
		return err
	}
	if cap(*vec) < l {
		*vec = make([]StatshouseItem, l)
	} else {
		*vec = (*vec)[:l]
	}
	for i := range *vec {
		if err := StatshouseItem__ReadJSON(&(*vec)[i], _arr[i]); err != nil {
			return err
		}
	}
	return nil
}

func VectorStatshouseItem0WriteJSON(w []byte, vec []StatshouseItem) (_ []byte, err error) {
	w = append(w, '[')
	for _, elem := range vec {
		w = basictl.JSONAddCommaIfNeeded(w)
		if w, err = elem.WriteJSON(w); err != nil {
			return w, err
		}
	}
	return append(w, ']'), nil
}

func VectorStatshouseItem0BytesRead(w []byte, vec *[]StatshouseItemBytes) (_ []byte, err error) {
	var l uint32
	if w, err = basictl.NatRead(w, &l); err != nil {
		return w, err
	}
	if err = basictl.CheckLengthSanity(w, l, 4); err != nil {
		return w, err
	}
	if uint32(cap(*vec)) < l {
		*vec = make([]StatshouseItemBytes, l)
	} else {
		*vec = (*vec)[:l]
	}
	for i := range *vec {
		if w, err = (*vec)[i].Read(w); err != nil {
			return w, err
		}
	}
	return w, nil
}

func VectorStatshouseItem0BytesWrite(w []byte, vec []StatshouseItemBytes) (_ []byte, err error) {
	w = basictl.NatWrite(w, uint32(len(vec)))
	for _, elem := range vec {
		if w, err = elem.Write(w); err != nil {
			return w, err
		}
	}
	return w, nil
}

func VectorStatshouseItem0BytesReadJSON(j interface{}, vec *[]StatshouseItemBytes) error {
	l, _arr, err := JsonReadArray("[]StatshouseItemBytes", j)
	if err != nil {
		return err
	}
	if cap(*vec) < l {
		*vec = make([]StatshouseItemBytes, l)
	} else {
		*vec = (*vec)[:l]
	}
	for i := range *vec {
		if err := StatshouseItemBytes__ReadJSON(&(*vec)[i], _arr[i]); err != nil {
			return err
		}
	}
	return nil
}

func VectorStatshouseItem0BytesWriteJSON(w []byte, vec []StatshouseItemBytes) (_ []byte, err error) {
	w = append(w, '[')
	for _, elem := range vec {
		w = basictl.JSONAddCommaIfNeeded(w)
		if w, err = elem.WriteJSON(w); err != nil {
			return w, err
		}
	}
	return append(w, ']'), nil
}
