// Copyright 2023 V Kontakte LLC
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

// Code generated by vktl/cmd/tlgen2; DO NOT EDIT.
package internal

import (
	"github.com/vkcom/statshouse/internal/vkgo/basictl"
)

var _ = basictl.NatWrite

type StatshouseApiQuery struct {
	FieldsMask uint32
	Version    int32
	TopN       int32
	MetricName string
	TimeFrom   int64
	TimeTo     int64
	Interval   string
	Function   StatshouseApiFunction
	GroupBy    []string
	Filter     []StatshouseApiFilter
	TimeShift  []int64
	Promql     string                  // Conditional: item.FieldsMask.0
	What       []StatshouseApiFunction // Conditional: item.FieldsMask.1
	// ExcessPointsFlag (TrueType) // Conditional: item.FieldsMask.2
	WidthAgg string // Conditional: item.FieldsMask.3
	// NameFlag (TrueType) // Conditional: item.FieldsMask.4
	// ColorFlag (TrueType) // Conditional: item.FieldsMask.5
	// TotalFlag (TrueType) // Conditional: item.FieldsMask.6
	// MaxHostFlag (TrueType) // Conditional: item.FieldsMask.7
}

func (StatshouseApiQuery) TLName() string { return "statshouseApi.query" }
func (StatshouseApiQuery) TLTag() uint32  { return 0xc9951bb9 }

func (item *StatshouseApiQuery) SetPromql(v string) {
	item.Promql = v
	item.FieldsMask |= 1 << 0
}
func (item *StatshouseApiQuery) ClearPromql() {
	item.Promql = ""
	item.FieldsMask &^= 1 << 0
}
func (item StatshouseApiQuery) IsSetPromql() bool { return item.FieldsMask&(1<<0) != 0 }

func (item *StatshouseApiQuery) SetWhat(v []StatshouseApiFunction) {
	item.What = v
	item.FieldsMask |= 1 << 1
}
func (item *StatshouseApiQuery) ClearWhat() {
	item.What = item.What[:0]
	item.FieldsMask &^= 1 << 1
}
func (item StatshouseApiQuery) IsSetWhat() bool { return item.FieldsMask&(1<<1) != 0 }

func (item *StatshouseApiQuery) SetExcessPointsFlag(v bool) {
	if v {
		item.FieldsMask |= 1 << 2
	} else {
		item.FieldsMask &^= 1 << 2
	}
}
func (item StatshouseApiQuery) IsSetExcessPointsFlag() bool { return item.FieldsMask&(1<<2) != 0 }

func (item *StatshouseApiQuery) SetWidthAgg(v string) {
	item.WidthAgg = v
	item.FieldsMask |= 1 << 3
}
func (item *StatshouseApiQuery) ClearWidthAgg() {
	item.WidthAgg = ""
	item.FieldsMask &^= 1 << 3
}
func (item StatshouseApiQuery) IsSetWidthAgg() bool { return item.FieldsMask&(1<<3) != 0 }

func (item *StatshouseApiQuery) SetNameFlag(v bool) {
	if v {
		item.FieldsMask |= 1 << 4
	} else {
		item.FieldsMask &^= 1 << 4
	}
}
func (item StatshouseApiQuery) IsSetNameFlag() bool { return item.FieldsMask&(1<<4) != 0 }

func (item *StatshouseApiQuery) SetColorFlag(v bool) {
	if v {
		item.FieldsMask |= 1 << 5
	} else {
		item.FieldsMask &^= 1 << 5
	}
}
func (item StatshouseApiQuery) IsSetColorFlag() bool { return item.FieldsMask&(1<<5) != 0 }

func (item *StatshouseApiQuery) SetTotalFlag(v bool) {
	if v {
		item.FieldsMask |= 1 << 6
	} else {
		item.FieldsMask &^= 1 << 6
	}
}
func (item StatshouseApiQuery) IsSetTotalFlag() bool { return item.FieldsMask&(1<<6) != 0 }

func (item *StatshouseApiQuery) SetMaxHostFlag(v bool) {
	if v {
		item.FieldsMask |= 1 << 7
	} else {
		item.FieldsMask &^= 1 << 7
	}
}
func (item StatshouseApiQuery) IsSetMaxHostFlag() bool { return item.FieldsMask&(1<<7) != 0 }

func (item *StatshouseApiQuery) Reset() {
	item.FieldsMask = 0
	item.Version = 0
	item.TopN = 0
	item.MetricName = ""
	item.TimeFrom = 0
	item.TimeTo = 0
	item.Interval = ""
	item.Function.Reset()
	item.GroupBy = item.GroupBy[:0]
	item.Filter = item.Filter[:0]
	item.TimeShift = item.TimeShift[:0]
	item.Promql = ""
	item.What = item.What[:0]
	item.WidthAgg = ""
}

func (item *StatshouseApiQuery) Read(w []byte) (_ []byte, err error) {
	if w, err = basictl.NatRead(w, &item.FieldsMask); err != nil {
		return w, err
	}
	if w, err = basictl.IntRead(w, &item.Version); err != nil {
		return w, err
	}
	if w, err = basictl.IntRead(w, &item.TopN); err != nil {
		return w, err
	}
	if w, err = basictl.StringRead(w, &item.MetricName); err != nil {
		return w, err
	}
	if w, err = basictl.LongRead(w, &item.TimeFrom); err != nil {
		return w, err
	}
	if w, err = basictl.LongRead(w, &item.TimeTo); err != nil {
		return w, err
	}
	if w, err = basictl.StringRead(w, &item.Interval); err != nil {
		return w, err
	}
	if w, err = item.Function.ReadBoxed(w); err != nil {
		return w, err
	}
	if w, err = BuiltinVectorStringRead(w, &item.GroupBy); err != nil {
		return w, err
	}
	if w, err = BuiltinVectorStatshouseApiFilterRead(w, &item.Filter); err != nil {
		return w, err
	}
	if w, err = BuiltinVectorLongRead(w, &item.TimeShift); err != nil {
		return w, err
	}
	if item.FieldsMask&(1<<0) != 0 {
		if w, err = basictl.StringRead(w, &item.Promql); err != nil {
			return w, err
		}
	} else {
		item.Promql = ""
	}
	if item.FieldsMask&(1<<1) != 0 {
		if w, err = BuiltinVectorStatshouseApiFunctionRead(w, &item.What); err != nil {
			return w, err
		}
	} else {
		item.What = item.What[:0]
	}
	if item.FieldsMask&(1<<3) != 0 {
		if w, err = basictl.StringRead(w, &item.WidthAgg); err != nil {
			return w, err
		}
	} else {
		item.WidthAgg = ""
	}
	return w, nil
}

// This method is general version of Write, use it instead!
func (item *StatshouseApiQuery) WriteGeneral(w []byte) (_ []byte, err error) {
	return item.Write(w), nil
}

func (item *StatshouseApiQuery) Write(w []byte) []byte {
	w = basictl.NatWrite(w, item.FieldsMask)
	w = basictl.IntWrite(w, item.Version)
	w = basictl.IntWrite(w, item.TopN)
	w = basictl.StringWrite(w, item.MetricName)
	w = basictl.LongWrite(w, item.TimeFrom)
	w = basictl.LongWrite(w, item.TimeTo)
	w = basictl.StringWrite(w, item.Interval)
	w = item.Function.WriteBoxed(w)
	w = BuiltinVectorStringWrite(w, item.GroupBy)
	w = BuiltinVectorStatshouseApiFilterWrite(w, item.Filter)
	w = BuiltinVectorLongWrite(w, item.TimeShift)
	if item.FieldsMask&(1<<0) != 0 {
		w = basictl.StringWrite(w, item.Promql)
	}
	if item.FieldsMask&(1<<1) != 0 {
		w = BuiltinVectorStatshouseApiFunctionWrite(w, item.What)
	}
	if item.FieldsMask&(1<<3) != 0 {
		w = basictl.StringWrite(w, item.WidthAgg)
	}
	return w
}

func (item *StatshouseApiQuery) ReadBoxed(w []byte) (_ []byte, err error) {
	if w, err = basictl.NatReadExactTag(w, 0xc9951bb9); err != nil {
		return w, err
	}
	return item.Read(w)
}

// This method is general version of WriteBoxed, use it instead!
func (item *StatshouseApiQuery) WriteBoxedGeneral(w []byte) (_ []byte, err error) {
	return item.WriteBoxed(w), nil
}

func (item *StatshouseApiQuery) WriteBoxed(w []byte) []byte {
	w = basictl.NatWrite(w, 0xc9951bb9)
	return item.Write(w)
}

func (item StatshouseApiQuery) String() string {
	return string(item.WriteJSON(nil))
}

func (item *StatshouseApiQuery) ReadJSON(legacyTypeNames bool, in *basictl.JsonLexer) error {
	var propFieldsMaskPresented bool
	var propVersionPresented bool
	var propTopNPresented bool
	var propMetricNamePresented bool
	var propTimeFromPresented bool
	var propTimeToPresented bool
	var propIntervalPresented bool
	var propFunctionPresented bool
	var propGroupByPresented bool
	var propFilterPresented bool
	var propTimeShiftPresented bool
	var propPromqlPresented bool
	var propWhatPresented bool
	var trueTypeExcessPointsFlagPresented bool
	var trueTypeExcessPointsFlagValue bool
	var propWidthAggPresented bool
	var trueTypeNameFlagPresented bool
	var trueTypeNameFlagValue bool
	var trueTypeColorFlagPresented bool
	var trueTypeColorFlagValue bool
	var trueTypeTotalFlagPresented bool
	var trueTypeTotalFlagValue bool
	var trueTypeMaxHostFlagPresented bool
	var trueTypeMaxHostFlagValue bool

	if in != nil {
		in.Delim('{')
		if !in.Ok() {
			return in.Error()
		}
		for !in.IsDelim('}') {
			key := in.UnsafeFieldName(true)
			in.WantColon()
			switch key {
			case "fields_mask":
				if propFieldsMaskPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouseApi.query", "fields_mask")
				}
				if err := Json2ReadUint32(in, &item.FieldsMask); err != nil {
					return err
				}
				propFieldsMaskPresented = true
			case "version":
				if propVersionPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouseApi.query", "version")
				}
				if err := Json2ReadInt32(in, &item.Version); err != nil {
					return err
				}
				propVersionPresented = true
			case "top_n":
				if propTopNPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouseApi.query", "top_n")
				}
				if err := Json2ReadInt32(in, &item.TopN); err != nil {
					return err
				}
				propTopNPresented = true
			case "metric_name":
				if propMetricNamePresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouseApi.query", "metric_name")
				}
				if err := Json2ReadString(in, &item.MetricName); err != nil {
					return err
				}
				propMetricNamePresented = true
			case "time_from":
				if propTimeFromPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouseApi.query", "time_from")
				}
				if err := Json2ReadInt64(in, &item.TimeFrom); err != nil {
					return err
				}
				propTimeFromPresented = true
			case "time_to":
				if propTimeToPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouseApi.query", "time_to")
				}
				if err := Json2ReadInt64(in, &item.TimeTo); err != nil {
					return err
				}
				propTimeToPresented = true
			case "interval":
				if propIntervalPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouseApi.query", "interval")
				}
				if err := Json2ReadString(in, &item.Interval); err != nil {
					return err
				}
				propIntervalPresented = true
			case "function":
				if propFunctionPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouseApi.query", "function")
				}
				if err := item.Function.ReadJSON(legacyTypeNames, in); err != nil {
					return err
				}
				propFunctionPresented = true
			case "group_by":
				if propGroupByPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouseApi.query", "group_by")
				}
				if err := BuiltinVectorStringReadJSON(legacyTypeNames, in, &item.GroupBy); err != nil {
					return err
				}
				propGroupByPresented = true
			case "filter":
				if propFilterPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouseApi.query", "filter")
				}
				if err := BuiltinVectorStatshouseApiFilterReadJSON(legacyTypeNames, in, &item.Filter); err != nil {
					return err
				}
				propFilterPresented = true
			case "time_shift":
				if propTimeShiftPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouseApi.query", "time_shift")
				}
				if err := BuiltinVectorLongReadJSON(legacyTypeNames, in, &item.TimeShift); err != nil {
					return err
				}
				propTimeShiftPresented = true
			case "promql":
				if propPromqlPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouseApi.query", "promql")
				}
				if err := Json2ReadString(in, &item.Promql); err != nil {
					return err
				}
				propPromqlPresented = true
			case "what":
				if propWhatPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouseApi.query", "what")
				}
				if err := BuiltinVectorStatshouseApiFunctionReadJSON(legacyTypeNames, in, &item.What); err != nil {
					return err
				}
				propWhatPresented = true
			case "excess_points_flag":
				if trueTypeExcessPointsFlagPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouseApi.query", "excess_points_flag")
				}
				if err := Json2ReadBool(in, &trueTypeExcessPointsFlagValue); err != nil {
					return err
				}
				trueTypeExcessPointsFlagPresented = true
			case "widthAgg":
				if propWidthAggPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouseApi.query", "widthAgg")
				}
				if err := Json2ReadString(in, &item.WidthAgg); err != nil {
					return err
				}
				propWidthAggPresented = true
			case "name_flag":
				if trueTypeNameFlagPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouseApi.query", "name_flag")
				}
				if err := Json2ReadBool(in, &trueTypeNameFlagValue); err != nil {
					return err
				}
				trueTypeNameFlagPresented = true
			case "color_flag":
				if trueTypeColorFlagPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouseApi.query", "color_flag")
				}
				if err := Json2ReadBool(in, &trueTypeColorFlagValue); err != nil {
					return err
				}
				trueTypeColorFlagPresented = true
			case "total_flag":
				if trueTypeTotalFlagPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouseApi.query", "total_flag")
				}
				if err := Json2ReadBool(in, &trueTypeTotalFlagValue); err != nil {
					return err
				}
				trueTypeTotalFlagPresented = true
			case "max_host_flag":
				if trueTypeMaxHostFlagPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouseApi.query", "max_host_flag")
				}
				if err := Json2ReadBool(in, &trueTypeMaxHostFlagValue); err != nil {
					return err
				}
				trueTypeMaxHostFlagPresented = true
			default:
				return ErrorInvalidJSONExcessElement("statshouseApi.query", key)
			}
			in.WantComma()
		}
		in.Delim('}')
		if !in.Ok() {
			return in.Error()
		}
	}
	if !propFieldsMaskPresented {
		item.FieldsMask = 0
	}
	if !propVersionPresented {
		item.Version = 0
	}
	if !propTopNPresented {
		item.TopN = 0
	}
	if !propMetricNamePresented {
		item.MetricName = ""
	}
	if !propTimeFromPresented {
		item.TimeFrom = 0
	}
	if !propTimeToPresented {
		item.TimeTo = 0
	}
	if !propIntervalPresented {
		item.Interval = ""
	}
	if !propFunctionPresented {
		item.Function.Reset()
	}
	if !propGroupByPresented {
		item.GroupBy = item.GroupBy[:0]
	}
	if !propFilterPresented {
		item.Filter = item.Filter[:0]
	}
	if !propTimeShiftPresented {
		item.TimeShift = item.TimeShift[:0]
	}
	if !propPromqlPresented {
		item.Promql = ""
	}
	if !propWhatPresented {
		item.What = item.What[:0]
	}
	if !propWidthAggPresented {
		item.WidthAgg = ""
	}
	if propPromqlPresented {
		item.FieldsMask |= 1 << 0
	}
	if propWhatPresented {
		item.FieldsMask |= 1 << 1
	}
	if trueTypeExcessPointsFlagPresented {
		if trueTypeExcessPointsFlagValue {
			item.FieldsMask |= 1 << 2
		}
	}
	if propWidthAggPresented {
		item.FieldsMask |= 1 << 3
	}
	if trueTypeNameFlagPresented {
		if trueTypeNameFlagValue {
			item.FieldsMask |= 1 << 4
		}
	}
	if trueTypeColorFlagPresented {
		if trueTypeColorFlagValue {
			item.FieldsMask |= 1 << 5
		}
	}
	if trueTypeTotalFlagPresented {
		if trueTypeTotalFlagValue {
			item.FieldsMask |= 1 << 6
		}
	}
	if trueTypeMaxHostFlagPresented {
		if trueTypeMaxHostFlagValue {
			item.FieldsMask |= 1 << 7
		}
	}
	// tries to set bit to zero if it is 1
	if trueTypeExcessPointsFlagPresented && !trueTypeExcessPointsFlagValue && (item.FieldsMask&(1<<2) != 0) {
		return ErrorInvalidJSON("statshouseApi.query", "fieldmask bit fields_mask.0 is indefinite because of the contradictions in values")
	}
	// tries to set bit to zero if it is 1
	if trueTypeNameFlagPresented && !trueTypeNameFlagValue && (item.FieldsMask&(1<<4) != 0) {
		return ErrorInvalidJSON("statshouseApi.query", "fieldmask bit fields_mask.0 is indefinite because of the contradictions in values")
	}
	// tries to set bit to zero if it is 1
	if trueTypeColorFlagPresented && !trueTypeColorFlagValue && (item.FieldsMask&(1<<5) != 0) {
		return ErrorInvalidJSON("statshouseApi.query", "fieldmask bit fields_mask.0 is indefinite because of the contradictions in values")
	}
	// tries to set bit to zero if it is 1
	if trueTypeTotalFlagPresented && !trueTypeTotalFlagValue && (item.FieldsMask&(1<<6) != 0) {
		return ErrorInvalidJSON("statshouseApi.query", "fieldmask bit fields_mask.0 is indefinite because of the contradictions in values")
	}
	// tries to set bit to zero if it is 1
	if trueTypeMaxHostFlagPresented && !trueTypeMaxHostFlagValue && (item.FieldsMask&(1<<7) != 0) {
		return ErrorInvalidJSON("statshouseApi.query", "fieldmask bit fields_mask.0 is indefinite because of the contradictions in values")
	}
	return nil
}

// This method is general version of WriteJSON, use it instead!
func (item *StatshouseApiQuery) WriteJSONGeneral(w []byte) (_ []byte, err error) {
	return item.WriteJSONOpt(true, false, w), nil
}

func (item *StatshouseApiQuery) WriteJSON(w []byte) []byte {
	return item.WriteJSONOpt(true, false, w)
}
func (item *StatshouseApiQuery) WriteJSONOpt(newTypeNames bool, short bool, w []byte) []byte {
	w = append(w, '{')
	backupIndexFieldsMask := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"fields_mask":`...)
	w = basictl.JSONWriteUint32(w, item.FieldsMask)
	if (item.FieldsMask != 0) == false {
		w = w[:backupIndexFieldsMask]
	}
	backupIndexVersion := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"version":`...)
	w = basictl.JSONWriteInt32(w, item.Version)
	if (item.Version != 0) == false {
		w = w[:backupIndexVersion]
	}
	backupIndexTopN := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"top_n":`...)
	w = basictl.JSONWriteInt32(w, item.TopN)
	if (item.TopN != 0) == false {
		w = w[:backupIndexTopN]
	}
	backupIndexMetricName := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"metric_name":`...)
	w = basictl.JSONWriteString(w, item.MetricName)
	if (len(item.MetricName) != 0) == false {
		w = w[:backupIndexMetricName]
	}
	backupIndexTimeFrom := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"time_from":`...)
	w = basictl.JSONWriteInt64(w, item.TimeFrom)
	if (item.TimeFrom != 0) == false {
		w = w[:backupIndexTimeFrom]
	}
	backupIndexTimeTo := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"time_to":`...)
	w = basictl.JSONWriteInt64(w, item.TimeTo)
	if (item.TimeTo != 0) == false {
		w = w[:backupIndexTimeTo]
	}
	backupIndexInterval := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"interval":`...)
	w = basictl.JSONWriteString(w, item.Interval)
	if (len(item.Interval) != 0) == false {
		w = w[:backupIndexInterval]
	}
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"function":`...)
	w = item.Function.WriteJSONOpt(newTypeNames, short, w)
	backupIndexGroupBy := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"group_by":`...)
	w = BuiltinVectorStringWriteJSONOpt(newTypeNames, short, w, item.GroupBy)
	if (len(item.GroupBy) != 0) == false {
		w = w[:backupIndexGroupBy]
	}
	backupIndexFilter := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"filter":`...)
	w = BuiltinVectorStatshouseApiFilterWriteJSONOpt(newTypeNames, short, w, item.Filter)
	if (len(item.Filter) != 0) == false {
		w = w[:backupIndexFilter]
	}
	backupIndexTimeShift := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"time_shift":`...)
	w = BuiltinVectorLongWriteJSONOpt(newTypeNames, short, w, item.TimeShift)
	if (len(item.TimeShift) != 0) == false {
		w = w[:backupIndexTimeShift]
	}
	if item.FieldsMask&(1<<0) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"promql":`...)
		w = basictl.JSONWriteString(w, item.Promql)
	}
	if item.FieldsMask&(1<<1) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"what":`...)
		w = BuiltinVectorStatshouseApiFunctionWriteJSONOpt(newTypeNames, short, w, item.What)
	}
	if item.FieldsMask&(1<<2) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"excess_points_flag":true`...)
	}
	if item.FieldsMask&(1<<3) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"widthAgg":`...)
		w = basictl.JSONWriteString(w, item.WidthAgg)
	}
	if item.FieldsMask&(1<<4) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"name_flag":true`...)
	}
	if item.FieldsMask&(1<<5) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"color_flag":true`...)
	}
	if item.FieldsMask&(1<<6) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"total_flag":true`...)
	}
	if item.FieldsMask&(1<<7) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"max_host_flag":true`...)
	}
	return append(w, '}')
}

func (item *StatshouseApiQuery) MarshalJSON() ([]byte, error) {
	return item.WriteJSON(nil), nil
}

func (item *StatshouseApiQuery) UnmarshalJSON(b []byte) error {
	if err := item.ReadJSON(true, &basictl.JsonLexer{Data: b}); err != nil {
		return ErrorInvalidJSON("statshouseApi.query", err.Error())
	}
	return nil
}
