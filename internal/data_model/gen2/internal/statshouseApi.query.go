// Copyright 2025 V Kontakte LLC
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

// Code generated by vktl/cmd/tlgen2; DO NOT EDIT.
package internal

import (
	"github.com/VKCOM/statshouse/internal/vkgo/basictl"
)

var _ = basictl.NatWrite

type StatshouseApiQuery struct {
	FieldsMask uint32
	Version    int32
	TopN       int32
	MetricName string
	TimeFrom   int64
	TimeTo     int64
	Interval   string
	Function   StatshouseApiFunction
	GroupBy    []string
	Filter     []StatshouseApiFilter
	TimeShift  []int64
	Promql     string                  // Conditional: item.FieldsMask.0
	What       []StatshouseApiFunction // Conditional: item.FieldsMask.1
	// ExcessPointsFlag (TrueType) // Conditional: item.FieldsMask.2
	WidthAgg string // Conditional: item.FieldsMask.3
	// NameFlag (TrueType) // Conditional: item.FieldsMask.4
	// ColorFlag (TrueType) // Conditional: item.FieldsMask.5
	// TotalFlag (TrueType) // Conditional: item.FieldsMask.6
	// MaxHostFlag (TrueType) // Conditional: item.FieldsMask.7
	tl2mask0 byte
}

func (StatshouseApiQuery) TLName() string { return "statshouseApi.query" }
func (StatshouseApiQuery) TLTag() uint32  { return 0xc9951bb9 }

func (item *StatshouseApiQuery) SetPromql(v string) {
	item.Promql = v
	item.FieldsMask |= 1 << 0
	item.tl2mask0 |= 1
}
func (item *StatshouseApiQuery) ClearPromql() {
	item.Promql = ""
	item.FieldsMask &^= 1 << 0
	item.tl2mask0 &^= 1
}
func (item *StatshouseApiQuery) IsSetPromql() bool { return item.tl2mask0&1 != 0 }

func (item *StatshouseApiQuery) SetWhat(v []StatshouseApiFunction) {
	item.What = v
	item.FieldsMask |= 1 << 1
	item.tl2mask0 |= 2
}
func (item *StatshouseApiQuery) ClearWhat() {
	item.What = item.What[:0]
	item.FieldsMask &^= 1 << 1
	item.tl2mask0 &^= 2
}
func (item *StatshouseApiQuery) IsSetWhat() bool { return item.tl2mask0&2 != 0 }

func (item *StatshouseApiQuery) SetExcessPointsFlag(v bool) {
	if v {
		item.FieldsMask |= 1 << 2
	} else {
		item.FieldsMask &^= 1 << 2
	}
	if v {
		item.tl2mask0 |= 4
	} else {
		item.tl2mask0 &^= 4
	}
}
func (item *StatshouseApiQuery) IsSetExcessPointsFlag() bool { return item.tl2mask0&4 != 0 }

func (item *StatshouseApiQuery) SetWidthAgg(v string) {
	item.WidthAgg = v
	item.FieldsMask |= 1 << 3
	item.tl2mask0 |= 8
}
func (item *StatshouseApiQuery) ClearWidthAgg() {
	item.WidthAgg = ""
	item.FieldsMask &^= 1 << 3
	item.tl2mask0 &^= 8
}
func (item *StatshouseApiQuery) IsSetWidthAgg() bool { return item.tl2mask0&8 != 0 }

func (item *StatshouseApiQuery) SetNameFlag(v bool) {
	if v {
		item.FieldsMask |= 1 << 4
	} else {
		item.FieldsMask &^= 1 << 4
	}
	if v {
		item.tl2mask0 |= 16
	} else {
		item.tl2mask0 &^= 16
	}
}
func (item *StatshouseApiQuery) IsSetNameFlag() bool { return item.tl2mask0&16 != 0 }

func (item *StatshouseApiQuery) SetColorFlag(v bool) {
	if v {
		item.FieldsMask |= 1 << 5
	} else {
		item.FieldsMask &^= 1 << 5
	}
	if v {
		item.tl2mask0 |= 32
	} else {
		item.tl2mask0 &^= 32
	}
}
func (item *StatshouseApiQuery) IsSetColorFlag() bool { return item.tl2mask0&32 != 0 }

func (item *StatshouseApiQuery) SetTotalFlag(v bool) {
	if v {
		item.FieldsMask |= 1 << 6
	} else {
		item.FieldsMask &^= 1 << 6
	}
	if v {
		item.tl2mask0 |= 64
	} else {
		item.tl2mask0 &^= 64
	}
}
func (item *StatshouseApiQuery) IsSetTotalFlag() bool { return item.tl2mask0&64 != 0 }

func (item *StatshouseApiQuery) SetMaxHostFlag(v bool) {
	if v {
		item.FieldsMask |= 1 << 7
	} else {
		item.FieldsMask &^= 1 << 7
	}
	if v {
		item.tl2mask0 |= 128
	} else {
		item.tl2mask0 &^= 128
	}
}
func (item *StatshouseApiQuery) IsSetMaxHostFlag() bool { return item.tl2mask0&128 != 0 }

func (item *StatshouseApiQuery) Reset() {
	item.FieldsMask = 0
	item.Version = 0
	item.TopN = 0
	item.MetricName = ""
	item.TimeFrom = 0
	item.TimeTo = 0
	item.Interval = ""
	item.Function.Reset()
	item.GroupBy = item.GroupBy[:0]
	item.Filter = item.Filter[:0]
	item.TimeShift = item.TimeShift[:0]
	item.Promql = ""
	item.What = item.What[:0]
	item.WidthAgg = ""
	item.tl2mask0 = 0
}

func (item *StatshouseApiQuery) FillRandom(rg *basictl.RandGenerator) {
	item.tl2mask0 = 0
	item.FieldsMask = basictl.RandomFieldMask(rg, 0b11111111)
	item.Version = basictl.RandomInt(rg)
	item.TopN = basictl.RandomInt(rg)
	item.MetricName = basictl.RandomString(rg)
	item.TimeFrom = basictl.RandomLong(rg)
	item.TimeTo = basictl.RandomLong(rg)
	item.Interval = basictl.RandomString(rg)
	item.Function.FillRandom(rg)
	BuiltinVectorStringFillRandom(rg, &item.GroupBy)
	BuiltinVectorStatshouseApiFilterFillRandom(rg, &item.Filter)
	BuiltinVectorLongFillRandom(rg, &item.TimeShift)
	if item.FieldsMask&(1<<0) != 0 {
		item.tl2mask0 |= 1
		item.Promql = basictl.RandomString(rg)
	} else {
		item.Promql = ""
	}
	if item.FieldsMask&(1<<1) != 0 {
		item.tl2mask0 |= 2
		BuiltinVectorStatshouseApiFunctionFillRandom(rg, &item.What)
	} else {
		item.What = item.What[:0]
	}
	if item.FieldsMask&(1<<2) != 0 {
		item.tl2mask0 |= 4
	}
	if item.FieldsMask&(1<<3) != 0 {
		item.tl2mask0 |= 8
		item.WidthAgg = basictl.RandomString(rg)
	} else {
		item.WidthAgg = ""
	}
	if item.FieldsMask&(1<<4) != 0 {
		item.tl2mask0 |= 16
	}
	if item.FieldsMask&(1<<5) != 0 {
		item.tl2mask0 |= 32
	}
	if item.FieldsMask&(1<<6) != 0 {
		item.tl2mask0 |= 64
	}
	if item.FieldsMask&(1<<7) != 0 {
		item.tl2mask0 |= 128
	}
}

func (item *StatshouseApiQuery) Read(w []byte) (_ []byte, err error) {
	item.tl2mask0 = 0
	if w, err = basictl.NatRead(w, &item.FieldsMask); err != nil {
		return w, err
	}
	if w, err = basictl.IntRead(w, &item.Version); err != nil {
		return w, err
	}
	if w, err = basictl.IntRead(w, &item.TopN); err != nil {
		return w, err
	}
	if w, err = basictl.StringRead(w, &item.MetricName); err != nil {
		return w, err
	}
	if w, err = basictl.LongRead(w, &item.TimeFrom); err != nil {
		return w, err
	}
	if w, err = basictl.LongRead(w, &item.TimeTo); err != nil {
		return w, err
	}
	if w, err = basictl.StringRead(w, &item.Interval); err != nil {
		return w, err
	}
	if w, err = item.Function.ReadBoxed(w); err != nil {
		return w, err
	}
	if w, err = BuiltinVectorStringRead(w, &item.GroupBy); err != nil {
		return w, err
	}
	if w, err = BuiltinVectorStatshouseApiFilterRead(w, &item.Filter); err != nil {
		return w, err
	}
	if w, err = BuiltinVectorLongRead(w, &item.TimeShift); err != nil {
		return w, err
	}
	if item.FieldsMask&(1<<0) != 0 {
		item.tl2mask0 |= 1
		if w, err = basictl.StringRead(w, &item.Promql); err != nil {
			return w, err
		}
	} else {
		item.Promql = ""
	}
	if item.FieldsMask&(1<<1) != 0 {
		item.tl2mask0 |= 2
		if w, err = BuiltinVectorStatshouseApiFunctionRead(w, &item.What); err != nil {
			return w, err
		}
	} else {
		item.What = item.What[:0]
	}
	if item.FieldsMask&(1<<2) != 0 {
		item.tl2mask0 |= 4
	}
	if item.FieldsMask&(1<<3) != 0 {
		item.tl2mask0 |= 8
		if w, err = basictl.StringRead(w, &item.WidthAgg); err != nil {
			return w, err
		}
	} else {
		item.WidthAgg = ""
	}
	if item.FieldsMask&(1<<4) != 0 {
		item.tl2mask0 |= 16
	}
	if item.FieldsMask&(1<<5) != 0 {
		item.tl2mask0 |= 32
	}
	if item.FieldsMask&(1<<6) != 0 {
		item.tl2mask0 |= 64
	}
	if item.FieldsMask&(1<<7) != 0 {
		item.tl2mask0 |= 128
	}
	return w, nil
}

func (item *StatshouseApiQuery) WriteGeneral(w []byte) (_ []byte, err error) {
	return item.Write(w), nil
}

func (item *StatshouseApiQuery) Write(w []byte) []byte {
	w = basictl.NatWrite(w, item.FieldsMask)
	w = basictl.IntWrite(w, item.Version)
	w = basictl.IntWrite(w, item.TopN)
	w = basictl.StringWrite(w, item.MetricName)
	w = basictl.LongWrite(w, item.TimeFrom)
	w = basictl.LongWrite(w, item.TimeTo)
	w = basictl.StringWrite(w, item.Interval)
	w = item.Function.WriteBoxed(w)
	w = BuiltinVectorStringWrite(w, item.GroupBy)
	w = BuiltinVectorStatshouseApiFilterWrite(w, item.Filter)
	w = BuiltinVectorLongWrite(w, item.TimeShift)
	if item.FieldsMask&(1<<0) != 0 {
		w = basictl.StringWrite(w, item.Promql)
	}
	if item.FieldsMask&(1<<1) != 0 {
		w = BuiltinVectorStatshouseApiFunctionWrite(w, item.What)
	}
	if item.FieldsMask&(1<<3) != 0 {
		w = basictl.StringWrite(w, item.WidthAgg)
	}
	return w
}

func (item *StatshouseApiQuery) ReadBoxed(w []byte) (_ []byte, err error) {
	if w, err = basictl.NatReadExactTag(w, 0xc9951bb9); err != nil {
		return w, err
	}
	return item.Read(w)
}

func (item *StatshouseApiQuery) WriteBoxedGeneral(w []byte) (_ []byte, err error) {
	return item.WriteBoxed(w), nil
}

func (item *StatshouseApiQuery) WriteBoxed(w []byte) []byte {
	w = basictl.NatWrite(w, 0xc9951bb9)
	return item.Write(w)
}

func (item StatshouseApiQuery) String() string {
	return string(item.WriteJSON(nil))
}

func (item *StatshouseApiQuery) ReadJSON(legacyTypeNames bool, in *basictl.JsonLexer) error {
	tctx := basictl.JSONReadContext{LegacyTypeNames: legacyTypeNames}
	return item.ReadJSONGeneral(&tctx, in)
}

func (item *StatshouseApiQuery) ReadJSONGeneral(tctx *basictl.JSONReadContext, in *basictl.JsonLexer) error {
	var propFieldsMaskPresented bool
	var propVersionPresented bool
	var propTopNPresented bool
	var propMetricNamePresented bool
	var propTimeFromPresented bool
	var propTimeToPresented bool
	var propIntervalPresented bool
	var propFunctionPresented bool
	var propGroupByPresented bool
	var propFilterPresented bool
	var propTimeShiftPresented bool
	var propPromqlPresented bool
	var propWhatPresented bool
	var trueTypeExcessPointsFlagPresented bool
	var trueTypeExcessPointsFlagValue bool
	var propWidthAggPresented bool
	var trueTypeNameFlagPresented bool
	var trueTypeNameFlagValue bool
	var trueTypeColorFlagPresented bool
	var trueTypeColorFlagValue bool
	var trueTypeTotalFlagPresented bool
	var trueTypeTotalFlagValue bool
	var trueTypeMaxHostFlagPresented bool
	var trueTypeMaxHostFlagValue bool

	if in != nil {
		in.Delim('{')
		if !in.Ok() {
			return in.Error()
		}
		for !in.IsDelim('}') {
			key := in.UnsafeFieldName(true)
			in.WantColon()
			switch key {
			case "fields_mask":
				if propFieldsMaskPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouseApi.query", "fields_mask")
				}
				if err := Json2ReadUint32(in, &item.FieldsMask); err != nil {
					return err
				}
				propFieldsMaskPresented = true
			case "version":
				if propVersionPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouseApi.query", "version")
				}
				if err := Json2ReadInt32(in, &item.Version); err != nil {
					return err
				}
				propVersionPresented = true
			case "top_n":
				if propTopNPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouseApi.query", "top_n")
				}
				if err := Json2ReadInt32(in, &item.TopN); err != nil {
					return err
				}
				propTopNPresented = true
			case "metric_name":
				if propMetricNamePresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouseApi.query", "metric_name")
				}
				if err := Json2ReadString(in, &item.MetricName); err != nil {
					return err
				}
				propMetricNamePresented = true
			case "time_from":
				if propTimeFromPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouseApi.query", "time_from")
				}
				if err := Json2ReadInt64(in, &item.TimeFrom); err != nil {
					return err
				}
				propTimeFromPresented = true
			case "time_to":
				if propTimeToPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouseApi.query", "time_to")
				}
				if err := Json2ReadInt64(in, &item.TimeTo); err != nil {
					return err
				}
				propTimeToPresented = true
			case "interval":
				if propIntervalPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouseApi.query", "interval")
				}
				if err := Json2ReadString(in, &item.Interval); err != nil {
					return err
				}
				propIntervalPresented = true
			case "function":
				if propFunctionPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouseApi.query", "function")
				}
				if err := item.Function.ReadJSONGeneral(tctx, in); err != nil {
					return err
				}
				propFunctionPresented = true
			case "group_by":
				if propGroupByPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouseApi.query", "group_by")
				}
				if err := BuiltinVectorStringReadJSONGeneral(tctx, in, &item.GroupBy); err != nil {
					return err
				}
				propGroupByPresented = true
			case "filter":
				if propFilterPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouseApi.query", "filter")
				}
				if err := BuiltinVectorStatshouseApiFilterReadJSONGeneral(tctx, in, &item.Filter); err != nil {
					return err
				}
				propFilterPresented = true
			case "time_shift":
				if propTimeShiftPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouseApi.query", "time_shift")
				}
				if err := BuiltinVectorLongReadJSONGeneral(tctx, in, &item.TimeShift); err != nil {
					return err
				}
				propTimeShiftPresented = true
			case "promql":
				if propPromqlPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouseApi.query", "promql")
				}
				if err := Json2ReadString(in, &item.Promql); err != nil {
					return err
				}
				propPromqlPresented = true
			case "what":
				if propWhatPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouseApi.query", "what")
				}
				if err := BuiltinVectorStatshouseApiFunctionReadJSONGeneral(tctx, in, &item.What); err != nil {
					return err
				}
				propWhatPresented = true
			case "excess_points_flag":
				if trueTypeExcessPointsFlagPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouseApi.query", "excess_points_flag")
				}
				if err := Json2ReadBool(in, &trueTypeExcessPointsFlagValue); err != nil {
					return err
				}
				trueTypeExcessPointsFlagPresented = true
			case "widthAgg":
				if propWidthAggPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouseApi.query", "widthAgg")
				}
				if err := Json2ReadString(in, &item.WidthAgg); err != nil {
					return err
				}
				propWidthAggPresented = true
			case "name_flag":
				if trueTypeNameFlagPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouseApi.query", "name_flag")
				}
				if err := Json2ReadBool(in, &trueTypeNameFlagValue); err != nil {
					return err
				}
				trueTypeNameFlagPresented = true
			case "color_flag":
				if trueTypeColorFlagPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouseApi.query", "color_flag")
				}
				if err := Json2ReadBool(in, &trueTypeColorFlagValue); err != nil {
					return err
				}
				trueTypeColorFlagPresented = true
			case "total_flag":
				if trueTypeTotalFlagPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouseApi.query", "total_flag")
				}
				if err := Json2ReadBool(in, &trueTypeTotalFlagValue); err != nil {
					return err
				}
				trueTypeTotalFlagPresented = true
			case "max_host_flag":
				if trueTypeMaxHostFlagPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouseApi.query", "max_host_flag")
				}
				if err := Json2ReadBool(in, &trueTypeMaxHostFlagValue); err != nil {
					return err
				}
				trueTypeMaxHostFlagPresented = true
			default:
				return ErrorInvalidJSONExcessElement("statshouseApi.query", key)
			}
			in.WantComma()
		}
		in.Delim('}')
		if !in.Ok() {
			return in.Error()
		}
	}
	if !propFieldsMaskPresented {
		item.FieldsMask = 0
	}
	if !propVersionPresented {
		item.Version = 0
	}
	if !propTopNPresented {
		item.TopN = 0
	}
	if !propMetricNamePresented {
		item.MetricName = ""
	}
	if !propTimeFromPresented {
		item.TimeFrom = 0
	}
	if !propTimeToPresented {
		item.TimeTo = 0
	}
	if !propIntervalPresented {
		item.Interval = ""
	}
	if !propFunctionPresented {
		item.Function.Reset()
	}
	if !propGroupByPresented {
		item.GroupBy = item.GroupBy[:0]
	}
	if !propFilterPresented {
		item.Filter = item.Filter[:0]
	}
	if !propTimeShiftPresented {
		item.TimeShift = item.TimeShift[:0]
	}
	if !propPromqlPresented {
		item.Promql = ""
	}
	if !propWhatPresented {
		item.What = item.What[:0]
	}
	if !propWidthAggPresented {
		item.WidthAgg = ""
	}
	if propPromqlPresented {
		item.FieldsMask |= 1 << 0
	}
	if propWhatPresented {
		item.FieldsMask |= 1 << 1
	}
	if trueTypeExcessPointsFlagPresented {
		if trueTypeExcessPointsFlagValue {
			item.FieldsMask |= 1 << 2
		}
	}
	if propWidthAggPresented {
		item.FieldsMask |= 1 << 3
	}
	if trueTypeNameFlagPresented {
		if trueTypeNameFlagValue {
			item.FieldsMask |= 1 << 4
		}
	}
	if trueTypeColorFlagPresented {
		if trueTypeColorFlagValue {
			item.FieldsMask |= 1 << 5
		}
	}
	if trueTypeTotalFlagPresented {
		if trueTypeTotalFlagValue {
			item.FieldsMask |= 1 << 6
		}
	}
	if trueTypeMaxHostFlagPresented {
		if trueTypeMaxHostFlagValue {
			item.FieldsMask |= 1 << 7
		}
	}
	// tries to set bit to zero if it is 1
	if trueTypeExcessPointsFlagPresented && !trueTypeExcessPointsFlagValue && (item.FieldsMask&(1<<2) != 0) {
		return ErrorInvalidJSON("statshouseApi.query", "fieldmask bit item.FieldsMask.2 is indefinite because of the contradictions in values")
	}
	// tries to set bit to zero if it is 1
	if trueTypeNameFlagPresented && !trueTypeNameFlagValue && (item.FieldsMask&(1<<4) != 0) {
		return ErrorInvalidJSON("statshouseApi.query", "fieldmask bit item.FieldsMask.4 is indefinite because of the contradictions in values")
	}
	// tries to set bit to zero if it is 1
	if trueTypeColorFlagPresented && !trueTypeColorFlagValue && (item.FieldsMask&(1<<5) != 0) {
		return ErrorInvalidJSON("statshouseApi.query", "fieldmask bit item.FieldsMask.5 is indefinite because of the contradictions in values")
	}
	// tries to set bit to zero if it is 1
	if trueTypeTotalFlagPresented && !trueTypeTotalFlagValue && (item.FieldsMask&(1<<6) != 0) {
		return ErrorInvalidJSON("statshouseApi.query", "fieldmask bit item.FieldsMask.6 is indefinite because of the contradictions in values")
	}
	// tries to set bit to zero if it is 1
	if trueTypeMaxHostFlagPresented && !trueTypeMaxHostFlagValue && (item.FieldsMask&(1<<7) != 0) {
		return ErrorInvalidJSON("statshouseApi.query", "fieldmask bit item.FieldsMask.7 is indefinite because of the contradictions in values")
	}
	if item.FieldsMask&(1<<0) != 0 {
		item.tl2mask0 |= 1
	}
	if item.FieldsMask&(1<<1) != 0 {
		item.tl2mask0 |= 2
	}
	if item.FieldsMask&(1<<2) != 0 {
		item.tl2mask0 |= 4
	}
	if item.FieldsMask&(1<<3) != 0 {
		item.tl2mask0 |= 8
	}
	if item.FieldsMask&(1<<4) != 0 {
		item.tl2mask0 |= 16
	}
	if item.FieldsMask&(1<<5) != 0 {
		item.tl2mask0 |= 32
	}
	if item.FieldsMask&(1<<6) != 0 {
		item.tl2mask0 |= 64
	}
	if item.FieldsMask&(1<<7) != 0 {
		item.tl2mask0 |= 128
	}
	return nil
}

// This method is general version of WriteJSON, use it instead!
func (item *StatshouseApiQuery) WriteJSONGeneral(tctx *basictl.JSONWriteContext, w []byte) (_ []byte, err error) {
	return item.WriteJSONOpt(tctx, w), nil
}

func (item *StatshouseApiQuery) WriteJSON(w []byte) []byte {
	tctx := basictl.JSONWriteContext{}
	return item.WriteJSONOpt(&tctx, w)
}
func (item *StatshouseApiQuery) WriteJSONOpt(tctx *basictl.JSONWriteContext, w []byte) []byte {
	w = append(w, '{')
	backupIndexFieldsMask := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"fields_mask":`...)
	w = basictl.JSONWriteUint32(w, item.FieldsMask)
	if (item.FieldsMask != 0) == false {
		w = w[:backupIndexFieldsMask]
	}
	backupIndexVersion := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"version":`...)
	w = basictl.JSONWriteInt32(w, item.Version)
	if (item.Version != 0) == false {
		w = w[:backupIndexVersion]
	}
	backupIndexTopN := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"top_n":`...)
	w = basictl.JSONWriteInt32(w, item.TopN)
	if (item.TopN != 0) == false {
		w = w[:backupIndexTopN]
	}
	backupIndexMetricName := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"metric_name":`...)
	w = basictl.JSONWriteString(w, item.MetricName)
	if (len(item.MetricName) != 0) == false {
		w = w[:backupIndexMetricName]
	}
	backupIndexTimeFrom := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"time_from":`...)
	w = basictl.JSONWriteInt64(w, item.TimeFrom)
	if (item.TimeFrom != 0) == false {
		w = w[:backupIndexTimeFrom]
	}
	backupIndexTimeTo := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"time_to":`...)
	w = basictl.JSONWriteInt64(w, item.TimeTo)
	if (item.TimeTo != 0) == false {
		w = w[:backupIndexTimeTo]
	}
	backupIndexInterval := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"interval":`...)
	w = basictl.JSONWriteString(w, item.Interval)
	if (len(item.Interval) != 0) == false {
		w = w[:backupIndexInterval]
	}
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"function":`...)
	w = item.Function.WriteJSONOpt(tctx, w)
	backupIndexGroupBy := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"group_by":`...)
	w = BuiltinVectorStringWriteJSONOpt(tctx, w, item.GroupBy)
	if (len(item.GroupBy) != 0) == false {
		w = w[:backupIndexGroupBy]
	}
	backupIndexFilter := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"filter":`...)
	w = BuiltinVectorStatshouseApiFilterWriteJSONOpt(tctx, w, item.Filter)
	if (len(item.Filter) != 0) == false {
		w = w[:backupIndexFilter]
	}
	backupIndexTimeShift := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"time_shift":`...)
	w = BuiltinVectorLongWriteJSONOpt(tctx, w, item.TimeShift)
	if (len(item.TimeShift) != 0) == false {
		w = w[:backupIndexTimeShift]
	}
	if item.FieldsMask&(1<<0) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"promql":`...)
		w = basictl.JSONWriteString(w, item.Promql)
	}
	if item.FieldsMask&(1<<1) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"what":`...)
		w = BuiltinVectorStatshouseApiFunctionWriteJSONOpt(tctx, w, item.What)
	}
	if item.FieldsMask&(1<<2) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"excess_points_flag":true`...)
	}
	if item.FieldsMask&(1<<3) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"widthAgg":`...)
		w = basictl.JSONWriteString(w, item.WidthAgg)
	}
	if item.FieldsMask&(1<<4) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"name_flag":true`...)
	}
	if item.FieldsMask&(1<<5) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"color_flag":true`...)
	}
	if item.FieldsMask&(1<<6) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"total_flag":true`...)
	}
	if item.FieldsMask&(1<<7) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"max_host_flag":true`...)
	}
	return append(w, '}')
}

func (item *StatshouseApiQuery) MarshalJSON() ([]byte, error) {
	return item.WriteJSON(nil), nil
}

func (item *StatshouseApiQuery) UnmarshalJSON(b []byte) error {
	if err := item.ReadJSON(true, &basictl.JsonLexer{Data: b}); err != nil {
		return ErrorInvalidJSON("statshouseApi.query", err.Error())
	}
	return nil
}

func (item *StatshouseApiQuery) CalculateLayout(sizes []int, optimizeEmpty bool) ([]int, int) {
	sizes = append(sizes, 3381992377)
	sizePosition := len(sizes)
	sizes = append(sizes, 0)

	currentSize := 1
	lastUsedByte := 0
	var sz int

	if item.FieldsMask != 0 {
		currentSize += 4
		lastUsedByte = currentSize
	}
	if item.Version != 0 {
		currentSize += 4
		lastUsedByte = currentSize
	}
	if item.TopN != 0 {
		currentSize += 4
		lastUsedByte = currentSize
	}
	if len(item.MetricName) != 0 {
		currentSize += basictl.TL2CalculateSize(len(item.MetricName)) + len(item.MetricName)
		lastUsedByte = currentSize
	}
	if item.TimeFrom != 0 {
		currentSize += 8
		lastUsedByte = currentSize
	}
	if item.TimeTo != 0 {
		currentSize += 8
		lastUsedByte = currentSize
	}
	if len(item.Interval) != 0 {
		currentSize += basictl.TL2CalculateSize(len(item.Interval)) + len(item.Interval)
		lastUsedByte = currentSize
	}
	currentSize++
	if sizes, sz = item.Function.CalculateLayout(sizes, true); sz != 0 {
		currentSize += sz
		lastUsedByte = currentSize
	}
	if sizes, sz = BuiltinVectorStringCalculateLayout(sizes, true, &item.GroupBy); sz != 0 {
		currentSize += sz
		lastUsedByte = currentSize
	}
	if sizes, sz = BuiltinVectorStatshouseApiFilterCalculateLayout(sizes, true, &item.Filter); sz != 0 {
		currentSize += sz
		lastUsedByte = currentSize
	}
	if sizes, sz = BuiltinVectorLongCalculateLayout(sizes, true, &item.TimeShift); sz != 0 {
		currentSize += sz
		lastUsedByte = currentSize
	}
	if item.tl2mask0&1 != 0 {
		currentSize += basictl.TL2CalculateSize(len(item.Promql)) + len(item.Promql)
		lastUsedByte = currentSize
	}
	if item.tl2mask0&2 != 0 {
		sizes, sz = BuiltinVectorStatshouseApiFunctionCalculateLayout(sizes, false, &item.What)
		currentSize += sz
		lastUsedByte = currentSize
	}
	if item.tl2mask0&4 != 0 {
		lastUsedByte = currentSize
	}
	if item.tl2mask0&8 != 0 {
		currentSize += basictl.TL2CalculateSize(len(item.WidthAgg)) + len(item.WidthAgg)
		lastUsedByte = currentSize
	}
	currentSize++
	if item.tl2mask0&16 != 0 {
		lastUsedByte = currentSize
	}
	if item.tl2mask0&32 != 0 {
		lastUsedByte = currentSize
	}
	if item.tl2mask0&64 != 0 {
		lastUsedByte = currentSize
	}
	if item.tl2mask0&128 != 0 {
		lastUsedByte = currentSize
	}

	if lastUsedByte < currentSize {
		currentSize = lastUsedByte
	}
	sizes[sizePosition] = currentSize
	if currentSize == 0 {
		sizes = sizes[:sizePosition+1]
	}
	if !optimizeEmpty || currentSize != 0 {
		currentSize += basictl.TL2CalculateSize(currentSize)
	}
	Unused(sz)
	return sizes, currentSize
}

func (item *StatshouseApiQuery) InternalWriteTL2(w []byte, sizes []int, optimizeEmpty bool) ([]byte, []int, int) {
	if sizes[0] != 3381992377 {
		panic("tl2: tag mismatch between calculate and write")
	}
	currentSize := sizes[1]
	sizes = sizes[2:]
	if optimizeEmpty && currentSize == 0 {
		return w, sizes, 0
	}
	w = basictl.TL2WriteSize(w, currentSize)
	oldLen := len(w)
	if len(w)-oldLen == currentSize {
		return w, sizes, 1
	}
	var sz int
	var currentBlock byte
	currentBlockPosition := len(w)
	w = append(w, 0)
	if item.FieldsMask != 0 {
		w = basictl.NatWrite(w, item.FieldsMask)
		currentBlock |= 2
	}
	if item.Version != 0 {
		w = basictl.IntWrite(w, item.Version)
		currentBlock |= 4
	}
	if item.TopN != 0 {
		w = basictl.IntWrite(w, item.TopN)
		currentBlock |= 8
	}
	if len(item.MetricName) != 0 {
		w = basictl.StringWriteTL2(w, item.MetricName)
		currentBlock |= 16
	}
	if item.TimeFrom != 0 {
		w = basictl.LongWrite(w, item.TimeFrom)
		currentBlock |= 32
	}
	if item.TimeTo != 0 {
		w = basictl.LongWrite(w, item.TimeTo)
		currentBlock |= 64
	}
	if len(item.Interval) != 0 {
		w = basictl.StringWriteTL2(w, item.Interval)
		currentBlock |= 128
	}
	w[currentBlockPosition] = currentBlock
	currentBlock = 0
	// start the next block
	currentBlockPosition = len(w)
	if len(w)-oldLen < currentSize {
		w = append(w, 0)
	}
	if w, sizes, sz = item.Function.InternalWriteTL2(w, sizes, true); sz != 0 {
		currentBlock |= 1
	}
	if w, sizes, sz = BuiltinVectorStringInternalWriteTL2(w, sizes, true, &item.GroupBy); sz != 0 {
		currentBlock |= 2
	}
	if w, sizes, sz = BuiltinVectorStatshouseApiFilterInternalWriteTL2(w, sizes, true, &item.Filter); sz != 0 {
		currentBlock |= 4
	}
	if w, sizes, sz = BuiltinVectorLongInternalWriteTL2(w, sizes, true, &item.TimeShift); sz != 0 {
		currentBlock |= 8
	}
	if item.tl2mask0&1 != 0 {
		w = basictl.StringWriteTL2(w, item.Promql)
		currentBlock |= 16
	}
	if item.tl2mask0&2 != 0 {
		w, sizes, _ = BuiltinVectorStatshouseApiFunctionInternalWriteTL2(w, sizes, false, &item.What)
		currentBlock |= 32
	}
	if item.tl2mask0&4 != 0 {
		currentBlock |= 64
	}
	if item.tl2mask0&8 != 0 {
		w = basictl.StringWriteTL2(w, item.WidthAgg)
		currentBlock |= 128
	}
	w[currentBlockPosition] = currentBlock
	currentBlock = 0
	// start the next block
	currentBlockPosition = len(w)
	if len(w)-oldLen < currentSize {
		w = append(w, 0)
	}
	if item.tl2mask0&16 != 0 {
		currentBlock |= 1
	}
	if item.tl2mask0&32 != 0 {
		currentBlock |= 2
	}
	if item.tl2mask0&64 != 0 {
		currentBlock |= 4
	}
	if item.tl2mask0&128 != 0 {
		currentBlock |= 8
	}
	if currentBlockPosition < len(w) {
		w[currentBlockPosition] = currentBlock
	}
	if len(w)-oldLen != currentSize {
		panic("tl2: mismatch between calculate and write")
	}
	Unused(sz)
	return w, sizes, 1
}

func (item *StatshouseApiQuery) WriteTL2(w []byte, ctx *basictl.TL2WriteContext) []byte {
	var sizes, sizes2 []int
	if ctx != nil {
		sizes = ctx.SizeBuffer[:0]
	}
	sizes, _ = item.CalculateLayout(sizes, false)
	w, sizes2, _ = item.InternalWriteTL2(w, sizes, false)
	if len(sizes2) != 0 {
		panic("tl2: internal write did not consume all size data")
	}
	if ctx != nil {
		ctx.SizeBuffer = sizes
	}
	return w
}

func (item *StatshouseApiQuery) InternalReadTL2(r []byte) (_ []byte, err error) {
	currentSize := 0
	if r, currentSize, err = basictl.TL2ParseSize(r); err != nil {
		return r, err
	}
	if len(r) < currentSize {
		return r, basictl.TL2Error("not enough data: expected %d, got %d", currentSize, len(r))
	}

	if currentSize == 0 {
		item.Reset()
		return r, nil
	}
	currentR := r[:currentSize]
	r = r[currentSize:]

	var block byte
	if currentR, err = basictl.ByteReadTL2(currentR, &block); err != nil {
		return currentR, err
	}
	// read No of constructor
	if block&1 != 0 {
		var index int
		if currentR, err = basictl.TL2ReadSize(currentR, &index); err != nil {
			return currentR, err
		}
		if index != 0 {
			return r, ErrorInvalidUnionIndex("statshouseApi.query", index)
		}
	}
	item.tl2mask0 = 0
	if block&2 != 0 {
		if currentR, err = basictl.NatRead(currentR, &item.FieldsMask); err != nil {
			return currentR, err
		}
	} else {
		item.FieldsMask = 0
	}
	if block&4 != 0 {
		if currentR, err = basictl.IntRead(currentR, &item.Version); err != nil {
			return currentR, err
		}
	} else {
		item.Version = 0
	}
	if block&8 != 0 {
		if currentR, err = basictl.IntRead(currentR, &item.TopN); err != nil {
			return currentR, err
		}
	} else {
		item.TopN = 0
	}
	if block&16 != 0 {
		if currentR, err = basictl.StringReadTL2(currentR, &item.MetricName); err != nil {
			return currentR, err
		}
	} else {
		item.MetricName = ""
	}
	if block&32 != 0 {
		if currentR, err = basictl.LongRead(currentR, &item.TimeFrom); err != nil {
			return currentR, err
		}
	} else {
		item.TimeFrom = 0
	}
	if block&64 != 0 {
		if currentR, err = basictl.LongRead(currentR, &item.TimeTo); err != nil {
			return currentR, err
		}
	} else {
		item.TimeTo = 0
	}
	if block&128 != 0 {
		if currentR, err = basictl.StringReadTL2(currentR, &item.Interval); err != nil {
			return currentR, err
		}
	} else {
		item.Interval = ""
	}
	// start the next block
	if len(currentR) > 0 {
		if currentR, err = basictl.ByteReadTL2(currentR, &block); err != nil {
			return currentR, err
		}
	} else {
		block = 0
	}
	if block&1 != 0 {
		if currentR, err = item.Function.InternalReadTL2(currentR); err != nil {
			return currentR, err
		}
	} else {
		item.Function.Reset()
	}
	if block&2 != 0 {
		if currentR, err = BuiltinVectorStringInternalReadTL2(currentR, &item.GroupBy); err != nil {
			return currentR, err
		}
	} else {
		item.GroupBy = item.GroupBy[:0]
	}
	if block&4 != 0 {
		if currentR, err = BuiltinVectorStatshouseApiFilterInternalReadTL2(currentR, &item.Filter); err != nil {
			return currentR, err
		}
	} else {
		item.Filter = item.Filter[:0]
	}
	if block&8 != 0 {
		if currentR, err = BuiltinVectorLongInternalReadTL2(currentR, &item.TimeShift); err != nil {
			return currentR, err
		}
	} else {
		item.TimeShift = item.TimeShift[:0]
	}
	if block&16 != 0 {
		item.tl2mask0 |= 1
		if currentR, err = basictl.StringReadTL2(currentR, &item.Promql); err != nil {
			return currentR, err
		}
	} else {
		item.Promql = ""
	}
	if block&32 != 0 {
		item.tl2mask0 |= 2
		if currentR, err = BuiltinVectorStatshouseApiFunctionInternalReadTL2(currentR, &item.What); err != nil {
			return currentR, err
		}
	} else {
		item.What = item.What[:0]
	}
	if block&64 != 0 {
		item.tl2mask0 |= 4
	}
	if block&128 != 0 {
		item.tl2mask0 |= 8
		if currentR, err = basictl.StringReadTL2(currentR, &item.WidthAgg); err != nil {
			return currentR, err
		}
	} else {
		item.WidthAgg = ""
	}
	// start the next block
	if len(currentR) > 0 {
		if currentR, err = basictl.ByteReadTL2(currentR, &block); err != nil {
			return currentR, err
		}
	} else {
		block = 0
	}
	if block&1 != 0 {
		item.tl2mask0 |= 16
	}
	if block&2 != 0 {
		item.tl2mask0 |= 32
	}
	if block&4 != 0 {
		item.tl2mask0 |= 64
	}
	if block&8 != 0 {
		item.tl2mask0 |= 128
	}
	Unused(currentR)
	return r, nil
}

func (item *StatshouseApiQuery) ReadTL2(r []byte, ctx *basictl.TL2ReadContext) (_ []byte, err error) {
	return item.InternalReadTL2(r)
}
