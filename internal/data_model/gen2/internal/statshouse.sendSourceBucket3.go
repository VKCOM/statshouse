// Copyright 2025 V Kontakte LLC
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

// Code generated by vktl/cmd/tlgen2; DO NOT EDIT.
package internal

import (
	"github.com/VKCOM/statshouse/internal/vkgo/basictl"
)

var _ = basictl.NatWrite

type StatshouseSendSourceBucket3 struct {
	FieldsMask uint32
	Header     StatshouseCommonProxyHeader
	Time       uint32
	// Historic (TrueType) // Conditional: item.FieldsMask.0
	// Spare (TrueType) // Conditional: item.FieldsMask.1
	BuildCommit    string
	BuildCommitTs  uint32
	OriginalSize   uint32
	CompressedData string
	SendMoreBytes  string
}

func (StatshouseSendSourceBucket3) TLName() string { return "statshouse.sendSourceBucket3" }
func (StatshouseSendSourceBucket3) TLTag() uint32  { return 0x0d04aa3f }

func (item *StatshouseSendSourceBucket3) SetHistoric(v bool) {
	if v {
		item.FieldsMask |= 1 << 0
	} else {
		item.FieldsMask &^= 1 << 0
	}
}
func (item StatshouseSendSourceBucket3) IsSetHistoric() bool { return item.FieldsMask&(1<<0) != 0 }

func (item *StatshouseSendSourceBucket3) SetSpare(v bool) {
	if v {
		item.FieldsMask |= 1 << 1
	} else {
		item.FieldsMask &^= 1 << 1
	}
}
func (item StatshouseSendSourceBucket3) IsSetSpare() bool { return item.FieldsMask&(1<<1) != 0 }

func (item *StatshouseSendSourceBucket3) Reset() {
	item.FieldsMask = 0
	item.Header.Reset()
	item.Time = 0
	item.BuildCommit = ""
	item.BuildCommitTs = 0
	item.OriginalSize = 0
	item.CompressedData = ""
	item.SendMoreBytes = ""
}

func (item *StatshouseSendSourceBucket3) Read(w []byte) (_ []byte, err error) {
	if w, err = basictl.NatRead(w, &item.FieldsMask); err != nil {
		return w, err
	}
	if w, err = item.Header.Read(w, item.FieldsMask); err != nil {
		return w, err
	}
	if w, err = basictl.NatRead(w, &item.Time); err != nil {
		return w, err
	}
	if w, err = basictl.StringRead(w, &item.BuildCommit); err != nil {
		return w, err
	}
	if w, err = basictl.NatRead(w, &item.BuildCommitTs); err != nil {
		return w, err
	}
	if w, err = basictl.NatRead(w, &item.OriginalSize); err != nil {
		return w, err
	}
	if w, err = basictl.StringRead(w, &item.CompressedData); err != nil {
		return w, err
	}
	return basictl.StringRead(w, &item.SendMoreBytes)
}

// This method is general version of Write, use it instead!
func (item *StatshouseSendSourceBucket3) WriteGeneral(w []byte) (_ []byte, err error) {
	return item.Write(w), nil
}

func (item *StatshouseSendSourceBucket3) Write(w []byte) []byte {
	w = basictl.NatWrite(w, item.FieldsMask)
	w = item.Header.Write(w, item.FieldsMask)
	w = basictl.NatWrite(w, item.Time)
	w = basictl.StringWrite(w, item.BuildCommit)
	w = basictl.NatWrite(w, item.BuildCommitTs)
	w = basictl.NatWrite(w, item.OriginalSize)
	w = basictl.StringWrite(w, item.CompressedData)
	w = basictl.StringWrite(w, item.SendMoreBytes)
	return w
}

func (item *StatshouseSendSourceBucket3) ReadBoxed(w []byte) (_ []byte, err error) {
	if w, err = basictl.NatReadExactTag(w, 0x0d04aa3f); err != nil {
		return w, err
	}
	return item.Read(w)
}

// This method is general version of WriteBoxed, use it instead!
func (item *StatshouseSendSourceBucket3) WriteBoxedGeneral(w []byte) (_ []byte, err error) {
	return item.WriteBoxed(w), nil
}

func (item *StatshouseSendSourceBucket3) WriteBoxed(w []byte) []byte {
	w = basictl.NatWrite(w, 0x0d04aa3f)
	return item.Write(w)
}

func (item *StatshouseSendSourceBucket3) ReadResult(w []byte, ret *StatshouseSendSourceBucket3Response) (_ []byte, err error) {
	return ret.ReadBoxed(w)
}

func (item *StatshouseSendSourceBucket3) WriteResult(w []byte, ret StatshouseSendSourceBucket3Response) (_ []byte, err error) {
	w = ret.WriteBoxed(w)
	return w, nil
}

func (item *StatshouseSendSourceBucket3) ReadResultJSON(legacyTypeNames bool, in *basictl.JsonLexer, ret *StatshouseSendSourceBucket3Response) error {
	if err := ret.ReadJSON(legacyTypeNames, in); err != nil {
		return err
	}
	return nil
}

func (item *StatshouseSendSourceBucket3) WriteResultJSON(w []byte, ret StatshouseSendSourceBucket3Response) (_ []byte, err error) {
	return item.writeResultJSON(true, false, w, ret)
}

func (item *StatshouseSendSourceBucket3) writeResultJSON(newTypeNames bool, short bool, w []byte, ret StatshouseSendSourceBucket3Response) (_ []byte, err error) {
	w = ret.WriteJSONOpt(newTypeNames, short, w)
	return w, nil
}

func (item *StatshouseSendSourceBucket3) ReadResultWriteResultJSON(r []byte, w []byte) (_ []byte, _ []byte, err error) {
	var ret StatshouseSendSourceBucket3Response
	if r, err = item.ReadResult(r, &ret); err != nil {
		return r, w, err
	}
	w, err = item.WriteResultJSON(w, ret)
	return r, w, err
}

func (item *StatshouseSendSourceBucket3) ReadResultWriteResultJSONOpt(newTypeNames bool, short bool, r []byte, w []byte) (_ []byte, _ []byte, err error) {
	var ret StatshouseSendSourceBucket3Response
	if r, err = item.ReadResult(r, &ret); err != nil {
		return r, w, err
	}
	w, err = item.writeResultJSON(newTypeNames, short, w, ret)
	return r, w, err
}

func (item *StatshouseSendSourceBucket3) ReadResultJSONWriteResult(r []byte, w []byte) ([]byte, []byte, error) {
	var ret StatshouseSendSourceBucket3Response
	err := item.ReadResultJSON(true, &basictl.JsonLexer{Data: r}, &ret)
	if err != nil {
		return r, w, err
	}
	w, err = item.WriteResult(w, ret)
	return r, w, err
}

func (item StatshouseSendSourceBucket3) String() string {
	return string(item.WriteJSON(nil))
}

func (item *StatshouseSendSourceBucket3) ReadJSON(legacyTypeNames bool, in *basictl.JsonLexer) error {
	var propFieldsMaskPresented bool
	var rawHeader []byte
	var propTimePresented bool
	var trueTypeHistoricPresented bool
	var trueTypeHistoricValue bool
	var trueTypeSparePresented bool
	var trueTypeSpareValue bool
	var propBuildCommitPresented bool
	var propBuildCommitTsPresented bool
	var propOriginalSizePresented bool
	var propCompressedDataPresented bool
	var propSendMoreBytesPresented bool

	if in != nil {
		in.Delim('{')
		if !in.Ok() {
			return in.Error()
		}
		for !in.IsDelim('}') {
			key := in.UnsafeFieldName(true)
			in.WantColon()
			switch key {
			case "fields_mask":
				if propFieldsMaskPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.sendSourceBucket3", "fields_mask")
				}
				if err := Json2ReadUint32(in, &item.FieldsMask); err != nil {
					return err
				}
				propFieldsMaskPresented = true
			case "header":
				if rawHeader != nil {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.sendSourceBucket3", "header")
				}
				rawHeader = in.Raw()
				if !in.Ok() {
					return in.Error()
				}
			case "time":
				if propTimePresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.sendSourceBucket3", "time")
				}
				if err := Json2ReadUint32(in, &item.Time); err != nil {
					return err
				}
				propTimePresented = true
			case "historic":
				if trueTypeHistoricPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.sendSourceBucket3", "historic")
				}
				if err := Json2ReadBool(in, &trueTypeHistoricValue); err != nil {
					return err
				}
				trueTypeHistoricPresented = true
			case "spare":
				if trueTypeSparePresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.sendSourceBucket3", "spare")
				}
				if err := Json2ReadBool(in, &trueTypeSpareValue); err != nil {
					return err
				}
				trueTypeSparePresented = true
			case "build_commit":
				if propBuildCommitPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.sendSourceBucket3", "build_commit")
				}
				if err := Json2ReadString(in, &item.BuildCommit); err != nil {
					return err
				}
				propBuildCommitPresented = true
			case "build_commit_ts":
				if propBuildCommitTsPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.sendSourceBucket3", "build_commit_ts")
				}
				if err := Json2ReadUint32(in, &item.BuildCommitTs); err != nil {
					return err
				}
				propBuildCommitTsPresented = true
			case "original_size":
				if propOriginalSizePresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.sendSourceBucket3", "original_size")
				}
				if err := Json2ReadUint32(in, &item.OriginalSize); err != nil {
					return err
				}
				propOriginalSizePresented = true
			case "compressed_data":
				if propCompressedDataPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.sendSourceBucket3", "compressed_data")
				}
				if err := Json2ReadString(in, &item.CompressedData); err != nil {
					return err
				}
				propCompressedDataPresented = true
			case "send_more_bytes":
				if propSendMoreBytesPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.sendSourceBucket3", "send_more_bytes")
				}
				if err := Json2ReadString(in, &item.SendMoreBytes); err != nil {
					return err
				}
				propSendMoreBytesPresented = true
			default:
				return ErrorInvalidJSONExcessElement("statshouse.sendSourceBucket3", key)
			}
			in.WantComma()
		}
		in.Delim('}')
		if !in.Ok() {
			return in.Error()
		}
	}
	if !propFieldsMaskPresented {
		item.FieldsMask = 0
	}
	if !propTimePresented {
		item.Time = 0
	}
	if !propBuildCommitPresented {
		item.BuildCommit = ""
	}
	if !propBuildCommitTsPresented {
		item.BuildCommitTs = 0
	}
	if !propOriginalSizePresented {
		item.OriginalSize = 0
	}
	if !propCompressedDataPresented {
		item.CompressedData = ""
	}
	if !propSendMoreBytesPresented {
		item.SendMoreBytes = ""
	}
	if trueTypeHistoricPresented {
		if trueTypeHistoricValue {
			item.FieldsMask |= 1 << 0
		}
	}
	if trueTypeSparePresented {
		if trueTypeSpareValue {
			item.FieldsMask |= 1 << 1
		}
	}
	var inHeaderPointer *basictl.JsonLexer
	inHeader := basictl.JsonLexer{Data: rawHeader}
	if rawHeader != nil {
		inHeaderPointer = &inHeader
	}
	if err := item.Header.ReadJSON(legacyTypeNames, inHeaderPointer, item.FieldsMask); err != nil {
		return err
	}

	// tries to set bit to zero if it is 1
	if trueTypeHistoricPresented && !trueTypeHistoricValue && (item.FieldsMask&(1<<0) != 0) {
		return ErrorInvalidJSON("statshouse.sendSourceBucket3", "fieldmask bit fields_mask.0 is indefinite because of the contradictions in values")
	}
	// tries to set bit to zero if it is 1
	if trueTypeSparePresented && !trueTypeSpareValue && (item.FieldsMask&(1<<1) != 0) {
		return ErrorInvalidJSON("statshouse.sendSourceBucket3", "fieldmask bit fields_mask.0 is indefinite because of the contradictions in values")
	}
	return nil
}

// This method is general version of WriteJSON, use it instead!
func (item *StatshouseSendSourceBucket3) WriteJSONGeneral(w []byte) (_ []byte, err error) {
	return item.WriteJSONOpt(true, false, w), nil
}

func (item *StatshouseSendSourceBucket3) WriteJSON(w []byte) []byte {
	return item.WriteJSONOpt(true, false, w)
}
func (item *StatshouseSendSourceBucket3) WriteJSONOpt(newTypeNames bool, short bool, w []byte) []byte {
	w = append(w, '{')
	backupIndexFieldsMask := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"fields_mask":`...)
	w = basictl.JSONWriteUint32(w, item.FieldsMask)
	if (item.FieldsMask != 0) == false {
		w = w[:backupIndexFieldsMask]
	}
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"header":`...)
	w = item.Header.WriteJSONOpt(newTypeNames, short, w, item.FieldsMask)
	backupIndexTime := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"time":`...)
	w = basictl.JSONWriteUint32(w, item.Time)
	if (item.Time != 0) == false {
		w = w[:backupIndexTime]
	}
	if item.FieldsMask&(1<<0) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"historic":true`...)
	}
	if item.FieldsMask&(1<<1) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"spare":true`...)
	}
	backupIndexBuildCommit := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"build_commit":`...)
	w = basictl.JSONWriteString(w, item.BuildCommit)
	if (len(item.BuildCommit) != 0) == false {
		w = w[:backupIndexBuildCommit]
	}
	backupIndexBuildCommitTs := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"build_commit_ts":`...)
	w = basictl.JSONWriteUint32(w, item.BuildCommitTs)
	if (item.BuildCommitTs != 0) == false {
		w = w[:backupIndexBuildCommitTs]
	}
	backupIndexOriginalSize := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"original_size":`...)
	w = basictl.JSONWriteUint32(w, item.OriginalSize)
	if (item.OriginalSize != 0) == false {
		w = w[:backupIndexOriginalSize]
	}
	backupIndexCompressedData := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"compressed_data":`...)
	w = basictl.JSONWriteString(w, item.CompressedData)
	if (len(item.CompressedData) != 0) == false {
		w = w[:backupIndexCompressedData]
	}
	backupIndexSendMoreBytes := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"send_more_bytes":`...)
	w = basictl.JSONWriteString(w, item.SendMoreBytes)
	if (len(item.SendMoreBytes) != 0) == false {
		w = w[:backupIndexSendMoreBytes]
	}
	return append(w, '}')
}

func (item *StatshouseSendSourceBucket3) MarshalJSON() ([]byte, error) {
	return item.WriteJSON(nil), nil
}

func (item *StatshouseSendSourceBucket3) UnmarshalJSON(b []byte) error {
	if err := item.ReadJSON(true, &basictl.JsonLexer{Data: b}); err != nil {
		return ErrorInvalidJSON("statshouse.sendSourceBucket3", err.Error())
	}
	return nil
}

type StatshouseSendSourceBucket3Bytes struct {
	FieldsMask uint32
	Header     StatshouseCommonProxyHeaderBytes
	Time       uint32
	// Historic (TrueType) // Conditional: item.FieldsMask.0
	// Spare (TrueType) // Conditional: item.FieldsMask.1
	BuildCommit    []byte
	BuildCommitTs  uint32
	OriginalSize   uint32
	CompressedData []byte
	SendMoreBytes  []byte
}

func (StatshouseSendSourceBucket3Bytes) TLName() string { return "statshouse.sendSourceBucket3" }
func (StatshouseSendSourceBucket3Bytes) TLTag() uint32  { return 0x0d04aa3f }

func (item *StatshouseSendSourceBucket3Bytes) SetHistoric(v bool) {
	if v {
		item.FieldsMask |= 1 << 0
	} else {
		item.FieldsMask &^= 1 << 0
	}
}
func (item StatshouseSendSourceBucket3Bytes) IsSetHistoric() bool { return item.FieldsMask&(1<<0) != 0 }

func (item *StatshouseSendSourceBucket3Bytes) SetSpare(v bool) {
	if v {
		item.FieldsMask |= 1 << 1
	} else {
		item.FieldsMask &^= 1 << 1
	}
}
func (item StatshouseSendSourceBucket3Bytes) IsSetSpare() bool { return item.FieldsMask&(1<<1) != 0 }

func (item *StatshouseSendSourceBucket3Bytes) Reset() {
	item.FieldsMask = 0
	item.Header.Reset()
	item.Time = 0
	item.BuildCommit = item.BuildCommit[:0]
	item.BuildCommitTs = 0
	item.OriginalSize = 0
	item.CompressedData = item.CompressedData[:0]
	item.SendMoreBytes = item.SendMoreBytes[:0]
}

func (item *StatshouseSendSourceBucket3Bytes) Read(w []byte) (_ []byte, err error) {
	if w, err = basictl.NatRead(w, &item.FieldsMask); err != nil {
		return w, err
	}
	if w, err = item.Header.Read(w, item.FieldsMask); err != nil {
		return w, err
	}
	if w, err = basictl.NatRead(w, &item.Time); err != nil {
		return w, err
	}
	if w, err = basictl.StringReadBytes(w, &item.BuildCommit); err != nil {
		return w, err
	}
	if w, err = basictl.NatRead(w, &item.BuildCommitTs); err != nil {
		return w, err
	}
	if w, err = basictl.NatRead(w, &item.OriginalSize); err != nil {
		return w, err
	}
	if w, err = basictl.StringReadBytes(w, &item.CompressedData); err != nil {
		return w, err
	}
	return basictl.StringReadBytes(w, &item.SendMoreBytes)
}

// This method is general version of Write, use it instead!
func (item *StatshouseSendSourceBucket3Bytes) WriteGeneral(w []byte) (_ []byte, err error) {
	return item.Write(w), nil
}

func (item *StatshouseSendSourceBucket3Bytes) Write(w []byte) []byte {
	w = basictl.NatWrite(w, item.FieldsMask)
	w = item.Header.Write(w, item.FieldsMask)
	w = basictl.NatWrite(w, item.Time)
	w = basictl.StringWriteBytes(w, item.BuildCommit)
	w = basictl.NatWrite(w, item.BuildCommitTs)
	w = basictl.NatWrite(w, item.OriginalSize)
	w = basictl.StringWriteBytes(w, item.CompressedData)
	w = basictl.StringWriteBytes(w, item.SendMoreBytes)
	return w
}

func (item *StatshouseSendSourceBucket3Bytes) ReadBoxed(w []byte) (_ []byte, err error) {
	if w, err = basictl.NatReadExactTag(w, 0x0d04aa3f); err != nil {
		return w, err
	}
	return item.Read(w)
}

// This method is general version of WriteBoxed, use it instead!
func (item *StatshouseSendSourceBucket3Bytes) WriteBoxedGeneral(w []byte) (_ []byte, err error) {
	return item.WriteBoxed(w), nil
}

func (item *StatshouseSendSourceBucket3Bytes) WriteBoxed(w []byte) []byte {
	w = basictl.NatWrite(w, 0x0d04aa3f)
	return item.Write(w)
}

func (item *StatshouseSendSourceBucket3Bytes) ReadResult(w []byte, ret *StatshouseSendSourceBucket3ResponseBytes) (_ []byte, err error) {
	return ret.ReadBoxed(w)
}

func (item *StatshouseSendSourceBucket3Bytes) WriteResult(w []byte, ret StatshouseSendSourceBucket3ResponseBytes) (_ []byte, err error) {
	w = ret.WriteBoxed(w)
	return w, nil
}

func (item *StatshouseSendSourceBucket3Bytes) ReadResultJSON(legacyTypeNames bool, in *basictl.JsonLexer, ret *StatshouseSendSourceBucket3ResponseBytes) error {
	if err := ret.ReadJSON(legacyTypeNames, in); err != nil {
		return err
	}
	return nil
}

func (item *StatshouseSendSourceBucket3Bytes) WriteResultJSON(w []byte, ret StatshouseSendSourceBucket3ResponseBytes) (_ []byte, err error) {
	return item.writeResultJSON(true, false, w, ret)
}

func (item *StatshouseSendSourceBucket3Bytes) writeResultJSON(newTypeNames bool, short bool, w []byte, ret StatshouseSendSourceBucket3ResponseBytes) (_ []byte, err error) {
	w = ret.WriteJSONOpt(newTypeNames, short, w)
	return w, nil
}

func (item *StatshouseSendSourceBucket3Bytes) ReadResultWriteResultJSON(r []byte, w []byte) (_ []byte, _ []byte, err error) {
	var ret StatshouseSendSourceBucket3ResponseBytes
	if r, err = item.ReadResult(r, &ret); err != nil {
		return r, w, err
	}
	w, err = item.WriteResultJSON(w, ret)
	return r, w, err
}

func (item *StatshouseSendSourceBucket3Bytes) ReadResultWriteResultJSONOpt(newTypeNames bool, short bool, r []byte, w []byte) (_ []byte, _ []byte, err error) {
	var ret StatshouseSendSourceBucket3ResponseBytes
	if r, err = item.ReadResult(r, &ret); err != nil {
		return r, w, err
	}
	w, err = item.writeResultJSON(newTypeNames, short, w, ret)
	return r, w, err
}

func (item *StatshouseSendSourceBucket3Bytes) ReadResultJSONWriteResult(r []byte, w []byte) ([]byte, []byte, error) {
	var ret StatshouseSendSourceBucket3ResponseBytes
	err := item.ReadResultJSON(true, &basictl.JsonLexer{Data: r}, &ret)
	if err != nil {
		return r, w, err
	}
	w, err = item.WriteResult(w, ret)
	return r, w, err
}

func (item StatshouseSendSourceBucket3Bytes) String() string {
	return string(item.WriteJSON(nil))
}

func (item *StatshouseSendSourceBucket3Bytes) ReadJSON(legacyTypeNames bool, in *basictl.JsonLexer) error {
	var propFieldsMaskPresented bool
	var rawHeader []byte
	var propTimePresented bool
	var trueTypeHistoricPresented bool
	var trueTypeHistoricValue bool
	var trueTypeSparePresented bool
	var trueTypeSpareValue bool
	var propBuildCommitPresented bool
	var propBuildCommitTsPresented bool
	var propOriginalSizePresented bool
	var propCompressedDataPresented bool
	var propSendMoreBytesPresented bool

	if in != nil {
		in.Delim('{')
		if !in.Ok() {
			return in.Error()
		}
		for !in.IsDelim('}') {
			key := in.UnsafeFieldName(true)
			in.WantColon()
			switch key {
			case "fields_mask":
				if propFieldsMaskPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.sendSourceBucket3", "fields_mask")
				}
				if err := Json2ReadUint32(in, &item.FieldsMask); err != nil {
					return err
				}
				propFieldsMaskPresented = true
			case "header":
				if rawHeader != nil {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.sendSourceBucket3", "header")
				}
				rawHeader = in.Raw()
				if !in.Ok() {
					return in.Error()
				}
			case "time":
				if propTimePresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.sendSourceBucket3", "time")
				}
				if err := Json2ReadUint32(in, &item.Time); err != nil {
					return err
				}
				propTimePresented = true
			case "historic":
				if trueTypeHistoricPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.sendSourceBucket3", "historic")
				}
				if err := Json2ReadBool(in, &trueTypeHistoricValue); err != nil {
					return err
				}
				trueTypeHistoricPresented = true
			case "spare":
				if trueTypeSparePresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.sendSourceBucket3", "spare")
				}
				if err := Json2ReadBool(in, &trueTypeSpareValue); err != nil {
					return err
				}
				trueTypeSparePresented = true
			case "build_commit":
				if propBuildCommitPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.sendSourceBucket3", "build_commit")
				}
				if err := Json2ReadStringBytes(in, &item.BuildCommit); err != nil {
					return err
				}
				propBuildCommitPresented = true
			case "build_commit_ts":
				if propBuildCommitTsPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.sendSourceBucket3", "build_commit_ts")
				}
				if err := Json2ReadUint32(in, &item.BuildCommitTs); err != nil {
					return err
				}
				propBuildCommitTsPresented = true
			case "original_size":
				if propOriginalSizePresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.sendSourceBucket3", "original_size")
				}
				if err := Json2ReadUint32(in, &item.OriginalSize); err != nil {
					return err
				}
				propOriginalSizePresented = true
			case "compressed_data":
				if propCompressedDataPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.sendSourceBucket3", "compressed_data")
				}
				if err := Json2ReadStringBytes(in, &item.CompressedData); err != nil {
					return err
				}
				propCompressedDataPresented = true
			case "send_more_bytes":
				if propSendMoreBytesPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.sendSourceBucket3", "send_more_bytes")
				}
				if err := Json2ReadStringBytes(in, &item.SendMoreBytes); err != nil {
					return err
				}
				propSendMoreBytesPresented = true
			default:
				return ErrorInvalidJSONExcessElement("statshouse.sendSourceBucket3", key)
			}
			in.WantComma()
		}
		in.Delim('}')
		if !in.Ok() {
			return in.Error()
		}
	}
	if !propFieldsMaskPresented {
		item.FieldsMask = 0
	}
	if !propTimePresented {
		item.Time = 0
	}
	if !propBuildCommitPresented {
		item.BuildCommit = item.BuildCommit[:0]
	}
	if !propBuildCommitTsPresented {
		item.BuildCommitTs = 0
	}
	if !propOriginalSizePresented {
		item.OriginalSize = 0
	}
	if !propCompressedDataPresented {
		item.CompressedData = item.CompressedData[:0]
	}
	if !propSendMoreBytesPresented {
		item.SendMoreBytes = item.SendMoreBytes[:0]
	}
	if trueTypeHistoricPresented {
		if trueTypeHistoricValue {
			item.FieldsMask |= 1 << 0
		}
	}
	if trueTypeSparePresented {
		if trueTypeSpareValue {
			item.FieldsMask |= 1 << 1
		}
	}
	var inHeaderPointer *basictl.JsonLexer
	inHeader := basictl.JsonLexer{Data: rawHeader}
	if rawHeader != nil {
		inHeaderPointer = &inHeader
	}
	if err := item.Header.ReadJSON(legacyTypeNames, inHeaderPointer, item.FieldsMask); err != nil {
		return err
	}

	// tries to set bit to zero if it is 1
	if trueTypeHistoricPresented && !trueTypeHistoricValue && (item.FieldsMask&(1<<0) != 0) {
		return ErrorInvalidJSON("statshouse.sendSourceBucket3", "fieldmask bit fields_mask.0 is indefinite because of the contradictions in values")
	}
	// tries to set bit to zero if it is 1
	if trueTypeSparePresented && !trueTypeSpareValue && (item.FieldsMask&(1<<1) != 0) {
		return ErrorInvalidJSON("statshouse.sendSourceBucket3", "fieldmask bit fields_mask.0 is indefinite because of the contradictions in values")
	}
	return nil
}

// This method is general version of WriteJSON, use it instead!
func (item *StatshouseSendSourceBucket3Bytes) WriteJSONGeneral(w []byte) (_ []byte, err error) {
	return item.WriteJSONOpt(true, false, w), nil
}

func (item *StatshouseSendSourceBucket3Bytes) WriteJSON(w []byte) []byte {
	return item.WriteJSONOpt(true, false, w)
}
func (item *StatshouseSendSourceBucket3Bytes) WriteJSONOpt(newTypeNames bool, short bool, w []byte) []byte {
	w = append(w, '{')
	backupIndexFieldsMask := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"fields_mask":`...)
	w = basictl.JSONWriteUint32(w, item.FieldsMask)
	if (item.FieldsMask != 0) == false {
		w = w[:backupIndexFieldsMask]
	}
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"header":`...)
	w = item.Header.WriteJSONOpt(newTypeNames, short, w, item.FieldsMask)
	backupIndexTime := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"time":`...)
	w = basictl.JSONWriteUint32(w, item.Time)
	if (item.Time != 0) == false {
		w = w[:backupIndexTime]
	}
	if item.FieldsMask&(1<<0) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"historic":true`...)
	}
	if item.FieldsMask&(1<<1) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"spare":true`...)
	}
	backupIndexBuildCommit := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"build_commit":`...)
	w = basictl.JSONWriteStringBytes(w, item.BuildCommit)
	if (len(item.BuildCommit) != 0) == false {
		w = w[:backupIndexBuildCommit]
	}
	backupIndexBuildCommitTs := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"build_commit_ts":`...)
	w = basictl.JSONWriteUint32(w, item.BuildCommitTs)
	if (item.BuildCommitTs != 0) == false {
		w = w[:backupIndexBuildCommitTs]
	}
	backupIndexOriginalSize := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"original_size":`...)
	w = basictl.JSONWriteUint32(w, item.OriginalSize)
	if (item.OriginalSize != 0) == false {
		w = w[:backupIndexOriginalSize]
	}
	backupIndexCompressedData := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"compressed_data":`...)
	w = basictl.JSONWriteStringBytes(w, item.CompressedData)
	if (len(item.CompressedData) != 0) == false {
		w = w[:backupIndexCompressedData]
	}
	backupIndexSendMoreBytes := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"send_more_bytes":`...)
	w = basictl.JSONWriteStringBytes(w, item.SendMoreBytes)
	if (len(item.SendMoreBytes) != 0) == false {
		w = w[:backupIndexSendMoreBytes]
	}
	return append(w, '}')
}

func (item *StatshouseSendSourceBucket3Bytes) MarshalJSON() ([]byte, error) {
	return item.WriteJSON(nil), nil
}

func (item *StatshouseSendSourceBucket3Bytes) UnmarshalJSON(b []byte) error {
	if err := item.ReadJSON(true, &basictl.JsonLexer{Data: b}); err != nil {
		return ErrorInvalidJSON("statshouse.sendSourceBucket3", err.Error())
	}
	return nil
}
