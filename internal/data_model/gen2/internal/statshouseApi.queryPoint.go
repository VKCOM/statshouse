// Copyright 2025 V Kontakte LLC
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

// Code generated by vktl/cmd/tlgen2; DO NOT EDIT.
package internal

import (
	"github.com/VKCOM/statshouse/internal/vkgo/basictl"
)

var _ = basictl.NatWrite

type StatshouseApiQueryPoint struct {
	FieldsMask uint32
	Version    int32
	TopN       int32
	MetricName string
	TimeFrom   int64
	TimeTo     int64
	Function   StatshouseApiFunction
	GroupBy    []string
	Filter     []StatshouseApiFilter
	TimeShift  []int64
	What       []StatshouseApiFunction // Conditional: item.FieldsMask.1
	tl2mask0   byte
}

func (StatshouseApiQueryPoint) TLName() string { return "statshouseApi.queryPoint" }
func (StatshouseApiQueryPoint) TLTag() uint32  { return 0xc9951bbb }

func (item *StatshouseApiQueryPoint) SetWhat(v []StatshouseApiFunction) {
	item.What = v
	item.FieldsMask |= 1 << 1
	item.tl2mask0 |= 1
}
func (item *StatshouseApiQueryPoint) ClearWhat() {
	item.What = item.What[:0]
	item.FieldsMask &^= 1 << 1
	item.tl2mask0 &^= 1
}
func (item *StatshouseApiQueryPoint) IsSetWhat() bool { return item.tl2mask0&1 != 0 }

func (item *StatshouseApiQueryPoint) Reset() {
	item.FieldsMask = 0
	item.Version = 0
	item.TopN = 0
	item.MetricName = ""
	item.TimeFrom = 0
	item.TimeTo = 0
	item.Function.Reset()
	item.GroupBy = item.GroupBy[:0]
	item.Filter = item.Filter[:0]
	item.TimeShift = item.TimeShift[:0]
	item.What = item.What[:0]
	item.tl2mask0 = 0
}

func (item *StatshouseApiQueryPoint) FillRandom(rg *basictl.RandGenerator) {
	item.tl2mask0 = 0
	item.FieldsMask = basictl.RandomFieldMask(rg, 0b10)
	item.Version = basictl.RandomInt(rg)
	item.TopN = basictl.RandomInt(rg)
	item.MetricName = basictl.RandomString(rg)
	item.TimeFrom = basictl.RandomLong(rg)
	item.TimeTo = basictl.RandomLong(rg)
	item.Function.FillRandom(rg)
	BuiltinVectorStringFillRandom(rg, &item.GroupBy)
	BuiltinVectorStatshouseApiFilterFillRandom(rg, &item.Filter)
	BuiltinVectorLongFillRandom(rg, &item.TimeShift)
	if item.FieldsMask&(1<<1) != 0 {
		item.tl2mask0 |= 1
		BuiltinVectorStatshouseApiFunctionFillRandom(rg, &item.What)
	} else {
		item.What = item.What[:0]
	}
}

func (item *StatshouseApiQueryPoint) Read(w []byte) (_ []byte, err error) {
	item.tl2mask0 = 0
	if w, err = basictl.NatRead(w, &item.FieldsMask); err != nil {
		return w, err
	}
	if w, err = basictl.IntRead(w, &item.Version); err != nil {
		return w, err
	}
	if w, err = basictl.IntRead(w, &item.TopN); err != nil {
		return w, err
	}
	if w, err = basictl.StringRead(w, &item.MetricName); err != nil {
		return w, err
	}
	if w, err = basictl.LongRead(w, &item.TimeFrom); err != nil {
		return w, err
	}
	if w, err = basictl.LongRead(w, &item.TimeTo); err != nil {
		return w, err
	}
	if w, err = item.Function.ReadBoxed(w); err != nil {
		return w, err
	}
	if w, err = BuiltinVectorStringRead(w, &item.GroupBy); err != nil {
		return w, err
	}
	if w, err = BuiltinVectorStatshouseApiFilterRead(w, &item.Filter); err != nil {
		return w, err
	}
	if w, err = BuiltinVectorLongRead(w, &item.TimeShift); err != nil {
		return w, err
	}
	if item.FieldsMask&(1<<1) != 0 {
		item.tl2mask0 |= 1
		if w, err = BuiltinVectorStatshouseApiFunctionRead(w, &item.What); err != nil {
			return w, err
		}
	} else {
		item.What = item.What[:0]
	}
	return w, nil
}

func (item *StatshouseApiQueryPoint) WriteGeneral(w []byte) (_ []byte, err error) {
	return item.Write(w), nil
}

func (item *StatshouseApiQueryPoint) Write(w []byte) []byte {
	w = basictl.NatWrite(w, item.FieldsMask)
	w = basictl.IntWrite(w, item.Version)
	w = basictl.IntWrite(w, item.TopN)
	w = basictl.StringWrite(w, item.MetricName)
	w = basictl.LongWrite(w, item.TimeFrom)
	w = basictl.LongWrite(w, item.TimeTo)
	w = item.Function.WriteBoxed(w)
	w = BuiltinVectorStringWrite(w, item.GroupBy)
	w = BuiltinVectorStatshouseApiFilterWrite(w, item.Filter)
	w = BuiltinVectorLongWrite(w, item.TimeShift)
	if item.FieldsMask&(1<<1) != 0 {
		w = BuiltinVectorStatshouseApiFunctionWrite(w, item.What)
	}
	return w
}

func (item *StatshouseApiQueryPoint) ReadBoxed(w []byte) (_ []byte, err error) {
	if w, err = basictl.NatReadExactTag(w, 0xc9951bbb); err != nil {
		return w, err
	}
	return item.Read(w)
}

func (item *StatshouseApiQueryPoint) WriteBoxedGeneral(w []byte) (_ []byte, err error) {
	return item.WriteBoxed(w), nil
}

func (item *StatshouseApiQueryPoint) WriteBoxed(w []byte) []byte {
	w = basictl.NatWrite(w, 0xc9951bbb)
	return item.Write(w)
}

func (item StatshouseApiQueryPoint) String() string {
	return string(item.WriteJSON(nil))
}

func (item *StatshouseApiQueryPoint) ReadJSON(legacyTypeNames bool, in *basictl.JsonLexer) error {
	tctx := basictl.JSONReadContext{LegacyTypeNames: legacyTypeNames}
	return item.ReadJSONGeneral(&tctx, in)
}

func (item *StatshouseApiQueryPoint) ReadJSONGeneral(tctx *basictl.JSONReadContext, in *basictl.JsonLexer) error {
	var propFieldsMaskPresented bool
	var propVersionPresented bool
	var propTopNPresented bool
	var propMetricNamePresented bool
	var propTimeFromPresented bool
	var propTimeToPresented bool
	var propFunctionPresented bool
	var propGroupByPresented bool
	var propFilterPresented bool
	var propTimeShiftPresented bool
	var propWhatPresented bool

	if in != nil {
		in.Delim('{')
		if !in.Ok() {
			return in.Error()
		}
		for !in.IsDelim('}') {
			key := in.UnsafeFieldName(true)
			in.WantColon()
			switch key {
			case "fields_mask":
				if propFieldsMaskPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouseApi.queryPoint", "fields_mask")
				}
				if err := Json2ReadUint32(in, &item.FieldsMask); err != nil {
					return err
				}
				propFieldsMaskPresented = true
			case "version":
				if propVersionPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouseApi.queryPoint", "version")
				}
				if err := Json2ReadInt32(in, &item.Version); err != nil {
					return err
				}
				propVersionPresented = true
			case "top_n":
				if propTopNPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouseApi.queryPoint", "top_n")
				}
				if err := Json2ReadInt32(in, &item.TopN); err != nil {
					return err
				}
				propTopNPresented = true
			case "metric_name":
				if propMetricNamePresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouseApi.queryPoint", "metric_name")
				}
				if err := Json2ReadString(in, &item.MetricName); err != nil {
					return err
				}
				propMetricNamePresented = true
			case "time_from":
				if propTimeFromPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouseApi.queryPoint", "time_from")
				}
				if err := Json2ReadInt64(in, &item.TimeFrom); err != nil {
					return err
				}
				propTimeFromPresented = true
			case "time_to":
				if propTimeToPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouseApi.queryPoint", "time_to")
				}
				if err := Json2ReadInt64(in, &item.TimeTo); err != nil {
					return err
				}
				propTimeToPresented = true
			case "function":
				if propFunctionPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouseApi.queryPoint", "function")
				}
				if err := item.Function.ReadJSONGeneral(tctx, in); err != nil {
					return err
				}
				propFunctionPresented = true
			case "group_by":
				if propGroupByPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouseApi.queryPoint", "group_by")
				}
				if err := BuiltinVectorStringReadJSONGeneral(tctx, in, &item.GroupBy); err != nil {
					return err
				}
				propGroupByPresented = true
			case "filter":
				if propFilterPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouseApi.queryPoint", "filter")
				}
				if err := BuiltinVectorStatshouseApiFilterReadJSONGeneral(tctx, in, &item.Filter); err != nil {
					return err
				}
				propFilterPresented = true
			case "time_shift":
				if propTimeShiftPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouseApi.queryPoint", "time_shift")
				}
				if err := BuiltinVectorLongReadJSONGeneral(tctx, in, &item.TimeShift); err != nil {
					return err
				}
				propTimeShiftPresented = true
			case "what":
				if propWhatPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouseApi.queryPoint", "what")
				}
				if err := BuiltinVectorStatshouseApiFunctionReadJSONGeneral(tctx, in, &item.What); err != nil {
					return err
				}
				propWhatPresented = true
			default:
				return ErrorInvalidJSONExcessElement("statshouseApi.queryPoint", key)
			}
			in.WantComma()
		}
		in.Delim('}')
		if !in.Ok() {
			return in.Error()
		}
	}
	if !propFieldsMaskPresented {
		item.FieldsMask = 0
	}
	if !propVersionPresented {
		item.Version = 0
	}
	if !propTopNPresented {
		item.TopN = 0
	}
	if !propMetricNamePresented {
		item.MetricName = ""
	}
	if !propTimeFromPresented {
		item.TimeFrom = 0
	}
	if !propTimeToPresented {
		item.TimeTo = 0
	}
	if !propFunctionPresented {
		item.Function.Reset()
	}
	if !propGroupByPresented {
		item.GroupBy = item.GroupBy[:0]
	}
	if !propFilterPresented {
		item.Filter = item.Filter[:0]
	}
	if !propTimeShiftPresented {
		item.TimeShift = item.TimeShift[:0]
	}
	if !propWhatPresented {
		item.What = item.What[:0]
	}
	if propWhatPresented {
		item.FieldsMask |= 1 << 1
	}
	if item.FieldsMask&(1<<1) != 0 {
		item.tl2mask0 |= 1
	}
	return nil
}

// This method is general version of WriteJSON, use it instead!
func (item *StatshouseApiQueryPoint) WriteJSONGeneral(tctx *basictl.JSONWriteContext, w []byte) (_ []byte, err error) {
	return item.WriteJSONOpt(tctx, w), nil
}

func (item *StatshouseApiQueryPoint) WriteJSON(w []byte) []byte {
	tctx := basictl.JSONWriteContext{}
	return item.WriteJSONOpt(&tctx, w)
}
func (item *StatshouseApiQueryPoint) WriteJSONOpt(tctx *basictl.JSONWriteContext, w []byte) []byte {
	w = append(w, '{')
	backupIndexFieldsMask := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"fields_mask":`...)
	w = basictl.JSONWriteUint32(w, item.FieldsMask)
	if (item.FieldsMask != 0) == false {
		w = w[:backupIndexFieldsMask]
	}
	backupIndexVersion := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"version":`...)
	w = basictl.JSONWriteInt32(w, item.Version)
	if (item.Version != 0) == false {
		w = w[:backupIndexVersion]
	}
	backupIndexTopN := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"top_n":`...)
	w = basictl.JSONWriteInt32(w, item.TopN)
	if (item.TopN != 0) == false {
		w = w[:backupIndexTopN]
	}
	backupIndexMetricName := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"metric_name":`...)
	w = basictl.JSONWriteString(w, item.MetricName)
	if (len(item.MetricName) != 0) == false {
		w = w[:backupIndexMetricName]
	}
	backupIndexTimeFrom := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"time_from":`...)
	w = basictl.JSONWriteInt64(w, item.TimeFrom)
	if (item.TimeFrom != 0) == false {
		w = w[:backupIndexTimeFrom]
	}
	backupIndexTimeTo := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"time_to":`...)
	w = basictl.JSONWriteInt64(w, item.TimeTo)
	if (item.TimeTo != 0) == false {
		w = w[:backupIndexTimeTo]
	}
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"function":`...)
	w = item.Function.WriteJSONOpt(tctx, w)
	backupIndexGroupBy := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"group_by":`...)
	w = BuiltinVectorStringWriteJSONOpt(tctx, w, item.GroupBy)
	if (len(item.GroupBy) != 0) == false {
		w = w[:backupIndexGroupBy]
	}
	backupIndexFilter := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"filter":`...)
	w = BuiltinVectorStatshouseApiFilterWriteJSONOpt(tctx, w, item.Filter)
	if (len(item.Filter) != 0) == false {
		w = w[:backupIndexFilter]
	}
	backupIndexTimeShift := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"time_shift":`...)
	w = BuiltinVectorLongWriteJSONOpt(tctx, w, item.TimeShift)
	if (len(item.TimeShift) != 0) == false {
		w = w[:backupIndexTimeShift]
	}
	if item.FieldsMask&(1<<1) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"what":`...)
		w = BuiltinVectorStatshouseApiFunctionWriteJSONOpt(tctx, w, item.What)
	}
	return append(w, '}')
}

func (item *StatshouseApiQueryPoint) MarshalJSON() ([]byte, error) {
	return item.WriteJSON(nil), nil
}

func (item *StatshouseApiQueryPoint) UnmarshalJSON(b []byte) error {
	if err := item.ReadJSON(true, &basictl.JsonLexer{Data: b}); err != nil {
		return ErrorInvalidJSON("statshouseApi.queryPoint", err.Error())
	}
	return nil
}

func (item *StatshouseApiQueryPoint) CalculateLayout(sizes []int, optimizeEmpty bool) ([]int, int) {
	sizes = append(sizes, 3381992379)
	sizePosition := len(sizes)
	sizes = append(sizes, 0)

	currentSize := 1
	lastUsedByte := 0
	var sz int

	if item.FieldsMask != 0 {
		currentSize += 4
		lastUsedByte = currentSize
	}
	if item.Version != 0 {
		currentSize += 4
		lastUsedByte = currentSize
	}
	if item.TopN != 0 {
		currentSize += 4
		lastUsedByte = currentSize
	}
	if len(item.MetricName) != 0 {
		currentSize += basictl.TL2CalculateSize(len(item.MetricName)) + len(item.MetricName)
		lastUsedByte = currentSize
	}
	if item.TimeFrom != 0 {
		currentSize += 8
		lastUsedByte = currentSize
	}
	if item.TimeTo != 0 {
		currentSize += 8
		lastUsedByte = currentSize
	}
	if sizes, sz = item.Function.CalculateLayout(sizes, true); sz != 0 {
		currentSize += sz
		lastUsedByte = currentSize
	}
	currentSize++
	if sizes, sz = BuiltinVectorStringCalculateLayout(sizes, true, &item.GroupBy); sz != 0 {
		currentSize += sz
		lastUsedByte = currentSize
	}
	if sizes, sz = BuiltinVectorStatshouseApiFilterCalculateLayout(sizes, true, &item.Filter); sz != 0 {
		currentSize += sz
		lastUsedByte = currentSize
	}
	if sizes, sz = BuiltinVectorLongCalculateLayout(sizes, true, &item.TimeShift); sz != 0 {
		currentSize += sz
		lastUsedByte = currentSize
	}
	if item.tl2mask0&1 != 0 {
		sizes, sz = BuiltinVectorStatshouseApiFunctionCalculateLayout(sizes, false, &item.What)
		currentSize += sz
		lastUsedByte = currentSize
	}

	if lastUsedByte < currentSize {
		currentSize = lastUsedByte
	}
	sizes[sizePosition] = currentSize
	if currentSize == 0 {
		sizes = sizes[:sizePosition+1]
	}
	if !optimizeEmpty || currentSize != 0 {
		currentSize += basictl.TL2CalculateSize(currentSize)
	}
	Unused(sz)
	return sizes, currentSize
}

func (item *StatshouseApiQueryPoint) InternalWriteTL2(w []byte, sizes []int, optimizeEmpty bool) ([]byte, []int, int) {
	if sizes[0] != 3381992379 {
		panic("tl2: tag mismatch between calculate and write")
	}
	currentSize := sizes[1]
	sizes = sizes[2:]
	if optimizeEmpty && currentSize == 0 {
		return w, sizes, 0
	}
	w = basictl.TL2WriteSize(w, currentSize)
	if currentSize == 0 {
		return w, sizes, 1
	}
	oldLen := len(w)
	var sz int
	var currentBlock byte
	currentBlockPosition := len(w)
	w = append(w, 0)
	if item.FieldsMask != 0 {
		w = basictl.NatWrite(w, item.FieldsMask)
		currentBlock |= 2
	}
	if item.Version != 0 {
		w = basictl.IntWrite(w, item.Version)
		currentBlock |= 4
	}
	if item.TopN != 0 {
		w = basictl.IntWrite(w, item.TopN)
		currentBlock |= 8
	}
	if len(item.MetricName) != 0 {
		w = basictl.StringWriteTL2(w, item.MetricName)
		currentBlock |= 16
	}
	if item.TimeFrom != 0 {
		w = basictl.LongWrite(w, item.TimeFrom)
		currentBlock |= 32
	}
	if item.TimeTo != 0 {
		w = basictl.LongWrite(w, item.TimeTo)
		currentBlock |= 64
	}
	if w, sizes, sz = item.Function.InternalWriteTL2(w, sizes, true); sz != 0 {
		currentBlock |= 128
	}
	if currentBlockPosition < len(w) {
		w[currentBlockPosition] = currentBlock
	}
	currentBlock = 0
	// start the next block
	currentBlockPosition = len(w)
	if len(w)-oldLen < currentSize {
		w = append(w, 0)
	}
	if w, sizes, sz = BuiltinVectorStringInternalWriteTL2(w, sizes, true, &item.GroupBy); sz != 0 {
		currentBlock |= 1
	}
	if w, sizes, sz = BuiltinVectorStatshouseApiFilterInternalWriteTL2(w, sizes, true, &item.Filter); sz != 0 {
		currentBlock |= 2
	}
	if w, sizes, sz = BuiltinVectorLongInternalWriteTL2(w, sizes, true, &item.TimeShift); sz != 0 {
		currentBlock |= 4
	}
	if item.tl2mask0&1 != 0 {
		w, sizes, _ = BuiltinVectorStatshouseApiFunctionInternalWriteTL2(w, sizes, false, &item.What)
		currentBlock |= 8
	}
	if currentBlockPosition < len(w) {
		w[currentBlockPosition] = currentBlock
	}
	if len(w)-oldLen != currentSize {
		panic("tl2: mismatch between calculate and write")
	}
	Unused(sz)
	return w, sizes, 1
}

func (item *StatshouseApiQueryPoint) WriteTL2(w []byte, ctx *basictl.TL2WriteContext) []byte {
	var sizes, sizes2 []int
	if ctx != nil {
		sizes = ctx.SizeBuffer[:0]
	}
	sizes, _ = item.CalculateLayout(sizes, false)
	w, sizes2, _ = item.InternalWriteTL2(w, sizes, false)
	if len(sizes2) != 0 {
		panic("tl2: internal write did not consume all size data")
	}
	if ctx != nil {
		ctx.SizeBuffer = sizes
	}
	return w
}

func (item *StatshouseApiQueryPoint) InternalReadTL2(r []byte) (_ []byte, err error) {
	currentSize := 0
	if r, currentSize, err = basictl.TL2ParseSize(r); err != nil {
		return r, err
	}
	if currentSize == 0 {
		item.Reset()
		return r, nil
	}
	if len(r) < currentSize {
		return r, basictl.TL2Error("not enough data: expected %d, got %d", currentSize, len(r))
	}

	currentR := r[:currentSize]
	r = r[currentSize:]

	var block byte
	if currentR, err = basictl.ByteReadTL2(currentR, &block); err != nil {
		return currentR, err
	}
	// read No of constructor
	if block&1 != 0 {
		var index int
		if currentR, index, err = basictl.TL2ParseSize(currentR); err != nil {
			return currentR, err
		}
		if index != 0 {
			return r, ErrorInvalidUnionIndex("statshouseApi.queryPoint", index)
		}
	}
	item.tl2mask0 = 0
	if block&2 != 0 {
		if currentR, err = basictl.NatRead(currentR, &item.FieldsMask); err != nil {
			return currentR, err
		}
	} else {
		item.FieldsMask = 0
	}
	if block&4 != 0 {
		if currentR, err = basictl.IntRead(currentR, &item.Version); err != nil {
			return currentR, err
		}
	} else {
		item.Version = 0
	}
	if block&8 != 0 {
		if currentR, err = basictl.IntRead(currentR, &item.TopN); err != nil {
			return currentR, err
		}
	} else {
		item.TopN = 0
	}
	if block&16 != 0 {
		if currentR, err = basictl.StringReadTL2(currentR, &item.MetricName); err != nil {
			return currentR, err
		}
	} else {
		item.MetricName = ""
	}
	if block&32 != 0 {
		if currentR, err = basictl.LongRead(currentR, &item.TimeFrom); err != nil {
			return currentR, err
		}
	} else {
		item.TimeFrom = 0
	}
	if block&64 != 0 {
		if currentR, err = basictl.LongRead(currentR, &item.TimeTo); err != nil {
			return currentR, err
		}
	} else {
		item.TimeTo = 0
	}
	if block&128 != 0 {
		if currentR, err = item.Function.InternalReadTL2(currentR); err != nil {
			return currentR, err
		}
	} else {
		item.Function.Reset()
	}
	// start the next block
	if len(currentR) > 0 {
		if currentR, err = basictl.ByteReadTL2(currentR, &block); err != nil {
			return currentR, err
		}
	} else {
		block = 0
	}
	if block&1 != 0 {
		if currentR, err = BuiltinVectorStringInternalReadTL2(currentR, &item.GroupBy); err != nil {
			return currentR, err
		}
	} else {
		item.GroupBy = item.GroupBy[:0]
	}
	if block&2 != 0 {
		if currentR, err = BuiltinVectorStatshouseApiFilterInternalReadTL2(currentR, &item.Filter); err != nil {
			return currentR, err
		}
	} else {
		item.Filter = item.Filter[:0]
	}
	if block&4 != 0 {
		if currentR, err = BuiltinVectorLongInternalReadTL2(currentR, &item.TimeShift); err != nil {
			return currentR, err
		}
	} else {
		item.TimeShift = item.TimeShift[:0]
	}
	if block&8 != 0 {
		item.tl2mask0 |= 1
		if currentR, err = BuiltinVectorStatshouseApiFunctionInternalReadTL2(currentR, &item.What); err != nil {
			return currentR, err
		}
	} else {
		item.What = item.What[:0]
	}
	Unused(currentR)
	return r, nil
}

func (item *StatshouseApiQueryPoint) ReadTL2(r []byte, ctx *basictl.TL2ReadContext) (_ []byte, err error) {
	return item.InternalReadTL2(r)
}
