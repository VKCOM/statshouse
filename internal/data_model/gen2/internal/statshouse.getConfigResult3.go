// Copyright 2025 V Kontakte LLC
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

// Code generated by vktl/cmd/tlgen2; DO NOT EDIT.
package internal

import (
	"github.com/vkcom/statshouse/internal/vkgo/basictl"
)

var _ = basictl.NatWrite

type StatshouseGetConfigResult3 struct {
	Addresses          []string
	ShardByMetricCount uint32
	Unused             [12]int32
	UnusedS            [4]string
}

func (StatshouseGetConfigResult3) TLName() string { return "statshouse.getConfigResult3" }
func (StatshouseGetConfigResult3) TLTag() uint32  { return 0xf13698cb }

func (item *StatshouseGetConfigResult3) Reset() {
	item.Addresses = item.Addresses[:0]
	item.ShardByMetricCount = 0
	BuiltinTuple12IntReset(&item.Unused)
	BuiltinTuple4StringReset(&item.UnusedS)
}

func (item *StatshouseGetConfigResult3) Read(w []byte) (_ []byte, err error) {
	if w, err = BuiltinVectorStringRead(w, &item.Addresses); err != nil {
		return w, err
	}
	if w, err = basictl.NatRead(w, &item.ShardByMetricCount); err != nil {
		return w, err
	}
	if w, err = BuiltinTuple12IntRead(w, &item.Unused); err != nil {
		return w, err
	}
	return BuiltinTuple4StringRead(w, &item.UnusedS)
}

// This method is general version of Write, use it instead!
func (item *StatshouseGetConfigResult3) WriteGeneral(w []byte) (_ []byte, err error) {
	return item.Write(w), nil
}

func (item *StatshouseGetConfigResult3) Write(w []byte) []byte {
	w = BuiltinVectorStringWrite(w, item.Addresses)
	w = basictl.NatWrite(w, item.ShardByMetricCount)
	w = BuiltinTuple12IntWrite(w, &item.Unused)
	w = BuiltinTuple4StringWrite(w, &item.UnusedS)
	return w
}

func (item *StatshouseGetConfigResult3) ReadBoxed(w []byte) (_ []byte, err error) {
	if w, err = basictl.NatReadExactTag(w, 0xf13698cb); err != nil {
		return w, err
	}
	return item.Read(w)
}

// This method is general version of WriteBoxed, use it instead!
func (item *StatshouseGetConfigResult3) WriteBoxedGeneral(w []byte) (_ []byte, err error) {
	return item.WriteBoxed(w), nil
}

func (item *StatshouseGetConfigResult3) WriteBoxed(w []byte) []byte {
	w = basictl.NatWrite(w, 0xf13698cb)
	return item.Write(w)
}

func (item StatshouseGetConfigResult3) String() string {
	return string(item.WriteJSON(nil))
}

func (item *StatshouseGetConfigResult3) ReadJSON(legacyTypeNames bool, in *basictl.JsonLexer) error {
	var propAddressesPresented bool
	var propShardByMetricCountPresented bool
	var propUnusedPresented bool
	var propUnusedSPresented bool

	if in != nil {
		in.Delim('{')
		if !in.Ok() {
			return in.Error()
		}
		for !in.IsDelim('}') {
			key := in.UnsafeFieldName(true)
			in.WantColon()
			switch key {
			case "addresses":
				if propAddressesPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.getConfigResult3", "addresses")
				}
				if err := BuiltinVectorStringReadJSON(legacyTypeNames, in, &item.Addresses); err != nil {
					return err
				}
				propAddressesPresented = true
			case "shard_by_metric_count":
				if propShardByMetricCountPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.getConfigResult3", "shard_by_metric_count")
				}
				if err := Json2ReadUint32(in, &item.ShardByMetricCount); err != nil {
					return err
				}
				propShardByMetricCountPresented = true
			case "unused":
				if propUnusedPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.getConfigResult3", "unused")
				}
				if err := BuiltinTuple12IntReadJSON(legacyTypeNames, in, &item.Unused); err != nil {
					return err
				}
				propUnusedPresented = true
			case "unused_s":
				if propUnusedSPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.getConfigResult3", "unused_s")
				}
				if err := BuiltinTuple4StringReadJSON(legacyTypeNames, in, &item.UnusedS); err != nil {
					return err
				}
				propUnusedSPresented = true
			default:
				return ErrorInvalidJSONExcessElement("statshouse.getConfigResult3", key)
			}
			in.WantComma()
		}
		in.Delim('}')
		if !in.Ok() {
			return in.Error()
		}
	}
	if !propAddressesPresented {
		item.Addresses = item.Addresses[:0]
	}
	if !propShardByMetricCountPresented {
		item.ShardByMetricCount = 0
	}
	if !propUnusedPresented {
		BuiltinTuple12IntReset(&item.Unused)
	}
	if !propUnusedSPresented {
		BuiltinTuple4StringReset(&item.UnusedS)
	}
	return nil
}

// This method is general version of WriteJSON, use it instead!
func (item *StatshouseGetConfigResult3) WriteJSONGeneral(w []byte) (_ []byte, err error) {
	return item.WriteJSONOpt(true, false, w), nil
}

func (item *StatshouseGetConfigResult3) WriteJSON(w []byte) []byte {
	return item.WriteJSONOpt(true, false, w)
}
func (item *StatshouseGetConfigResult3) WriteJSONOpt(newTypeNames bool, short bool, w []byte) []byte {
	w = append(w, '{')
	backupIndexAddresses := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"addresses":`...)
	w = BuiltinVectorStringWriteJSONOpt(newTypeNames, short, w, item.Addresses)
	if (len(item.Addresses) != 0) == false {
		w = w[:backupIndexAddresses]
	}
	backupIndexShardByMetricCount := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"shard_by_metric_count":`...)
	w = basictl.JSONWriteUint32(w, item.ShardByMetricCount)
	if (item.ShardByMetricCount != 0) == false {
		w = w[:backupIndexShardByMetricCount]
	}
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"unused":`...)
	w = BuiltinTuple12IntWriteJSONOpt(newTypeNames, short, w, &item.Unused)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"unused_s":`...)
	w = BuiltinTuple4StringWriteJSONOpt(newTypeNames, short, w, &item.UnusedS)
	return append(w, '}')
}

func (item *StatshouseGetConfigResult3) MarshalJSON() ([]byte, error) {
	return item.WriteJSON(nil), nil
}

func (item *StatshouseGetConfigResult3) UnmarshalJSON(b []byte) error {
	if err := item.ReadJSON(true, &basictl.JsonLexer{Data: b}); err != nil {
		return ErrorInvalidJSON("statshouse.getConfigResult3", err.Error())
	}
	return nil
}

type StatshouseGetConfigResult3Bytes struct {
	Addresses          [][]byte
	ShardByMetricCount uint32
	Unused             [12]int32
	UnusedS            [4][]byte
}

func (StatshouseGetConfigResult3Bytes) TLName() string { return "statshouse.getConfigResult3" }
func (StatshouseGetConfigResult3Bytes) TLTag() uint32  { return 0xf13698cb }

func (item *StatshouseGetConfigResult3Bytes) Reset() {
	item.Addresses = item.Addresses[:0]
	item.ShardByMetricCount = 0
	BuiltinTuple12IntReset(&item.Unused)
	BuiltinTuple4StringBytesReset(&item.UnusedS)
}

func (item *StatshouseGetConfigResult3Bytes) Read(w []byte) (_ []byte, err error) {
	if w, err = BuiltinVectorStringBytesRead(w, &item.Addresses); err != nil {
		return w, err
	}
	if w, err = basictl.NatRead(w, &item.ShardByMetricCount); err != nil {
		return w, err
	}
	if w, err = BuiltinTuple12IntRead(w, &item.Unused); err != nil {
		return w, err
	}
	return BuiltinTuple4StringBytesRead(w, &item.UnusedS)
}

// This method is general version of Write, use it instead!
func (item *StatshouseGetConfigResult3Bytes) WriteGeneral(w []byte) (_ []byte, err error) {
	return item.Write(w), nil
}

func (item *StatshouseGetConfigResult3Bytes) Write(w []byte) []byte {
	w = BuiltinVectorStringBytesWrite(w, item.Addresses)
	w = basictl.NatWrite(w, item.ShardByMetricCount)
	w = BuiltinTuple12IntWrite(w, &item.Unused)
	w = BuiltinTuple4StringBytesWrite(w, &item.UnusedS)
	return w
}

func (item *StatshouseGetConfigResult3Bytes) ReadBoxed(w []byte) (_ []byte, err error) {
	if w, err = basictl.NatReadExactTag(w, 0xf13698cb); err != nil {
		return w, err
	}
	return item.Read(w)
}

// This method is general version of WriteBoxed, use it instead!
func (item *StatshouseGetConfigResult3Bytes) WriteBoxedGeneral(w []byte) (_ []byte, err error) {
	return item.WriteBoxed(w), nil
}

func (item *StatshouseGetConfigResult3Bytes) WriteBoxed(w []byte) []byte {
	w = basictl.NatWrite(w, 0xf13698cb)
	return item.Write(w)
}

func (item StatshouseGetConfigResult3Bytes) String() string {
	return string(item.WriteJSON(nil))
}

func (item *StatshouseGetConfigResult3Bytes) ReadJSON(legacyTypeNames bool, in *basictl.JsonLexer) error {
	var propAddressesPresented bool
	var propShardByMetricCountPresented bool
	var propUnusedPresented bool
	var propUnusedSPresented bool

	if in != nil {
		in.Delim('{')
		if !in.Ok() {
			return in.Error()
		}
		for !in.IsDelim('}') {
			key := in.UnsafeFieldName(true)
			in.WantColon()
			switch key {
			case "addresses":
				if propAddressesPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.getConfigResult3", "addresses")
				}
				if err := BuiltinVectorStringBytesReadJSON(legacyTypeNames, in, &item.Addresses); err != nil {
					return err
				}
				propAddressesPresented = true
			case "shard_by_metric_count":
				if propShardByMetricCountPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.getConfigResult3", "shard_by_metric_count")
				}
				if err := Json2ReadUint32(in, &item.ShardByMetricCount); err != nil {
					return err
				}
				propShardByMetricCountPresented = true
			case "unused":
				if propUnusedPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.getConfigResult3", "unused")
				}
				if err := BuiltinTuple12IntReadJSON(legacyTypeNames, in, &item.Unused); err != nil {
					return err
				}
				propUnusedPresented = true
			case "unused_s":
				if propUnusedSPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.getConfigResult3", "unused_s")
				}
				if err := BuiltinTuple4StringBytesReadJSON(legacyTypeNames, in, &item.UnusedS); err != nil {
					return err
				}
				propUnusedSPresented = true
			default:
				return ErrorInvalidJSONExcessElement("statshouse.getConfigResult3", key)
			}
			in.WantComma()
		}
		in.Delim('}')
		if !in.Ok() {
			return in.Error()
		}
	}
	if !propAddressesPresented {
		item.Addresses = item.Addresses[:0]
	}
	if !propShardByMetricCountPresented {
		item.ShardByMetricCount = 0
	}
	if !propUnusedPresented {
		BuiltinTuple12IntReset(&item.Unused)
	}
	if !propUnusedSPresented {
		BuiltinTuple4StringBytesReset(&item.UnusedS)
	}
	return nil
}

// This method is general version of WriteJSON, use it instead!
func (item *StatshouseGetConfigResult3Bytes) WriteJSONGeneral(w []byte) (_ []byte, err error) {
	return item.WriteJSONOpt(true, false, w), nil
}

func (item *StatshouseGetConfigResult3Bytes) WriteJSON(w []byte) []byte {
	return item.WriteJSONOpt(true, false, w)
}
func (item *StatshouseGetConfigResult3Bytes) WriteJSONOpt(newTypeNames bool, short bool, w []byte) []byte {
	w = append(w, '{')
	backupIndexAddresses := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"addresses":`...)
	w = BuiltinVectorStringBytesWriteJSONOpt(newTypeNames, short, w, item.Addresses)
	if (len(item.Addresses) != 0) == false {
		w = w[:backupIndexAddresses]
	}
	backupIndexShardByMetricCount := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"shard_by_metric_count":`...)
	w = basictl.JSONWriteUint32(w, item.ShardByMetricCount)
	if (item.ShardByMetricCount != 0) == false {
		w = w[:backupIndexShardByMetricCount]
	}
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"unused":`...)
	w = BuiltinTuple12IntWriteJSONOpt(newTypeNames, short, w, &item.Unused)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"unused_s":`...)
	w = BuiltinTuple4StringBytesWriteJSONOpt(newTypeNames, short, w, &item.UnusedS)
	return append(w, '}')
}

func (item *StatshouseGetConfigResult3Bytes) MarshalJSON() ([]byte, error) {
	return item.WriteJSON(nil), nil
}

func (item *StatshouseGetConfigResult3Bytes) UnmarshalJSON(b []byte) error {
	if err := item.ReadJSON(true, &basictl.JsonLexer{Data: b}); err != nil {
		return ErrorInvalidJSON("statshouse.getConfigResult3", err.Error())
	}
	return nil
}
