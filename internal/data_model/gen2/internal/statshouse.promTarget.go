// Copyright 2025 V Kontakte LLC
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

// Code generated by vktl/cmd/tlgen2; DO NOT EDIT.
package internal

import (
	"github.com/VKCOM/statshouse/internal/vkgo/basictl"
)

var _ = basictl.NatWrite

func BuiltinVectorStatshousePromTargetFillRandom(rg *basictl.RandGenerator, vec *[]StatshousePromTarget, nat_t uint32) {
	rg.IncreaseDepth()
	l := basictl.RandomSize(rg)
	*vec = make([]StatshousePromTarget, l)
	for i := range *vec {
		(*vec)[i].FillRandom(rg, nat_t)
	}
	rg.DecreaseDepth()
}
func BuiltinVectorStatshousePromTargetRead(w []byte, vec *[]StatshousePromTarget, nat_t uint32) (_ []byte, err error) {
	var l uint32
	if w, err = basictl.NatRead(w, &l); err != nil {
		return w, err
	}
	if err = basictl.CheckLengthSanity(w, l, 4); err != nil {
		return w, err
	}
	if uint32(cap(*vec)) < l {
		*vec = make([]StatshousePromTarget, l)
	} else {
		*vec = (*vec)[:l]
	}
	for i := range *vec {
		if w, err = (*vec)[i].Read(w, nat_t); err != nil {
			return w, err
		}
	}
	return w, nil
}

func BuiltinVectorStatshousePromTargetWrite(w []byte, vec []StatshousePromTarget, nat_t uint32) []byte {
	w = basictl.NatWrite(w, uint32(len(vec)))
	for _, elem := range vec {
		w = elem.Write(w, nat_t)
	}
	return w
}

func BuiltinVectorStatshousePromTargetInternalReadTL2(r []byte, vec *[]StatshousePromTarget) (_ []byte, err error) {
	return r, ErrorTL2SerializersNotGenerated("[]StatshousePromTarget")
}

func BuiltinVectorStatshousePromTargetReadJSONGeneral(tctx *basictl.JSONReadContext, in *basictl.JsonLexer, vec *[]StatshousePromTarget, nat_t uint32) error {
	*vec = (*vec)[:cap(*vec)]
	index := 0
	if in != nil {
		in.Delim('[')
		if !in.Ok() {
			return ErrorInvalidJSON("[]StatshousePromTarget", "expected json array")
		}
		for ; !in.IsDelim(']'); index++ {
			if len(*vec) <= index {
				var newValue StatshousePromTarget
				*vec = append(*vec, newValue)
				*vec = (*vec)[:cap(*vec)]
			}
			if err := (*vec)[index].ReadJSONGeneral(tctx, in, nat_t); err != nil {
				return err
			}
			in.WantComma()
		}
		in.Delim(']')
		if !in.Ok() {
			return ErrorInvalidJSON("[]StatshousePromTarget", "expected json array's end")
		}
	}
	*vec = (*vec)[:index]
	return nil
}

func BuiltinVectorStatshousePromTargetWriteJSON(w []byte, vec []StatshousePromTarget, nat_t uint32) []byte {
	tctx := basictl.JSONWriteContext{}
	return BuiltinVectorStatshousePromTargetWriteJSONOpt(&tctx, w, vec, nat_t)
}
func BuiltinVectorStatshousePromTargetWriteJSONOpt(tctx *basictl.JSONWriteContext, w []byte, vec []StatshousePromTarget, nat_t uint32) []byte {
	w = append(w, '[')
	for _, elem := range vec {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = elem.WriteJSONOpt(tctx, w, nat_t)
	}
	return append(w, ']')
}

func BuiltinVectorStatshousePromTargetBytesFillRandom(rg *basictl.RandGenerator, vec *[]StatshousePromTargetBytes, nat_t uint32) {
	rg.IncreaseDepth()
	l := basictl.RandomSize(rg)
	*vec = make([]StatshousePromTargetBytes, l)
	for i := range *vec {
		(*vec)[i].FillRandom(rg, nat_t)
	}
	rg.DecreaseDepth()
}
func BuiltinVectorStatshousePromTargetBytesRead(w []byte, vec *[]StatshousePromTargetBytes, nat_t uint32) (_ []byte, err error) {
	var l uint32
	if w, err = basictl.NatRead(w, &l); err != nil {
		return w, err
	}
	if err = basictl.CheckLengthSanity(w, l, 4); err != nil {
		return w, err
	}
	if uint32(cap(*vec)) < l {
		*vec = make([]StatshousePromTargetBytes, l)
	} else {
		*vec = (*vec)[:l]
	}
	for i := range *vec {
		if w, err = (*vec)[i].Read(w, nat_t); err != nil {
			return w, err
		}
	}
	return w, nil
}

func BuiltinVectorStatshousePromTargetBytesWrite(w []byte, vec []StatshousePromTargetBytes, nat_t uint32) []byte {
	w = basictl.NatWrite(w, uint32(len(vec)))
	for _, elem := range vec {
		w = elem.Write(w, nat_t)
	}
	return w
}

func BuiltinVectorStatshousePromTargetBytesInternalReadTL2(r []byte, vec *[]StatshousePromTargetBytes) (_ []byte, err error) {
	return r, ErrorTL2SerializersNotGenerated("[]StatshousePromTargetBytes")
}

func BuiltinVectorStatshousePromTargetBytesReadJSONGeneral(tctx *basictl.JSONReadContext, in *basictl.JsonLexer, vec *[]StatshousePromTargetBytes, nat_t uint32) error {
	*vec = (*vec)[:cap(*vec)]
	index := 0
	if in != nil {
		in.Delim('[')
		if !in.Ok() {
			return ErrorInvalidJSON("[]StatshousePromTargetBytes", "expected json array")
		}
		for ; !in.IsDelim(']'); index++ {
			if len(*vec) <= index {
				var newValue StatshousePromTargetBytes
				*vec = append(*vec, newValue)
				*vec = (*vec)[:cap(*vec)]
			}
			if err := (*vec)[index].ReadJSONGeneral(tctx, in, nat_t); err != nil {
				return err
			}
			in.WantComma()
		}
		in.Delim(']')
		if !in.Ok() {
			return ErrorInvalidJSON("[]StatshousePromTargetBytes", "expected json array's end")
		}
	}
	*vec = (*vec)[:index]
	return nil
}

func BuiltinVectorStatshousePromTargetBytesWriteJSON(w []byte, vec []StatshousePromTargetBytes, nat_t uint32) []byte {
	tctx := basictl.JSONWriteContext{}
	return BuiltinVectorStatshousePromTargetBytesWriteJSONOpt(&tctx, w, vec, nat_t)
}
func BuiltinVectorStatshousePromTargetBytesWriteJSONOpt(tctx *basictl.JSONWriteContext, w []byte, vec []StatshousePromTargetBytes, nat_t uint32) []byte {
	w = append(w, '[')
	for _, elem := range vec {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = elem.WriteJSONOpt(tctx, w, nat_t)
	}
	return append(w, ']')
}

type StatshousePromTarget struct {
	FieldsMask     uint32
	JobName        string
	Url            string
	Labels         map[string]string
	ScrapeInterval int64
	// HonorTimestamps (TrueType) // Conditional: item.FieldsMask.0
	// HonorLabels (TrueType) // Conditional: item.FieldsMask.1
	ScrapeTimeout         int64
	BodySizeLimit         int64
	LabelLimit            int64
	LabelNameLengthLimit  int64
	LabelValueLengthLimit int64
	HttpClientConfig      string
	MetricRelabelConfigs  string // Conditional: nat_fields_mask_arg.1
}

func (StatshousePromTarget) TLName() string { return "statshouse.promTarget" }
func (StatshousePromTarget) TLTag() uint32  { return 0xac5296df }

func (item *StatshousePromTarget) SetHonorTimestamps(v bool) {
	if v {
		item.FieldsMask |= 1 << 0
	} else {
		item.FieldsMask &^= 1 << 0
	}
}
func (item *StatshousePromTarget) IsSetHonorTimestamps() bool { return item.FieldsMask&(1<<0) != 0 }

func (item *StatshousePromTarget) SetHonorLabels(v bool) {
	if v {
		item.FieldsMask |= 1 << 1
	} else {
		item.FieldsMask &^= 1 << 1
	}
}
func (item *StatshousePromTarget) IsSetHonorLabels() bool { return item.FieldsMask&(1<<1) != 0 }

func (item *StatshousePromTarget) SetMetricRelabelConfigs(v string, nat_fields_mask_arg *uint32) {
	item.MetricRelabelConfigs = v
	if nat_fields_mask_arg != nil {
		*nat_fields_mask_arg |= 1 << 1
	}
}
func (item *StatshousePromTarget) ClearMetricRelabelConfigs(nat_fields_mask_arg *uint32) {
	item.MetricRelabelConfigs = ""
	if nat_fields_mask_arg != nil {
		*nat_fields_mask_arg &^= 1 << 1
	}
}
func (item *StatshousePromTarget) IsSetMetricRelabelConfigs(nat_fields_mask_arg uint32) bool {
	return nat_fields_mask_arg&(1<<1) != 0
}

func (item *StatshousePromTarget) Reset() {
	item.FieldsMask = 0
	item.JobName = ""
	item.Url = ""
	BuiltinVectorDictionaryFieldStringReset(item.Labels)
	item.ScrapeInterval = 0
	item.ScrapeTimeout = 0
	item.BodySizeLimit = 0
	item.LabelLimit = 0
	item.LabelNameLengthLimit = 0
	item.LabelValueLengthLimit = 0
	item.HttpClientConfig = ""
	item.MetricRelabelConfigs = ""
}

func (item *StatshousePromTarget) FillRandom(rg *basictl.RandGenerator, nat_fields_mask_arg uint32) {
	item.FieldsMask = basictl.RandomFieldMask(rg, 0b11)
	item.JobName = basictl.RandomString(rg)
	item.Url = basictl.RandomString(rg)
	BuiltinVectorDictionaryFieldStringFillRandom(rg, &item.Labels)
	item.ScrapeInterval = basictl.RandomLong(rg)
	item.ScrapeTimeout = basictl.RandomLong(rg)
	item.BodySizeLimit = basictl.RandomLong(rg)
	item.LabelLimit = basictl.RandomLong(rg)
	item.LabelNameLengthLimit = basictl.RandomLong(rg)
	item.LabelValueLengthLimit = basictl.RandomLong(rg)
	item.HttpClientConfig = basictl.RandomString(rg)
	if nat_fields_mask_arg&(1<<1) != 0 {
		item.MetricRelabelConfigs = basictl.RandomString(rg)
	} else {
		item.MetricRelabelConfigs = ""
	}
}

func (item *StatshousePromTarget) Read(w []byte, nat_fields_mask_arg uint32) (_ []byte, err error) {
	if w, err = basictl.NatRead(w, &item.FieldsMask); err != nil {
		return w, err
	}
	if w, err = basictl.StringRead(w, &item.JobName); err != nil {
		return w, err
	}
	if w, err = basictl.StringRead(w, &item.Url); err != nil {
		return w, err
	}
	if w, err = BuiltinVectorDictionaryFieldStringRead(w, &item.Labels); err != nil {
		return w, err
	}
	if w, err = basictl.LongRead(w, &item.ScrapeInterval); err != nil {
		return w, err
	}
	if w, err = basictl.LongRead(w, &item.ScrapeTimeout); err != nil {
		return w, err
	}
	if w, err = basictl.LongRead(w, &item.BodySizeLimit); err != nil {
		return w, err
	}
	if w, err = basictl.LongRead(w, &item.LabelLimit); err != nil {
		return w, err
	}
	if w, err = basictl.LongRead(w, &item.LabelNameLengthLimit); err != nil {
		return w, err
	}
	if w, err = basictl.LongRead(w, &item.LabelValueLengthLimit); err != nil {
		return w, err
	}
	if w, err = basictl.StringRead(w, &item.HttpClientConfig); err != nil {
		return w, err
	}
	if nat_fields_mask_arg&(1<<1) != 0 {
		if w, err = basictl.StringRead(w, &item.MetricRelabelConfigs); err != nil {
			return w, err
		}
	} else {
		item.MetricRelabelConfigs = ""
	}
	return w, nil
}

func (item *StatshousePromTarget) WriteGeneral(w []byte, nat_fields_mask_arg uint32) (_ []byte, err error) {
	return item.Write(w, nat_fields_mask_arg), nil
}

func (item *StatshousePromTarget) Write(w []byte, nat_fields_mask_arg uint32) []byte {
	w = basictl.NatWrite(w, item.FieldsMask)
	w = basictl.StringWrite(w, item.JobName)
	w = basictl.StringWrite(w, item.Url)
	w = BuiltinVectorDictionaryFieldStringWrite(w, item.Labels)
	w = basictl.LongWrite(w, item.ScrapeInterval)
	w = basictl.LongWrite(w, item.ScrapeTimeout)
	w = basictl.LongWrite(w, item.BodySizeLimit)
	w = basictl.LongWrite(w, item.LabelLimit)
	w = basictl.LongWrite(w, item.LabelNameLengthLimit)
	w = basictl.LongWrite(w, item.LabelValueLengthLimit)
	w = basictl.StringWrite(w, item.HttpClientConfig)
	if nat_fields_mask_arg&(1<<1) != 0 {
		w = basictl.StringWrite(w, item.MetricRelabelConfigs)
	}
	return w
}

func (item *StatshousePromTarget) ReadBoxed(w []byte, nat_fields_mask_arg uint32) (_ []byte, err error) {
	if w, err = basictl.NatReadExactTag(w, 0xac5296df); err != nil {
		return w, err
	}
	return item.Read(w, nat_fields_mask_arg)
}

func (item *StatshousePromTarget) WriteBoxedGeneral(w []byte, nat_fields_mask_arg uint32) (_ []byte, err error) {
	return item.WriteBoxed(w, nat_fields_mask_arg), nil
}

func (item *StatshousePromTarget) WriteBoxed(w []byte, nat_fields_mask_arg uint32) []byte {
	w = basictl.NatWrite(w, 0xac5296df)
	return item.Write(w, nat_fields_mask_arg)
}

func (item *StatshousePromTarget) ReadJSONGeneral(tctx *basictl.JSONReadContext, in *basictl.JsonLexer, nat_fields_mask_arg uint32) error {
	var propFieldsMaskPresented bool
	var propJobNamePresented bool
	var propUrlPresented bool
	var propLabelsPresented bool
	var propScrapeIntervalPresented bool
	var trueTypeHonorTimestampsPresented bool
	var trueTypeHonorTimestampsValue bool
	var trueTypeHonorLabelsPresented bool
	var trueTypeHonorLabelsValue bool
	var propScrapeTimeoutPresented bool
	var propBodySizeLimitPresented bool
	var propLabelLimitPresented bool
	var propLabelNameLengthLimitPresented bool
	var propLabelValueLengthLimitPresented bool
	var propHttpClientConfigPresented bool
	var propMetricRelabelConfigsPresented bool

	if in != nil {
		in.Delim('{')
		if !in.Ok() {
			return in.Error()
		}
		for !in.IsDelim('}') {
			key := in.UnsafeFieldName(true)
			in.WantColon()
			switch key {
			case "fields_mask":
				if propFieldsMaskPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.promTarget", "fields_mask")
				}
				if err := Json2ReadUint32(in, &item.FieldsMask); err != nil {
					return err
				}
				propFieldsMaskPresented = true
			case "job_name":
				if propJobNamePresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.promTarget", "job_name")
				}
				if err := Json2ReadString(in, &item.JobName); err != nil {
					return err
				}
				propJobNamePresented = true
			case "url":
				if propUrlPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.promTarget", "url")
				}
				if err := Json2ReadString(in, &item.Url); err != nil {
					return err
				}
				propUrlPresented = true
			case "labels":
				if propLabelsPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.promTarget", "labels")
				}
				if err := BuiltinVectorDictionaryFieldStringReadJSONGeneral(tctx, in, &item.Labels); err != nil {
					return err
				}
				propLabelsPresented = true
			case "scrape_interval":
				if propScrapeIntervalPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.promTarget", "scrape_interval")
				}
				if err := Json2ReadInt64(in, &item.ScrapeInterval); err != nil {
					return err
				}
				propScrapeIntervalPresented = true
			case "honor_timestamps":
				if trueTypeHonorTimestampsPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.promTarget", "honor_timestamps")
				}
				if err := Json2ReadBool(in, &trueTypeHonorTimestampsValue); err != nil {
					return err
				}
				trueTypeHonorTimestampsPresented = true
			case "honor_labels":
				if trueTypeHonorLabelsPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.promTarget", "honor_labels")
				}
				if err := Json2ReadBool(in, &trueTypeHonorLabelsValue); err != nil {
					return err
				}
				trueTypeHonorLabelsPresented = true
			case "scrape_timeout":
				if propScrapeTimeoutPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.promTarget", "scrape_timeout")
				}
				if err := Json2ReadInt64(in, &item.ScrapeTimeout); err != nil {
					return err
				}
				propScrapeTimeoutPresented = true
			case "body_size_limit":
				if propBodySizeLimitPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.promTarget", "body_size_limit")
				}
				if err := Json2ReadInt64(in, &item.BodySizeLimit); err != nil {
					return err
				}
				propBodySizeLimitPresented = true
			case "label_limit":
				if propLabelLimitPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.promTarget", "label_limit")
				}
				if err := Json2ReadInt64(in, &item.LabelLimit); err != nil {
					return err
				}
				propLabelLimitPresented = true
			case "label_name_length_limit":
				if propLabelNameLengthLimitPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.promTarget", "label_name_length_limit")
				}
				if err := Json2ReadInt64(in, &item.LabelNameLengthLimit); err != nil {
					return err
				}
				propLabelNameLengthLimitPresented = true
			case "label_value_length_limit":
				if propLabelValueLengthLimitPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.promTarget", "label_value_length_limit")
				}
				if err := Json2ReadInt64(in, &item.LabelValueLengthLimit); err != nil {
					return err
				}
				propLabelValueLengthLimitPresented = true
			case "http_client_config":
				if propHttpClientConfigPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.promTarget", "http_client_config")
				}
				if err := Json2ReadString(in, &item.HttpClientConfig); err != nil {
					return err
				}
				propHttpClientConfigPresented = true
			case "metric_relabel_configs":
				if propMetricRelabelConfigsPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.promTarget", "metric_relabel_configs")
				}
				if nat_fields_mask_arg&(1<<1) == 0 {
					return ErrorInvalidJSON("statshouse.promTarget", "field 'metric_relabel_configs' is defined, while corresponding implicit fieldmask bit is 0")
				}
				if err := Json2ReadString(in, &item.MetricRelabelConfigs); err != nil {
					return err
				}
				propMetricRelabelConfigsPresented = true
			default:
				return ErrorInvalidJSONExcessElement("statshouse.promTarget", key)
			}
			in.WantComma()
		}
		in.Delim('}')
		if !in.Ok() {
			return in.Error()
		}
	}
	if !propFieldsMaskPresented {
		item.FieldsMask = 0
	}
	if !propJobNamePresented {
		item.JobName = ""
	}
	if !propUrlPresented {
		item.Url = ""
	}
	if !propLabelsPresented {
		BuiltinVectorDictionaryFieldStringReset(item.Labels)
	}
	if !propScrapeIntervalPresented {
		item.ScrapeInterval = 0
	}
	if !propScrapeTimeoutPresented {
		item.ScrapeTimeout = 0
	}
	if !propBodySizeLimitPresented {
		item.BodySizeLimit = 0
	}
	if !propLabelLimitPresented {
		item.LabelLimit = 0
	}
	if !propLabelNameLengthLimitPresented {
		item.LabelNameLengthLimit = 0
	}
	if !propLabelValueLengthLimitPresented {
		item.LabelValueLengthLimit = 0
	}
	if !propHttpClientConfigPresented {
		item.HttpClientConfig = ""
	}
	if !propMetricRelabelConfigsPresented {
		item.MetricRelabelConfigs = ""
	}
	if trueTypeHonorTimestampsPresented {
		if trueTypeHonorTimestampsValue {
			item.FieldsMask |= 1 << 0
		}
	}
	if trueTypeHonorLabelsPresented {
		if trueTypeHonorLabelsValue {
			item.FieldsMask |= 1 << 1
		}
	}
	// tries to set bit to zero if it is 1
	if trueTypeHonorTimestampsPresented && !trueTypeHonorTimestampsValue && (item.FieldsMask&(1<<0) != 0) {
		return ErrorInvalidJSON("statshouse.promTarget", "fieldmask bit item.FieldsMask.0 is indefinite because of the contradictions in values")
	}
	// tries to set bit to zero if it is 1
	if trueTypeHonorLabelsPresented && !trueTypeHonorLabelsValue && (item.FieldsMask&(1<<1) != 0) {
		return ErrorInvalidJSON("statshouse.promTarget", "fieldmask bit item.FieldsMask.1 is indefinite because of the contradictions in values")
	}
	return nil
}

// This method is general version of WriteJSON, use it instead!
func (item *StatshousePromTarget) WriteJSONGeneral(tctx *basictl.JSONWriteContext, w []byte, nat_fields_mask_arg uint32) (_ []byte, err error) {
	return item.WriteJSONOpt(tctx, w, nat_fields_mask_arg), nil
}

func (item *StatshousePromTarget) WriteJSON(w []byte, nat_fields_mask_arg uint32) []byte {
	tctx := basictl.JSONWriteContext{}
	return item.WriteJSONOpt(&tctx, w, nat_fields_mask_arg)
}
func (item *StatshousePromTarget) WriteJSONOpt(tctx *basictl.JSONWriteContext, w []byte, nat_fields_mask_arg uint32) []byte {
	w = append(w, '{')
	backupIndexFieldsMask := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"fields_mask":`...)
	w = basictl.JSONWriteUint32(w, item.FieldsMask)
	if (item.FieldsMask != 0) == false {
		w = w[:backupIndexFieldsMask]
	}
	backupIndexJobName := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"job_name":`...)
	w = basictl.JSONWriteString(w, item.JobName)
	if (len(item.JobName) != 0) == false {
		w = w[:backupIndexJobName]
	}
	backupIndexUrl := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"url":`...)
	w = basictl.JSONWriteString(w, item.Url)
	if (len(item.Url) != 0) == false {
		w = w[:backupIndexUrl]
	}
	backupIndexLabels := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"labels":`...)
	w = BuiltinVectorDictionaryFieldStringWriteJSONOpt(tctx, w, item.Labels)
	if (len(item.Labels) != 0) == false {
		w = w[:backupIndexLabels]
	}
	backupIndexScrapeInterval := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"scrape_interval":`...)
	w = basictl.JSONWriteInt64(w, item.ScrapeInterval)
	if (item.ScrapeInterval != 0) == false {
		w = w[:backupIndexScrapeInterval]
	}
	if item.FieldsMask&(1<<0) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"honor_timestamps":true`...)
	}
	if item.FieldsMask&(1<<1) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"honor_labels":true`...)
	}
	backupIndexScrapeTimeout := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"scrape_timeout":`...)
	w = basictl.JSONWriteInt64(w, item.ScrapeTimeout)
	if (item.ScrapeTimeout != 0) == false {
		w = w[:backupIndexScrapeTimeout]
	}
	backupIndexBodySizeLimit := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"body_size_limit":`...)
	w = basictl.JSONWriteInt64(w, item.BodySizeLimit)
	if (item.BodySizeLimit != 0) == false {
		w = w[:backupIndexBodySizeLimit]
	}
	backupIndexLabelLimit := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"label_limit":`...)
	w = basictl.JSONWriteInt64(w, item.LabelLimit)
	if (item.LabelLimit != 0) == false {
		w = w[:backupIndexLabelLimit]
	}
	backupIndexLabelNameLengthLimit := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"label_name_length_limit":`...)
	w = basictl.JSONWriteInt64(w, item.LabelNameLengthLimit)
	if (item.LabelNameLengthLimit != 0) == false {
		w = w[:backupIndexLabelNameLengthLimit]
	}
	backupIndexLabelValueLengthLimit := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"label_value_length_limit":`...)
	w = basictl.JSONWriteInt64(w, item.LabelValueLengthLimit)
	if (item.LabelValueLengthLimit != 0) == false {
		w = w[:backupIndexLabelValueLengthLimit]
	}
	backupIndexHttpClientConfig := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"http_client_config":`...)
	w = basictl.JSONWriteString(w, item.HttpClientConfig)
	if (len(item.HttpClientConfig) != 0) == false {
		w = w[:backupIndexHttpClientConfig]
	}
	if nat_fields_mask_arg&(1<<1) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"metric_relabel_configs":`...)
		w = basictl.JSONWriteString(w, item.MetricRelabelConfigs)
	}
	return append(w, '}')
}

func (item *StatshousePromTarget) WriteTL2(w []byte, ctx *basictl.TL2WriteContext) []byte {
	return w
}

func (item *StatshousePromTarget) ReadTL2(r []byte, ctx *basictl.TL2ReadContext) (_ []byte, err error) {
	return r, ErrorTL2SerializersNotGenerated("statshouse.promTarget")
}

type StatshousePromTargetBytes struct {
	FieldsMask     uint32
	JobName        []byte
	Url            []byte
	Labels         []DictionaryFieldStringBytes
	ScrapeInterval int64
	// HonorTimestamps (TrueType) // Conditional: item.FieldsMask.0
	// HonorLabels (TrueType) // Conditional: item.FieldsMask.1
	ScrapeTimeout         int64
	BodySizeLimit         int64
	LabelLimit            int64
	LabelNameLengthLimit  int64
	LabelValueLengthLimit int64
	HttpClientConfig      []byte
	MetricRelabelConfigs  []byte // Conditional: nat_fields_mask_arg.1
}

func (StatshousePromTargetBytes) TLName() string { return "statshouse.promTarget" }
func (StatshousePromTargetBytes) TLTag() uint32  { return 0xac5296df }

func (item *StatshousePromTargetBytes) SetHonorTimestamps(v bool) {
	if v {
		item.FieldsMask |= 1 << 0
	} else {
		item.FieldsMask &^= 1 << 0
	}
}
func (item *StatshousePromTargetBytes) IsSetHonorTimestamps() bool {
	return item.FieldsMask&(1<<0) != 0
}

func (item *StatshousePromTargetBytes) SetHonorLabels(v bool) {
	if v {
		item.FieldsMask |= 1 << 1
	} else {
		item.FieldsMask &^= 1 << 1
	}
}
func (item *StatshousePromTargetBytes) IsSetHonorLabels() bool { return item.FieldsMask&(1<<1) != 0 }

func (item *StatshousePromTargetBytes) SetMetricRelabelConfigs(v []byte, nat_fields_mask_arg *uint32) {
	item.MetricRelabelConfigs = v
	if nat_fields_mask_arg != nil {
		*nat_fields_mask_arg |= 1 << 1
	}
}
func (item *StatshousePromTargetBytes) ClearMetricRelabelConfigs(nat_fields_mask_arg *uint32) {
	item.MetricRelabelConfigs = item.MetricRelabelConfigs[:0]
	if nat_fields_mask_arg != nil {
		*nat_fields_mask_arg &^= 1 << 1
	}
}
func (item *StatshousePromTargetBytes) IsSetMetricRelabelConfigs(nat_fields_mask_arg uint32) bool {
	return nat_fields_mask_arg&(1<<1) != 0
}

func (item *StatshousePromTargetBytes) Reset() {
	item.FieldsMask = 0
	item.JobName = item.JobName[:0]
	item.Url = item.Url[:0]
	item.Labels = item.Labels[:0]
	item.ScrapeInterval = 0
	item.ScrapeTimeout = 0
	item.BodySizeLimit = 0
	item.LabelLimit = 0
	item.LabelNameLengthLimit = 0
	item.LabelValueLengthLimit = 0
	item.HttpClientConfig = item.HttpClientConfig[:0]
	item.MetricRelabelConfigs = item.MetricRelabelConfigs[:0]
}

func (item *StatshousePromTargetBytes) FillRandom(rg *basictl.RandGenerator, nat_fields_mask_arg uint32) {
	item.FieldsMask = basictl.RandomFieldMask(rg, 0b11)
	item.JobName = basictl.RandomStringBytes(rg)
	item.Url = basictl.RandomStringBytes(rg)
	BuiltinVectorDictionaryFieldStringBytesFillRandom(rg, &item.Labels)
	item.ScrapeInterval = basictl.RandomLong(rg)
	item.ScrapeTimeout = basictl.RandomLong(rg)
	item.BodySizeLimit = basictl.RandomLong(rg)
	item.LabelLimit = basictl.RandomLong(rg)
	item.LabelNameLengthLimit = basictl.RandomLong(rg)
	item.LabelValueLengthLimit = basictl.RandomLong(rg)
	item.HttpClientConfig = basictl.RandomStringBytes(rg)
	if nat_fields_mask_arg&(1<<1) != 0 {
		item.MetricRelabelConfigs = basictl.RandomStringBytes(rg)
	} else {
		item.MetricRelabelConfigs = item.MetricRelabelConfigs[:0]
	}
}

func (item *StatshousePromTargetBytes) Read(w []byte, nat_fields_mask_arg uint32) (_ []byte, err error) {
	if w, err = basictl.NatRead(w, &item.FieldsMask); err != nil {
		return w, err
	}
	if w, err = basictl.StringReadBytes(w, &item.JobName); err != nil {
		return w, err
	}
	if w, err = basictl.StringReadBytes(w, &item.Url); err != nil {
		return w, err
	}
	if w, err = BuiltinVectorDictionaryFieldStringBytesRead(w, &item.Labels); err != nil {
		return w, err
	}
	if w, err = basictl.LongRead(w, &item.ScrapeInterval); err != nil {
		return w, err
	}
	if w, err = basictl.LongRead(w, &item.ScrapeTimeout); err != nil {
		return w, err
	}
	if w, err = basictl.LongRead(w, &item.BodySizeLimit); err != nil {
		return w, err
	}
	if w, err = basictl.LongRead(w, &item.LabelLimit); err != nil {
		return w, err
	}
	if w, err = basictl.LongRead(w, &item.LabelNameLengthLimit); err != nil {
		return w, err
	}
	if w, err = basictl.LongRead(w, &item.LabelValueLengthLimit); err != nil {
		return w, err
	}
	if w, err = basictl.StringReadBytes(w, &item.HttpClientConfig); err != nil {
		return w, err
	}
	if nat_fields_mask_arg&(1<<1) != 0 {
		if w, err = basictl.StringReadBytes(w, &item.MetricRelabelConfigs); err != nil {
			return w, err
		}
	} else {
		item.MetricRelabelConfigs = item.MetricRelabelConfigs[:0]
	}
	return w, nil
}

func (item *StatshousePromTargetBytes) WriteGeneral(w []byte, nat_fields_mask_arg uint32) (_ []byte, err error) {
	return item.Write(w, nat_fields_mask_arg), nil
}

func (item *StatshousePromTargetBytes) Write(w []byte, nat_fields_mask_arg uint32) []byte {
	w = basictl.NatWrite(w, item.FieldsMask)
	w = basictl.StringWriteBytes(w, item.JobName)
	w = basictl.StringWriteBytes(w, item.Url)
	w = BuiltinVectorDictionaryFieldStringBytesWrite(w, item.Labels)
	w = basictl.LongWrite(w, item.ScrapeInterval)
	w = basictl.LongWrite(w, item.ScrapeTimeout)
	w = basictl.LongWrite(w, item.BodySizeLimit)
	w = basictl.LongWrite(w, item.LabelLimit)
	w = basictl.LongWrite(w, item.LabelNameLengthLimit)
	w = basictl.LongWrite(w, item.LabelValueLengthLimit)
	w = basictl.StringWriteBytes(w, item.HttpClientConfig)
	if nat_fields_mask_arg&(1<<1) != 0 {
		w = basictl.StringWriteBytes(w, item.MetricRelabelConfigs)
	}
	return w
}

func (item *StatshousePromTargetBytes) ReadBoxed(w []byte, nat_fields_mask_arg uint32) (_ []byte, err error) {
	if w, err = basictl.NatReadExactTag(w, 0xac5296df); err != nil {
		return w, err
	}
	return item.Read(w, nat_fields_mask_arg)
}

func (item *StatshousePromTargetBytes) WriteBoxedGeneral(w []byte, nat_fields_mask_arg uint32) (_ []byte, err error) {
	return item.WriteBoxed(w, nat_fields_mask_arg), nil
}

func (item *StatshousePromTargetBytes) WriteBoxed(w []byte, nat_fields_mask_arg uint32) []byte {
	w = basictl.NatWrite(w, 0xac5296df)
	return item.Write(w, nat_fields_mask_arg)
}

func (item *StatshousePromTargetBytes) ReadJSONGeneral(tctx *basictl.JSONReadContext, in *basictl.JsonLexer, nat_fields_mask_arg uint32) error {
	var propFieldsMaskPresented bool
	var propJobNamePresented bool
	var propUrlPresented bool
	var propLabelsPresented bool
	var propScrapeIntervalPresented bool
	var trueTypeHonorTimestampsPresented bool
	var trueTypeHonorTimestampsValue bool
	var trueTypeHonorLabelsPresented bool
	var trueTypeHonorLabelsValue bool
	var propScrapeTimeoutPresented bool
	var propBodySizeLimitPresented bool
	var propLabelLimitPresented bool
	var propLabelNameLengthLimitPresented bool
	var propLabelValueLengthLimitPresented bool
	var propHttpClientConfigPresented bool
	var propMetricRelabelConfigsPresented bool

	if in != nil {
		in.Delim('{')
		if !in.Ok() {
			return in.Error()
		}
		for !in.IsDelim('}') {
			key := in.UnsafeFieldName(true)
			in.WantColon()
			switch key {
			case "fields_mask":
				if propFieldsMaskPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.promTarget", "fields_mask")
				}
				if err := Json2ReadUint32(in, &item.FieldsMask); err != nil {
					return err
				}
				propFieldsMaskPresented = true
			case "job_name":
				if propJobNamePresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.promTarget", "job_name")
				}
				if err := Json2ReadStringBytes(in, &item.JobName); err != nil {
					return err
				}
				propJobNamePresented = true
			case "url":
				if propUrlPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.promTarget", "url")
				}
				if err := Json2ReadStringBytes(in, &item.Url); err != nil {
					return err
				}
				propUrlPresented = true
			case "labels":
				if propLabelsPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.promTarget", "labels")
				}
				if err := BuiltinVectorDictionaryFieldStringBytesReadJSONGeneral(tctx, in, &item.Labels); err != nil {
					return err
				}
				propLabelsPresented = true
			case "scrape_interval":
				if propScrapeIntervalPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.promTarget", "scrape_interval")
				}
				if err := Json2ReadInt64(in, &item.ScrapeInterval); err != nil {
					return err
				}
				propScrapeIntervalPresented = true
			case "honor_timestamps":
				if trueTypeHonorTimestampsPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.promTarget", "honor_timestamps")
				}
				if err := Json2ReadBool(in, &trueTypeHonorTimestampsValue); err != nil {
					return err
				}
				trueTypeHonorTimestampsPresented = true
			case "honor_labels":
				if trueTypeHonorLabelsPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.promTarget", "honor_labels")
				}
				if err := Json2ReadBool(in, &trueTypeHonorLabelsValue); err != nil {
					return err
				}
				trueTypeHonorLabelsPresented = true
			case "scrape_timeout":
				if propScrapeTimeoutPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.promTarget", "scrape_timeout")
				}
				if err := Json2ReadInt64(in, &item.ScrapeTimeout); err != nil {
					return err
				}
				propScrapeTimeoutPresented = true
			case "body_size_limit":
				if propBodySizeLimitPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.promTarget", "body_size_limit")
				}
				if err := Json2ReadInt64(in, &item.BodySizeLimit); err != nil {
					return err
				}
				propBodySizeLimitPresented = true
			case "label_limit":
				if propLabelLimitPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.promTarget", "label_limit")
				}
				if err := Json2ReadInt64(in, &item.LabelLimit); err != nil {
					return err
				}
				propLabelLimitPresented = true
			case "label_name_length_limit":
				if propLabelNameLengthLimitPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.promTarget", "label_name_length_limit")
				}
				if err := Json2ReadInt64(in, &item.LabelNameLengthLimit); err != nil {
					return err
				}
				propLabelNameLengthLimitPresented = true
			case "label_value_length_limit":
				if propLabelValueLengthLimitPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.promTarget", "label_value_length_limit")
				}
				if err := Json2ReadInt64(in, &item.LabelValueLengthLimit); err != nil {
					return err
				}
				propLabelValueLengthLimitPresented = true
			case "http_client_config":
				if propHttpClientConfigPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.promTarget", "http_client_config")
				}
				if err := Json2ReadStringBytes(in, &item.HttpClientConfig); err != nil {
					return err
				}
				propHttpClientConfigPresented = true
			case "metric_relabel_configs":
				if propMetricRelabelConfigsPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("statshouse.promTarget", "metric_relabel_configs")
				}
				if nat_fields_mask_arg&(1<<1) == 0 {
					return ErrorInvalidJSON("statshouse.promTarget", "field 'metric_relabel_configs' is defined, while corresponding implicit fieldmask bit is 0")
				}
				if err := Json2ReadStringBytes(in, &item.MetricRelabelConfigs); err != nil {
					return err
				}
				propMetricRelabelConfigsPresented = true
			default:
				return ErrorInvalidJSONExcessElement("statshouse.promTarget", key)
			}
			in.WantComma()
		}
		in.Delim('}')
		if !in.Ok() {
			return in.Error()
		}
	}
	if !propFieldsMaskPresented {
		item.FieldsMask = 0
	}
	if !propJobNamePresented {
		item.JobName = item.JobName[:0]
	}
	if !propUrlPresented {
		item.Url = item.Url[:0]
	}
	if !propLabelsPresented {
		item.Labels = item.Labels[:0]
	}
	if !propScrapeIntervalPresented {
		item.ScrapeInterval = 0
	}
	if !propScrapeTimeoutPresented {
		item.ScrapeTimeout = 0
	}
	if !propBodySizeLimitPresented {
		item.BodySizeLimit = 0
	}
	if !propLabelLimitPresented {
		item.LabelLimit = 0
	}
	if !propLabelNameLengthLimitPresented {
		item.LabelNameLengthLimit = 0
	}
	if !propLabelValueLengthLimitPresented {
		item.LabelValueLengthLimit = 0
	}
	if !propHttpClientConfigPresented {
		item.HttpClientConfig = item.HttpClientConfig[:0]
	}
	if !propMetricRelabelConfigsPresented {
		item.MetricRelabelConfigs = item.MetricRelabelConfigs[:0]
	}
	if trueTypeHonorTimestampsPresented {
		if trueTypeHonorTimestampsValue {
			item.FieldsMask |= 1 << 0
		}
	}
	if trueTypeHonorLabelsPresented {
		if trueTypeHonorLabelsValue {
			item.FieldsMask |= 1 << 1
		}
	}
	// tries to set bit to zero if it is 1
	if trueTypeHonorTimestampsPresented && !trueTypeHonorTimestampsValue && (item.FieldsMask&(1<<0) != 0) {
		return ErrorInvalidJSON("statshouse.promTarget", "fieldmask bit item.FieldsMask.0 is indefinite because of the contradictions in values")
	}
	// tries to set bit to zero if it is 1
	if trueTypeHonorLabelsPresented && !trueTypeHonorLabelsValue && (item.FieldsMask&(1<<1) != 0) {
		return ErrorInvalidJSON("statshouse.promTarget", "fieldmask bit item.FieldsMask.1 is indefinite because of the contradictions in values")
	}
	return nil
}

// This method is general version of WriteJSON, use it instead!
func (item *StatshousePromTargetBytes) WriteJSONGeneral(tctx *basictl.JSONWriteContext, w []byte, nat_fields_mask_arg uint32) (_ []byte, err error) {
	return item.WriteJSONOpt(tctx, w, nat_fields_mask_arg), nil
}

func (item *StatshousePromTargetBytes) WriteJSON(w []byte, nat_fields_mask_arg uint32) []byte {
	tctx := basictl.JSONWriteContext{}
	return item.WriteJSONOpt(&tctx, w, nat_fields_mask_arg)
}
func (item *StatshousePromTargetBytes) WriteJSONOpt(tctx *basictl.JSONWriteContext, w []byte, nat_fields_mask_arg uint32) []byte {
	w = append(w, '{')
	backupIndexFieldsMask := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"fields_mask":`...)
	w = basictl.JSONWriteUint32(w, item.FieldsMask)
	if (item.FieldsMask != 0) == false {
		w = w[:backupIndexFieldsMask]
	}
	backupIndexJobName := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"job_name":`...)
	w = basictl.JSONWriteStringBytes(w, item.JobName)
	if (len(item.JobName) != 0) == false {
		w = w[:backupIndexJobName]
	}
	backupIndexUrl := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"url":`...)
	w = basictl.JSONWriteStringBytes(w, item.Url)
	if (len(item.Url) != 0) == false {
		w = w[:backupIndexUrl]
	}
	backupIndexLabels := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"labels":`...)
	w = BuiltinVectorDictionaryFieldStringBytesWriteJSONOpt(tctx, w, item.Labels)
	if (len(item.Labels) != 0) == false {
		w = w[:backupIndexLabels]
	}
	backupIndexScrapeInterval := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"scrape_interval":`...)
	w = basictl.JSONWriteInt64(w, item.ScrapeInterval)
	if (item.ScrapeInterval != 0) == false {
		w = w[:backupIndexScrapeInterval]
	}
	if item.FieldsMask&(1<<0) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"honor_timestamps":true`...)
	}
	if item.FieldsMask&(1<<1) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"honor_labels":true`...)
	}
	backupIndexScrapeTimeout := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"scrape_timeout":`...)
	w = basictl.JSONWriteInt64(w, item.ScrapeTimeout)
	if (item.ScrapeTimeout != 0) == false {
		w = w[:backupIndexScrapeTimeout]
	}
	backupIndexBodySizeLimit := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"body_size_limit":`...)
	w = basictl.JSONWriteInt64(w, item.BodySizeLimit)
	if (item.BodySizeLimit != 0) == false {
		w = w[:backupIndexBodySizeLimit]
	}
	backupIndexLabelLimit := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"label_limit":`...)
	w = basictl.JSONWriteInt64(w, item.LabelLimit)
	if (item.LabelLimit != 0) == false {
		w = w[:backupIndexLabelLimit]
	}
	backupIndexLabelNameLengthLimit := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"label_name_length_limit":`...)
	w = basictl.JSONWriteInt64(w, item.LabelNameLengthLimit)
	if (item.LabelNameLengthLimit != 0) == false {
		w = w[:backupIndexLabelNameLengthLimit]
	}
	backupIndexLabelValueLengthLimit := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"label_value_length_limit":`...)
	w = basictl.JSONWriteInt64(w, item.LabelValueLengthLimit)
	if (item.LabelValueLengthLimit != 0) == false {
		w = w[:backupIndexLabelValueLengthLimit]
	}
	backupIndexHttpClientConfig := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"http_client_config":`...)
	w = basictl.JSONWriteStringBytes(w, item.HttpClientConfig)
	if (len(item.HttpClientConfig) != 0) == false {
		w = w[:backupIndexHttpClientConfig]
	}
	if nat_fields_mask_arg&(1<<1) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"metric_relabel_configs":`...)
		w = basictl.JSONWriteStringBytes(w, item.MetricRelabelConfigs)
	}
	return append(w, '}')
}

func (item *StatshousePromTargetBytes) WriteTL2(w []byte, ctx *basictl.TL2WriteContext) []byte {
	return w
}

func (item *StatshousePromTargetBytes) ReadTL2(r []byte, ctx *basictl.TL2ReadContext) (_ []byte, err error) {
	return r, ErrorTL2SerializersNotGenerated("statshouse.promTarget")
}
