// Copyright 2025 V Kontakte LLC
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

// Code generated by vktl/cmd/tlgen2; DO NOT EDIT.
package tlstatshouseApi

import (
	"context"
	"time"

	"github.com/VKCOM/statshouse/internal/data_model/gen2/internal"
	"github.com/VKCOM/statshouse/internal/vkgo/basictl"
	"github.com/VKCOM/statshouse/internal/vkgo/rpc"
)

type (
	Filter                        = internal.StatshouseApiFilter
	Flag                          = internal.StatshouseApiFlag
	Function                      = internal.StatshouseApiFunction
	GetChunk                      = internal.StatshouseApiGetChunk
	GetChunkResponse              = internal.StatshouseApiGetChunkResponse
	GetMapping                    = internal.StatshouseApiGetMapping
	GetMappingResponse            = internal.StatshouseApiGetMappingResponse
	GetQuery                      = internal.StatshouseApiGetQuery
	GetQueryPoint                 = internal.StatshouseApiGetQueryPoint
	GetQueryPointResponse         = internal.StatshouseApiGetQueryPointResponse
	GetQueryResponse              = internal.StatshouseApiGetQueryResponse
	PointMeta                     = internal.StatshouseApiPointMeta
	Query                         = internal.StatshouseApiQuery
	QueryPoint                    = internal.StatshouseApiQueryPoint
	ReleaseChunks                 = internal.StatshouseApiReleaseChunks
	ReleaseChunksResponse         = internal.StatshouseApiReleaseChunksResponse
	Series                        = internal.StatshouseApiSeries
	SeriesMeta                    = internal.StatshouseApiSeriesMeta
	TagValue                      = internal.StatshouseApiTagValue
	VectorStatshouseApiFilter     = internal.VectorStatshouseApiFilter
	VectorStatshouseApiFunction   = internal.VectorStatshouseApiFunction
	VectorStatshouseApiPointMeta  = internal.VectorStatshouseApiPointMeta
	VectorStatshouseApiSeriesMeta = internal.VectorStatshouseApiSeriesMeta
	VectorStatshouseApiTagValue   = internal.VectorStatshouseApiTagValue
)

func FlagAuto() Flag                   { return internal.StatshouseApiFlagAuto() }
func FlagMapped() Flag                 { return internal.StatshouseApiFlagMapped() }
func FlagRaw() Flag                    { return internal.StatshouseApiFlagRaw() }
func FnAvg() Function                  { return internal.StatshouseApiFnAvg() }
func FnCount() Function                { return internal.StatshouseApiFnCount() }
func FnCountNorm() Function            { return internal.StatshouseApiFnCountNorm() }
func FnCumulAvg() Function             { return internal.StatshouseApiFnCumulAvg() }
func FnCumulCount() Function           { return internal.StatshouseApiFnCumulCount() }
func FnCumulSum() Function             { return internal.StatshouseApiFnCumulSum() }
func FnDerivativeAvg() Function        { return internal.StatshouseApiFnDerivativeAvg() }
func FnDerivativeCount() Function      { return internal.StatshouseApiFnDerivativeCount() }
func FnDerivativeCountNorm() Function  { return internal.StatshouseApiFnDerivativeCountNorm() }
func FnDerivativeMax() Function        { return internal.StatshouseApiFnDerivativeMax() }
func FnDerivativeMin() Function        { return internal.StatshouseApiFnDerivativeMin() }
func FnDerivativeSum() Function        { return internal.StatshouseApiFnDerivativeSum() }
func FnDerivativeSumNorm() Function    { return internal.StatshouseApiFnDerivativeSumNorm() }
func FnDerivativeUnique() Function     { return internal.StatshouseApiFnDerivativeUnique() }
func FnDerivativeUniqueNorm() Function { return internal.StatshouseApiFnDerivativeUniqueNorm() }
func FnMax() Function                  { return internal.StatshouseApiFnMax() }
func FnMaxCountHost() Function         { return internal.StatshouseApiFnMaxCountHost() }
func FnMaxHost() Function              { return internal.StatshouseApiFnMaxHost() }
func FnMin() Function                  { return internal.StatshouseApiFnMin() }
func FnP01() Function                  { return internal.StatshouseApiFnP01() }
func FnP1() Function                   { return internal.StatshouseApiFnP1() }
func FnP10() Function                  { return internal.StatshouseApiFnP10() }
func FnP25() Function                  { return internal.StatshouseApiFnP25() }
func FnP5() Function                   { return internal.StatshouseApiFnP5() }
func FnP50() Function                  { return internal.StatshouseApiFnP50() }
func FnP75() Function                  { return internal.StatshouseApiFnP75() }
func FnP90() Function                  { return internal.StatshouseApiFnP90() }
func FnP95() Function                  { return internal.StatshouseApiFnP95() }
func FnP99() Function                  { return internal.StatshouseApiFnP99() }
func FnP999() Function                 { return internal.StatshouseApiFnP999() }
func FnStddev() Function               { return internal.StatshouseApiFnStddev() }
func FnSum() Function                  { return internal.StatshouseApiFnSum() }
func FnSumNorm() Function              { return internal.StatshouseApiFnSumNorm() }
func FnUnique() Function               { return internal.StatshouseApiFnUnique() }
func FnUniqueNorm() Function           { return internal.StatshouseApiFnUniqueNorm() }

type Client struct {
	Client  rpc.Client
	Network string // should be either "tcp4" or "unix"
	Address string
	ActorID int64         // should be >0 for routing via rpc-proxy
	Timeout time.Duration // set to extra.CustomTimeoutMs, if not already set
}

func (c *Client) GetChunk(ctx context.Context, args GetChunk, extra *rpc.InvokeReqExtra, ret *GetChunkResponse) (err error) {
	req := c.Client.GetRequest()
	req.ActorID = c.ActorID
	req.ReadOnly = true
	req.FunctionName = "statshouseApi.getChunk"
	if extra != nil {
		req.Extra = extra.RequestExtra
		req.FailIfNoConnection = extra.FailIfNoConnection
		if extra.PreferTL2 {
			req.BodyFormatTL2 = true
		}
	}
	rpc.UpdateExtraTimeout(&req.Extra, c.Timeout)
	if req.BodyFormatTL2 {
		req.Body = basictl.NatWrite(req.Body, args.TLTag())
		tctx := basictl.TL2WriteContext{}
		req.Body = args.WriteTL2(req.Body, &tctx)
	} else {
		req.Body, err = args.WriteBoxedGeneral(req.Body)
		if err != nil {
			return internal.ErrorClientWrite("statshouseApi.getChunk", err)
		}
	}
	resp, err := c.Client.Do(ctx, c.Network, c.Address, req)
	if extra != nil && resp != nil {
		extra.ResponseExtra = resp.Extra
	}
	defer c.Client.PutResponse(resp)
	if err != nil {
		return internal.ErrorClientDo("statshouseApi.getChunk", c.Network, c.ActorID, c.Address, err)
	}
	if ret != nil {
		if resp.BodyFormatTL2() {
			tctx := basictl.TL2ReadContext{}
			resp.Body, err = args.ReadResultTL2(resp.Body, &tctx, ret)
		} else {
			resp.Body, err = args.ReadResult(resp.Body, ret)
		}
		if err != nil {
			return internal.ErrorClientReadResult("statshouseApi.getChunk", c.Network, c.ActorID, c.Address, err)
		}
	}
	return nil
}

func (c *Client) GetMapping(ctx context.Context, args GetMapping, extra *rpc.InvokeReqExtra, ret *GetMappingResponse) (err error) {
	req := c.Client.GetRequest()
	req.ActorID = c.ActorID
	req.FunctionName = "statshouseApi.getMapping"
	if extra != nil {
		req.Extra = extra.RequestExtra
		req.FailIfNoConnection = extra.FailIfNoConnection
		if extra.PreferTL2 {
			req.BodyFormatTL2 = true
		}
	}
	rpc.UpdateExtraTimeout(&req.Extra, c.Timeout)
	if req.BodyFormatTL2 {
		req.Body = basictl.NatWrite(req.Body, args.TLTag())
		tctx := basictl.TL2WriteContext{}
		req.Body = args.WriteTL2(req.Body, &tctx)
	} else {
		req.Body, err = args.WriteBoxedGeneral(req.Body)
		if err != nil {
			return internal.ErrorClientWrite("statshouseApi.getMapping", err)
		}
	}
	resp, err := c.Client.Do(ctx, c.Network, c.Address, req)
	if extra != nil && resp != nil {
		extra.ResponseExtra = resp.Extra
	}
	defer c.Client.PutResponse(resp)
	if err != nil {
		return internal.ErrorClientDo("statshouseApi.getMapping", c.Network, c.ActorID, c.Address, err)
	}
	if ret != nil {
		if resp.BodyFormatTL2() {
			tctx := basictl.TL2ReadContext{}
			resp.Body, err = args.ReadResultTL2(resp.Body, &tctx, ret)
		} else {
			resp.Body, err = args.ReadResult(resp.Body, ret)
		}
		if err != nil {
			return internal.ErrorClientReadResult("statshouseApi.getMapping", c.Network, c.ActorID, c.Address, err)
		}
	}
	return nil
}

func (c *Client) GetQuery(ctx context.Context, args GetQuery, extra *rpc.InvokeReqExtra, ret *GetQueryResponse) (err error) {
	req := c.Client.GetRequest()
	req.ActorID = c.ActorID
	req.FunctionName = "statshouseApi.getQuery"
	if extra != nil {
		req.Extra = extra.RequestExtra
		req.FailIfNoConnection = extra.FailIfNoConnection
		if extra.PreferTL2 {
			req.BodyFormatTL2 = true
		}
	}
	rpc.UpdateExtraTimeout(&req.Extra, c.Timeout)
	if req.BodyFormatTL2 {
		req.Body = basictl.NatWrite(req.Body, args.TLTag())
		tctx := basictl.TL2WriteContext{}
		req.Body = args.WriteTL2(req.Body, &tctx)
	} else {
		req.Body, err = args.WriteBoxedGeneral(req.Body)
		if err != nil {
			return internal.ErrorClientWrite("statshouseApi.getQuery", err)
		}
	}
	resp, err := c.Client.Do(ctx, c.Network, c.Address, req)
	if extra != nil && resp != nil {
		extra.ResponseExtra = resp.Extra
	}
	defer c.Client.PutResponse(resp)
	if err != nil {
		return internal.ErrorClientDo("statshouseApi.getQuery", c.Network, c.ActorID, c.Address, err)
	}
	if ret != nil {
		if resp.BodyFormatTL2() {
			tctx := basictl.TL2ReadContext{}
			resp.Body, err = args.ReadResultTL2(resp.Body, &tctx, ret)
		} else {
			resp.Body, err = args.ReadResult(resp.Body, ret)
		}
		if err != nil {
			return internal.ErrorClientReadResult("statshouseApi.getQuery", c.Network, c.ActorID, c.Address, err)
		}
	}
	return nil
}

func (c *Client) GetQueryPoint(ctx context.Context, args GetQueryPoint, extra *rpc.InvokeReqExtra, ret *GetQueryPointResponse) (err error) {
	req := c.Client.GetRequest()
	req.ActorID = c.ActorID
	req.ReadOnly = true
	req.FunctionName = "statshouseApi.getQueryPoint"
	if extra != nil {
		req.Extra = extra.RequestExtra
		req.FailIfNoConnection = extra.FailIfNoConnection
		if extra.PreferTL2 {
			req.BodyFormatTL2 = true
		}
	}
	rpc.UpdateExtraTimeout(&req.Extra, c.Timeout)
	if req.BodyFormatTL2 {
		req.Body = basictl.NatWrite(req.Body, args.TLTag())
		tctx := basictl.TL2WriteContext{}
		req.Body = args.WriteTL2(req.Body, &tctx)
	} else {
		req.Body, err = args.WriteBoxedGeneral(req.Body)
		if err != nil {
			return internal.ErrorClientWrite("statshouseApi.getQueryPoint", err)
		}
	}
	resp, err := c.Client.Do(ctx, c.Network, c.Address, req)
	if extra != nil && resp != nil {
		extra.ResponseExtra = resp.Extra
	}
	defer c.Client.PutResponse(resp)
	if err != nil {
		return internal.ErrorClientDo("statshouseApi.getQueryPoint", c.Network, c.ActorID, c.Address, err)
	}
	if ret != nil {
		if resp.BodyFormatTL2() {
			tctx := basictl.TL2ReadContext{}
			resp.Body, err = args.ReadResultTL2(resp.Body, &tctx, ret)
		} else {
			resp.Body, err = args.ReadResult(resp.Body, ret)
		}
		if err != nil {
			return internal.ErrorClientReadResult("statshouseApi.getQueryPoint", c.Network, c.ActorID, c.Address, err)
		}
	}
	return nil
}

func (c *Client) ReleaseChunks(ctx context.Context, args ReleaseChunks, extra *rpc.InvokeReqExtra, ret *ReleaseChunksResponse) (err error) {
	req := c.Client.GetRequest()
	req.ActorID = c.ActorID
	req.FunctionName = "statshouseApi.releaseChunks"
	if extra != nil {
		req.Extra = extra.RequestExtra
		req.FailIfNoConnection = extra.FailIfNoConnection
		if extra.PreferTL2 {
			req.BodyFormatTL2 = true
		}
	}
	rpc.UpdateExtraTimeout(&req.Extra, c.Timeout)
	if req.BodyFormatTL2 {
		req.Body = basictl.NatWrite(req.Body, args.TLTag())
		tctx := basictl.TL2WriteContext{}
		req.Body = args.WriteTL2(req.Body, &tctx)
	} else {
		req.Body, err = args.WriteBoxedGeneral(req.Body)
		if err != nil {
			return internal.ErrorClientWrite("statshouseApi.releaseChunks", err)
		}
	}
	resp, err := c.Client.Do(ctx, c.Network, c.Address, req)
	if extra != nil && resp != nil {
		extra.ResponseExtra = resp.Extra
	}
	defer c.Client.PutResponse(resp)
	if err != nil {
		return internal.ErrorClientDo("statshouseApi.releaseChunks", c.Network, c.ActorID, c.Address, err)
	}
	if ret != nil {
		if resp.BodyFormatTL2() {
			tctx := basictl.TL2ReadContext{}
			resp.Body, err = args.ReadResultTL2(resp.Body, &tctx, ret)
		} else {
			resp.Body, err = args.ReadResult(resp.Body, ret)
		}
		if err != nil {
			return internal.ErrorClientReadResult("statshouseApi.releaseChunks", c.Network, c.ActorID, c.Address, err)
		}
	}
	return nil
}

type Handler struct {
	GetChunk      func(ctx context.Context, args GetChunk) (GetChunkResponse, error)           // statshouseApi.getChunk
	GetMapping    func(ctx context.Context, args GetMapping) (GetMappingResponse, error)       // statshouseApi.getMapping
	GetQuery      func(ctx context.Context, args GetQuery) (GetQueryResponse, error)           // statshouseApi.getQuery
	GetQueryPoint func(ctx context.Context, args GetQueryPoint) (GetQueryPointResponse, error) // statshouseApi.getQueryPoint
	ReleaseChunks func(ctx context.Context, args ReleaseChunks) (ReleaseChunksResponse, error) // statshouseApi.releaseChunks

}

func (h *Handler) Handle(ctx context.Context, hctx *rpc.HandlerContext) (err error) {
	tag, r, _ := basictl.NatReadTag(hctx.Request) // keep hctx.Request intact for handler chaining
	switch tag {
	case 0x52721884: // statshouseApi.getChunk
		hctx.SetRequestFunctionName("statshouseApi.getChunk")
		if h.GetChunk != nil {
			var args GetChunk
			if hctx.BodyFormatTL2() {
				tctx := basictl.TL2ReadContext{}
				_, err = args.ReadTL2(r, &tctx)
			} else {
				_, err = args.Read(r)
			}
			if err != nil {
				return internal.ErrorServerRead("statshouseApi.getChunk", err)
			}
			ctx = hctx.WithContext(ctx)
			ret, err := h.GetChunk(ctx, args)
			if hctx.LongpollStarted() || rpc.IsLongpollResponse(err) {
				return err
			}
			if err != nil {
				return internal.ErrorServerHandle("statshouseApi.getChunk", err)
			}
			if hctx.BodyFormatTL2() {
				tctx := basictl.TL2WriteContext{}
				hctx.Response, err = args.WriteResultTL2(hctx.Response, &tctx, ret)
			} else {
				hctx.Response, err = args.WriteResult(hctx.Response, ret)
			}
			if err != nil {
				return internal.ErrorServerWriteResult("statshouseApi.getChunk", err)
			}
			return nil
		}
	case 0x4239a8f8: // statshouseApi.getMapping
		hctx.SetRequestFunctionName("statshouseApi.getMapping")
		if h.GetMapping != nil {
			var args GetMapping
			if hctx.BodyFormatTL2() {
				tctx := basictl.TL2ReadContext{}
				_, err = args.ReadTL2(r, &tctx)
			} else {
				_, err = args.Read(r)
			}
			if err != nil {
				return internal.ErrorServerRead("statshouseApi.getMapping", err)
			}
			ctx = hctx.WithContext(ctx)
			ret, err := h.GetMapping(ctx, args)
			if hctx.LongpollStarted() || rpc.IsLongpollResponse(err) {
				return err
			}
			if err != nil {
				return internal.ErrorServerHandle("statshouseApi.getMapping", err)
			}
			if hctx.BodyFormatTL2() {
				tctx := basictl.TL2WriteContext{}
				hctx.Response, err = args.WriteResultTL2(hctx.Response, &tctx, ret)
			} else {
				hctx.Response, err = args.WriteResult(hctx.Response, ret)
			}
			if err != nil {
				return internal.ErrorServerWriteResult("statshouseApi.getMapping", err)
			}
			return nil
		}
	case 0x0c7349bb: // statshouseApi.getQuery
		hctx.SetRequestFunctionName("statshouseApi.getQuery")
		if h.GetQuery != nil {
			var args GetQuery
			if hctx.BodyFormatTL2() {
				tctx := basictl.TL2ReadContext{}
				_, err = args.ReadTL2(r, &tctx)
			} else {
				_, err = args.Read(r)
			}
			if err != nil {
				return internal.ErrorServerRead("statshouseApi.getQuery", err)
			}
			ctx = hctx.WithContext(ctx)
			ret, err := h.GetQuery(ctx, args)
			if hctx.LongpollStarted() || rpc.IsLongpollResponse(err) {
				return err
			}
			if err != nil {
				return internal.ErrorServerHandle("statshouseApi.getQuery", err)
			}
			if hctx.BodyFormatTL2() {
				tctx := basictl.TL2WriteContext{}
				hctx.Response, err = args.WriteResultTL2(hctx.Response, &tctx, ret)
			} else {
				hctx.Response, err = args.WriteResult(hctx.Response, ret)
			}
			if err != nil {
				return internal.ErrorServerWriteResult("statshouseApi.getQuery", err)
			}
			return nil
		}
	case 0x0c7348bb: // statshouseApi.getQueryPoint
		hctx.SetRequestFunctionName("statshouseApi.getQueryPoint")
		if h.GetQueryPoint != nil {
			var args GetQueryPoint
			if hctx.BodyFormatTL2() {
				tctx := basictl.TL2ReadContext{}
				_, err = args.ReadTL2(r, &tctx)
			} else {
				_, err = args.Read(r)
			}
			if err != nil {
				return internal.ErrorServerRead("statshouseApi.getQueryPoint", err)
			}
			ctx = hctx.WithContext(ctx)
			ret, err := h.GetQueryPoint(ctx, args)
			if hctx.LongpollStarted() || rpc.IsLongpollResponse(err) {
				return err
			}
			if err != nil {
				return internal.ErrorServerHandle("statshouseApi.getQueryPoint", err)
			}
			if hctx.BodyFormatTL2() {
				tctx := basictl.TL2WriteContext{}
				hctx.Response, err = args.WriteResultTL2(hctx.Response, &tctx, ret)
			} else {
				hctx.Response, err = args.WriteResult(hctx.Response, ret)
			}
			if err != nil {
				return internal.ErrorServerWriteResult("statshouseApi.getQueryPoint", err)
			}
			return nil
		}
	case 0x62adc773: // statshouseApi.releaseChunks
		hctx.SetRequestFunctionName("statshouseApi.releaseChunks")
		if h.ReleaseChunks != nil {
			var args ReleaseChunks
			if hctx.BodyFormatTL2() {
				tctx := basictl.TL2ReadContext{}
				_, err = args.ReadTL2(r, &tctx)
			} else {
				_, err = args.Read(r)
			}
			if err != nil {
				return internal.ErrorServerRead("statshouseApi.releaseChunks", err)
			}
			ctx = hctx.WithContext(ctx)
			ret, err := h.ReleaseChunks(ctx, args)
			if hctx.LongpollStarted() || rpc.IsLongpollResponse(err) {
				return err
			}
			if err != nil {
				return internal.ErrorServerHandle("statshouseApi.releaseChunks", err)
			}
			if hctx.BodyFormatTL2() {
				tctx := basictl.TL2WriteContext{}
				hctx.Response, err = args.WriteResultTL2(hctx.Response, &tctx, ret)
			} else {
				hctx.Response, err = args.WriteResult(hctx.Response, ret)
			}
			if err != nil {
				return internal.ErrorServerWriteResult("statshouseApi.releaseChunks", err)
			}
			return nil
		}
	}
	return rpc.ErrNoHandler
}
