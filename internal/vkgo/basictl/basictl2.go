// Copyright 2025 V Kontakte LLC
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

// Code generated by vktl/cmd/tlgen2; DO NOT EDIT.
package basictl

import (
	"encoding/binary"
	"fmt"
	"io"
	"math"
)

type TL2WriteContext struct {
	// buffer for allocations of objects sizes
	SizeBuffer []int
}

type TL2ReadContext struct{}

func TL2UnexpectedByteError(actualByte, expectedByte byte) error {
	return fmt.Errorf("unexpected byte %d, expected: %d", actualByte, expectedByte)
}

func TL2ExpectedZeroError() error {
	return fmt.Errorf("expected zero value")
}

func TL2ExpectedNonZeroError() error {
	return fmt.Errorf("expected non zero value")
}

func TL2Error(format string, a ...any) error {
	return fmt.Errorf("tl2 error: %s", fmt.Sprintf(format, a...))
}

func TL2ReadSize(r []byte, l *int) (_ []byte, err error) {
	r, *l, err = TL2ParseSize(r)
	return r, err
}

func TL2ParseSize(r []byte) ([]byte, int, error) {
	if len(r) == 0 {
		return r, 0, io.ErrUnexpectedEOF
	}
	b0 := r[0]

	switch {
	case b0 < bigStringMarker:
		l := int(b0)
		r = r[1:]
		return r, l, nil
	case b0 == bigStringMarker:
		if len(r) < 3 {
			return r, 0, io.ErrUnexpectedEOF
		}
		l := bigStringMarker + int(binary.LittleEndian.Uint16(r[1:]))
		r = r[3:]
		return r, l, nil
	default: // hugeStringMarker
		if len(r) < 9 {
			return r, 0, io.ErrUnexpectedEOF
		}
		l64 := binary.LittleEndian.Uint64(r[1:])
		if l64 > math.MaxInt {
			return r, 0, fmt.Errorf("string length cannot be represented on 32-bit platform: %d", l64)
		}
		// we allow non-canonical length to speed up some rare implementations
		r = r[9:]
		return r, int(l64), nil
	}
}

func TL2WriteSize(w []byte, l int) []byte {
	switch {
	case l < bigStringMarker:
		w = append(w, byte(l))
	case l < bigStringMarker+(1<<16):
		w = append(w, bigStringMarker)
		w = binary.LittleEndian.AppendUint16(w, uint16(l-bigStringMarker))
	default:
		w = append(w, hugeStringMarker)
		w = binary.LittleEndian.AppendUint64(w, uint64(l))
	}
	return w
}

func TL2CalculateSize(l int) int {
	switch {
	case l < bigStringMarker:
		return 1
	case l < bigStringMarker+(1<<16):
		return 3
	default:
		return 9
	}
}

func StringWriteTL2(w []byte, v string) []byte {
	w = TL2WriteSize(w, len(v))
	w = append(w, v...)
	return w
}

func StringWriteTL2Bytes(w []byte, v []byte) []byte {
	w = TL2WriteSize(w, len(v))
	w = append(w, v...)
	return w
}

func StringReadTL2(r []byte, dst *string) (_ []byte, err error) {
	var l int
	if r, err = TL2ReadSize(r, &l); err != nil {
		return r, err
	}
	if len(r) < l {
		return r, io.ErrUnexpectedEOF
	}
	*dst = string(r[:l])
	return r[l:], nil
}

func StringReadTL2Bytes(r []byte, dst *[]byte) (_ []byte, err error) {
	var l int
	if r, err = TL2ReadSize(r, &l); err != nil {
		return r, err
	}
	if l > 0 {
		if len(r) < l {
			return r, io.ErrUnexpectedEOF
		}
		// Allocate only after we know there is enough bytes in reader
		if cap(*dst) < l {
			*dst = make([]byte, l)
		} else {
			*dst = (*dst)[:l]
		}
		copy(*dst, r)
	} else {
		*dst = (*dst)[:0]
	}
	return r[l:], nil
}

func ByteWriteTL2(w []byte, b byte) []byte {
	w = append(w, b)
	return w
}

func ByteReadTL2(r []byte, b *byte) ([]byte, error) {
	if len(r) == 0 {
		return r, io.ErrUnexpectedEOF
	}
	*b = r[0]
	return r[1:], nil
}

func ByteBoolWriteTL2(w []byte, b bool) []byte {
	if b {
		w = append(w, 1)
	} else {
		w = append(w, 0)
	}
	return w
}

func ByteBoolReadTL2(r []byte, b *bool) (_ []byte, err error) {
	var byt byte
	if r, err = ByteReadTL2(r, &byt); err != nil {
		return r, err
	}
	if byt == 0 {
		*b = false
	} else {
		*b = true
	}
	return r, nil
}

func MaybeBoolWriteTL2(w []byte, b bool) []byte {
	if b {
		w = append(w, 2, 1<<0+1<<1, 1)
	} else {
		w = append(w, 2, 1<<0, 1)
	}
	return w
}

func MaybeBoolReadTL2(r []byte, b *bool) (_ []byte, err error) {
	var l int
	if r, err = TL2ReadSize(r, &l); err != nil {
		return r, err
	}
	if l == 0 {
		*b = false
	} else {
		curR := r[:l]
		r = r[l:]

		var block byte
		if curR, err = ByteReadTL2(curR, &block); err != nil {
			return curR, err
		}

		var constructor int
		if curR, err = TL2ReadSize(curR, &constructor); err != nil {
			return curR, err
		}

		if constructor != 1 {
			return curR, TL2Error("unknown constructor %d", constructor)
		}

		*b = (block & (1 << 1)) != 0
	}
	return r, err
}

func SkipSizedValue(r []byte) (_ []byte, err error) {
	var l int
	if r, err = TL2ReadSize(r, &l); err != nil {
		return r, err
	}
	if len(r) < l {
		return r, TL2Error("not enough data to skip: expected %d, got %d", l, len(r))
	}
	r = r[l:]
	return r, err
}

func SkipFixedSizedValue(r []byte, l int) (_ []byte, err error) {
	if l < 0 {
		return r, TL2Error("can skip only non negative number of elements")
	}
	if len(r) < l {
		return r, TL2Error("not enough data to skip: expected %d, got %d", l, len(r))
	}
	r = r[l:]
	return r, err
}
