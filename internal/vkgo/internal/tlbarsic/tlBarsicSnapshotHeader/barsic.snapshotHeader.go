// Copyright 2025 V Kontakte LLC
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

// Code generated by vktl/cmd/tlgen2; DO NOT EDIT.
package tlBarsicSnapshotHeader

import (
	"github.com/VKCOM/statshouse/internal/vkgo/basictl"
	"github.com/VKCOM/statshouse/internal/vkgo/internal"
	"github.com/VKCOM/statshouse/internal/vkgo/internal/tl/tlBuiltinVectorBarsicSnapshotDependency"
	"github.com/VKCOM/statshouse/internal/vkgo/internal/tl/tlBuiltinVectorBarsicSnapshotExternalFile"
	"github.com/VKCOM/statshouse/internal/vkgo/internal/tlbarsic/tlBarsicSnapshotDependency"
	"github.com/VKCOM/statshouse/internal/vkgo/internal/tlbarsic/tlBarsicSnapshotExternalFile"
)

var _ = basictl.NatWrite
var _ = internal.ErrorInvalidEnumTag

type BarsicSnapshotHeader struct {
	FieldsMask       uint32
	ClusterId        string
	ShardId          string
	SnapshotMeta     string
	Dependencies     []tlBarsicSnapshotDependency.BarsicSnapshotDependency
	PayloadOffset    int64
	EngineVersion    string
	CreationTimeNano int64
	ControlMeta      string                                                    // Conditional: item.FieldsMask.0
	ExternalFiles    []tlBarsicSnapshotExternalFile.BarsicSnapshotExternalFile // Conditional: item.FieldsMask.1
}

func (BarsicSnapshotHeader) TLName() string { return "barsic.snapshotHeader" }
func (BarsicSnapshotHeader) TLTag() uint32  { return 0x1d0d1b74 }

func (item *BarsicSnapshotHeader) SetControlMeta(v string) {
	item.ControlMeta = v
	item.FieldsMask |= 1 << 0
}
func (item *BarsicSnapshotHeader) ClearControlMeta() {
	item.ControlMeta = ""
	item.FieldsMask &^= 1 << 0
}
func (item *BarsicSnapshotHeader) IsSetControlMeta() bool { return item.FieldsMask&(1<<0) != 0 }

func (item *BarsicSnapshotHeader) SetExternalFiles(v []tlBarsicSnapshotExternalFile.BarsicSnapshotExternalFile) {
	item.ExternalFiles = v
	item.FieldsMask |= 1 << 1
}
func (item *BarsicSnapshotHeader) ClearExternalFiles() {
	item.ExternalFiles = item.ExternalFiles[:0]
	item.FieldsMask &^= 1 << 1
}
func (item *BarsicSnapshotHeader) IsSetExternalFiles() bool { return item.FieldsMask&(1<<1) != 0 }

func (item *BarsicSnapshotHeader) Reset() {
	item.FieldsMask = 0
	item.ClusterId = ""
	item.ShardId = ""
	item.SnapshotMeta = ""
	item.Dependencies = item.Dependencies[:0]
	item.PayloadOffset = 0
	item.EngineVersion = ""
	item.CreationTimeNano = 0
	item.ControlMeta = ""
	item.ExternalFiles = item.ExternalFiles[:0]
}

func (item *BarsicSnapshotHeader) FillRandom(rg *basictl.RandGenerator) {
	var maskFieldsMask uint32
	maskFieldsMask = basictl.RandomUint(rg)
	item.FieldsMask = 0
	if maskFieldsMask&(1<<0) != 0 {
		item.FieldsMask |= (1 << 0)
	}
	if maskFieldsMask&(1<<1) != 0 {
		item.FieldsMask |= (1 << 1)
	}
	item.ClusterId = basictl.RandomString(rg)
	item.ShardId = basictl.RandomString(rg)
	item.SnapshotMeta = basictl.RandomString(rg)
	tlBuiltinVectorBarsicSnapshotDependency.BuiltinVectorBarsicSnapshotDependencyFillRandom(rg, &item.Dependencies)
	item.PayloadOffset = basictl.RandomLong(rg)
	item.EngineVersion = basictl.RandomString(rg)
	item.CreationTimeNano = basictl.RandomLong(rg)
	if item.FieldsMask&(1<<0) != 0 {
		item.ControlMeta = basictl.RandomString(rg)
	} else {
		item.ControlMeta = ""
	}
	if item.FieldsMask&(1<<1) != 0 {
		tlBuiltinVectorBarsicSnapshotExternalFile.BuiltinVectorBarsicSnapshotExternalFileFillRandom(rg, &item.ExternalFiles)
	} else {
		item.ExternalFiles = item.ExternalFiles[:0]
	}
}

func (item *BarsicSnapshotHeader) Read(w []byte) (_ []byte, err error) {
	if w, err = basictl.NatRead(w, &item.FieldsMask); err != nil {
		return w, err
	}
	if w, err = basictl.StringRead(w, &item.ClusterId); err != nil {
		return w, err
	}
	if w, err = basictl.StringRead(w, &item.ShardId); err != nil {
		return w, err
	}
	if w, err = basictl.StringRead(w, &item.SnapshotMeta); err != nil {
		return w, err
	}
	if w, err = tlBuiltinVectorBarsicSnapshotDependency.BuiltinVectorBarsicSnapshotDependencyRead(w, &item.Dependencies); err != nil {
		return w, err
	}
	if w, err = basictl.LongRead(w, &item.PayloadOffset); err != nil {
		return w, err
	}
	if w, err = basictl.StringRead(w, &item.EngineVersion); err != nil {
		return w, err
	}
	if w, err = basictl.LongRead(w, &item.CreationTimeNano); err != nil {
		return w, err
	}
	if item.FieldsMask&(1<<0) != 0 {
		if w, err = basictl.StringRead(w, &item.ControlMeta); err != nil {
			return w, err
		}
	} else {
		item.ControlMeta = ""
	}
	if item.FieldsMask&(1<<1) != 0 {
		if w, err = tlBuiltinVectorBarsicSnapshotExternalFile.BuiltinVectorBarsicSnapshotExternalFileRead(w, &item.ExternalFiles); err != nil {
			return w, err
		}
	} else {
		item.ExternalFiles = item.ExternalFiles[:0]
	}
	return w, nil
}

func (item *BarsicSnapshotHeader) WriteGeneral(w []byte) (_ []byte, err error) {
	return item.Write(w), nil
}

func (item *BarsicSnapshotHeader) Write(w []byte) []byte {
	w = basictl.NatWrite(w, item.FieldsMask)
	w = basictl.StringWrite(w, item.ClusterId)
	w = basictl.StringWrite(w, item.ShardId)
	w = basictl.StringWrite(w, item.SnapshotMeta)
	w = tlBuiltinVectorBarsicSnapshotDependency.BuiltinVectorBarsicSnapshotDependencyWrite(w, item.Dependencies)
	w = basictl.LongWrite(w, item.PayloadOffset)
	w = basictl.StringWrite(w, item.EngineVersion)
	w = basictl.LongWrite(w, item.CreationTimeNano)
	if item.FieldsMask&(1<<0) != 0 {
		w = basictl.StringWrite(w, item.ControlMeta)
	}
	if item.FieldsMask&(1<<1) != 0 {
		w = tlBuiltinVectorBarsicSnapshotExternalFile.BuiltinVectorBarsicSnapshotExternalFileWrite(w, item.ExternalFiles)
	}
	return w
}

func (item *BarsicSnapshotHeader) ReadBoxed(w []byte) (_ []byte, err error) {
	if w, err = basictl.NatReadExactTag(w, 0x1d0d1b74); err != nil {
		return w, err
	}
	return item.Read(w)
}

func (item *BarsicSnapshotHeader) WriteBoxedGeneral(w []byte) (_ []byte, err error) {
	return item.WriteBoxed(w), nil
}

func (item *BarsicSnapshotHeader) WriteBoxed(w []byte) []byte {
	w = basictl.NatWrite(w, 0x1d0d1b74)
	return item.Write(w)
}

func (item BarsicSnapshotHeader) String() string {
	return string(item.WriteJSON(nil))
}

func (item *BarsicSnapshotHeader) ReadJSON(legacyTypeNames bool, in *basictl.JsonLexer) error {
	var propFieldsMaskPresented bool
	var propClusterIdPresented bool
	var propShardIdPresented bool
	var propSnapshotMetaPresented bool
	var propDependenciesPresented bool
	var propPayloadOffsetPresented bool
	var propEngineVersionPresented bool
	var propCreationTimeNanoPresented bool
	var propControlMetaPresented bool
	var propExternalFilesPresented bool

	if in != nil {
		in.Delim('{')
		if !in.Ok() {
			return in.Error()
		}
		for !in.IsDelim('}') {
			key := in.UnsafeFieldName(true)
			in.WantColon()
			switch key {
			case "fields_mask":
				if propFieldsMaskPresented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("barsic.snapshotHeader", "fields_mask")
				}
				if err := internal.Json2ReadUint32(in, &item.FieldsMask); err != nil {
					return err
				}
				propFieldsMaskPresented = true
			case "cluster_id":
				if propClusterIdPresented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("barsic.snapshotHeader", "cluster_id")
				}
				if err := internal.Json2ReadString(in, &item.ClusterId); err != nil {
					return err
				}
				propClusterIdPresented = true
			case "shard_id":
				if propShardIdPresented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("barsic.snapshotHeader", "shard_id")
				}
				if err := internal.Json2ReadString(in, &item.ShardId); err != nil {
					return err
				}
				propShardIdPresented = true
			case "snapshot_meta":
				if propSnapshotMetaPresented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("barsic.snapshotHeader", "snapshot_meta")
				}
				if err := internal.Json2ReadString(in, &item.SnapshotMeta); err != nil {
					return err
				}
				propSnapshotMetaPresented = true
			case "dependencies":
				if propDependenciesPresented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("barsic.snapshotHeader", "dependencies")
				}
				if err := tlBuiltinVectorBarsicSnapshotDependency.BuiltinVectorBarsicSnapshotDependencyReadJSON(legacyTypeNames, in, &item.Dependencies); err != nil {
					return err
				}
				propDependenciesPresented = true
			case "payload_offset":
				if propPayloadOffsetPresented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("barsic.snapshotHeader", "payload_offset")
				}
				if err := internal.Json2ReadInt64(in, &item.PayloadOffset); err != nil {
					return err
				}
				propPayloadOffsetPresented = true
			case "engine_version":
				if propEngineVersionPresented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("barsic.snapshotHeader", "engine_version")
				}
				if err := internal.Json2ReadString(in, &item.EngineVersion); err != nil {
					return err
				}
				propEngineVersionPresented = true
			case "creation_time_nano":
				if propCreationTimeNanoPresented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("barsic.snapshotHeader", "creation_time_nano")
				}
				if err := internal.Json2ReadInt64(in, &item.CreationTimeNano); err != nil {
					return err
				}
				propCreationTimeNanoPresented = true
			case "control_meta":
				if propControlMetaPresented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("barsic.snapshotHeader", "control_meta")
				}
				if err := internal.Json2ReadString(in, &item.ControlMeta); err != nil {
					return err
				}
				propControlMetaPresented = true
			case "external_files":
				if propExternalFilesPresented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("barsic.snapshotHeader", "external_files")
				}
				if err := tlBuiltinVectorBarsicSnapshotExternalFile.BuiltinVectorBarsicSnapshotExternalFileReadJSON(legacyTypeNames, in, &item.ExternalFiles); err != nil {
					return err
				}
				propExternalFilesPresented = true
			default:
				return internal.ErrorInvalidJSONExcessElement("barsic.snapshotHeader", key)
			}
			in.WantComma()
		}
		in.Delim('}')
		if !in.Ok() {
			return in.Error()
		}
	}
	if !propFieldsMaskPresented {
		item.FieldsMask = 0
	}
	if !propClusterIdPresented {
		item.ClusterId = ""
	}
	if !propShardIdPresented {
		item.ShardId = ""
	}
	if !propSnapshotMetaPresented {
		item.SnapshotMeta = ""
	}
	if !propDependenciesPresented {
		item.Dependencies = item.Dependencies[:0]
	}
	if !propPayloadOffsetPresented {
		item.PayloadOffset = 0
	}
	if !propEngineVersionPresented {
		item.EngineVersion = ""
	}
	if !propCreationTimeNanoPresented {
		item.CreationTimeNano = 0
	}
	if !propControlMetaPresented {
		item.ControlMeta = ""
	}
	if !propExternalFilesPresented {
		item.ExternalFiles = item.ExternalFiles[:0]
	}
	if propControlMetaPresented {
		item.FieldsMask |= 1 << 0
	}
	if propExternalFilesPresented {
		item.FieldsMask |= 1 << 1
	}
	return nil
}

// This method is general version of WriteJSON, use it instead!
func (item *BarsicSnapshotHeader) WriteJSONGeneral(w []byte) (_ []byte, err error) {
	return item.WriteJSONOpt(true, false, w), nil
}

func (item *BarsicSnapshotHeader) WriteJSON(w []byte) []byte {
	return item.WriteJSONOpt(true, false, w)
}
func (item *BarsicSnapshotHeader) WriteJSONOpt(newTypeNames bool, short bool, w []byte) []byte {
	w = append(w, '{')
	backupIndexFieldsMask := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"fields_mask":`...)
	w = basictl.JSONWriteUint32(w, item.FieldsMask)
	if (item.FieldsMask != 0) == false {
		w = w[:backupIndexFieldsMask]
	}
	backupIndexClusterId := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"cluster_id":`...)
	w = basictl.JSONWriteString(w, item.ClusterId)
	if (len(item.ClusterId) != 0) == false {
		w = w[:backupIndexClusterId]
	}
	backupIndexShardId := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"shard_id":`...)
	w = basictl.JSONWriteString(w, item.ShardId)
	if (len(item.ShardId) != 0) == false {
		w = w[:backupIndexShardId]
	}
	backupIndexSnapshotMeta := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"snapshot_meta":`...)
	w = basictl.JSONWriteString(w, item.SnapshotMeta)
	if (len(item.SnapshotMeta) != 0) == false {
		w = w[:backupIndexSnapshotMeta]
	}
	backupIndexDependencies := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"dependencies":`...)
	w = tlBuiltinVectorBarsicSnapshotDependency.BuiltinVectorBarsicSnapshotDependencyWriteJSONOpt(newTypeNames, short, w, item.Dependencies)
	if (len(item.Dependencies) != 0) == false {
		w = w[:backupIndexDependencies]
	}
	backupIndexPayloadOffset := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"payload_offset":`...)
	w = basictl.JSONWriteInt64(w, item.PayloadOffset)
	if (item.PayloadOffset != 0) == false {
		w = w[:backupIndexPayloadOffset]
	}
	backupIndexEngineVersion := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"engine_version":`...)
	w = basictl.JSONWriteString(w, item.EngineVersion)
	if (len(item.EngineVersion) != 0) == false {
		w = w[:backupIndexEngineVersion]
	}
	backupIndexCreationTimeNano := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"creation_time_nano":`...)
	w = basictl.JSONWriteInt64(w, item.CreationTimeNano)
	if (item.CreationTimeNano != 0) == false {
		w = w[:backupIndexCreationTimeNano]
	}
	if item.FieldsMask&(1<<0) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"control_meta":`...)
		w = basictl.JSONWriteString(w, item.ControlMeta)
	}
	if item.FieldsMask&(1<<1) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"external_files":`...)
		w = tlBuiltinVectorBarsicSnapshotExternalFile.BuiltinVectorBarsicSnapshotExternalFileWriteJSONOpt(newTypeNames, short, w, item.ExternalFiles)
	}
	return append(w, '}')
}

func (item *BarsicSnapshotHeader) MarshalJSON() ([]byte, error) {
	return item.WriteJSON(nil), nil
}

func (item *BarsicSnapshotHeader) UnmarshalJSON(b []byte) error {
	if err := item.ReadJSON(true, &basictl.JsonLexer{Data: b}); err != nil {
		return internal.ErrorInvalidJSON("barsic.snapshotHeader", err.Error())
	}
	return nil
}

func (item *BarsicSnapshotHeader) WriteTL2(w []byte, ctx *basictl.TL2WriteContext) []byte {
	return w
}

func (item *BarsicSnapshotHeader) ReadTL2(r []byte, ctx *basictl.TL2ReadContext) (_ []byte, err error) {
	return r, internal.ErrorTL2SerializersNotGenerated("barsic.snapshotHeader")
}

type BarsicSnapshotHeaderBytes struct {
	FieldsMask       uint32
	ClusterId        []byte
	ShardId          []byte
	SnapshotMeta     []byte
	Dependencies     []tlBarsicSnapshotDependency.BarsicSnapshotDependencyBytes
	PayloadOffset    int64
	EngineVersion    []byte
	CreationTimeNano int64
	ControlMeta      []byte                                                         // Conditional: item.FieldsMask.0
	ExternalFiles    []tlBarsicSnapshotExternalFile.BarsicSnapshotExternalFileBytes // Conditional: item.FieldsMask.1
}

func (BarsicSnapshotHeaderBytes) TLName() string { return "barsic.snapshotHeader" }
func (BarsicSnapshotHeaderBytes) TLTag() uint32  { return 0x1d0d1b74 }

func (item *BarsicSnapshotHeaderBytes) SetControlMeta(v []byte) {
	item.ControlMeta = v
	item.FieldsMask |= 1 << 0
}
func (item *BarsicSnapshotHeaderBytes) ClearControlMeta() {
	item.ControlMeta = item.ControlMeta[:0]
	item.FieldsMask &^= 1 << 0
}
func (item *BarsicSnapshotHeaderBytes) IsSetControlMeta() bool { return item.FieldsMask&(1<<0) != 0 }

func (item *BarsicSnapshotHeaderBytes) SetExternalFiles(v []tlBarsicSnapshotExternalFile.BarsicSnapshotExternalFileBytes) {
	item.ExternalFiles = v
	item.FieldsMask |= 1 << 1
}
func (item *BarsicSnapshotHeaderBytes) ClearExternalFiles() {
	item.ExternalFiles = item.ExternalFiles[:0]
	item.FieldsMask &^= 1 << 1
}
func (item *BarsicSnapshotHeaderBytes) IsSetExternalFiles() bool { return item.FieldsMask&(1<<1) != 0 }

func (item *BarsicSnapshotHeaderBytes) Reset() {
	item.FieldsMask = 0
	item.ClusterId = item.ClusterId[:0]
	item.ShardId = item.ShardId[:0]
	item.SnapshotMeta = item.SnapshotMeta[:0]
	item.Dependencies = item.Dependencies[:0]
	item.PayloadOffset = 0
	item.EngineVersion = item.EngineVersion[:0]
	item.CreationTimeNano = 0
	item.ControlMeta = item.ControlMeta[:0]
	item.ExternalFiles = item.ExternalFiles[:0]
}

func (item *BarsicSnapshotHeaderBytes) FillRandom(rg *basictl.RandGenerator) {
	var maskFieldsMask uint32
	maskFieldsMask = basictl.RandomUint(rg)
	item.FieldsMask = 0
	if maskFieldsMask&(1<<0) != 0 {
		item.FieldsMask |= (1 << 0)
	}
	if maskFieldsMask&(1<<1) != 0 {
		item.FieldsMask |= (1 << 1)
	}
	item.ClusterId = basictl.RandomStringBytes(rg)
	item.ShardId = basictl.RandomStringBytes(rg)
	item.SnapshotMeta = basictl.RandomStringBytes(rg)
	tlBuiltinVectorBarsicSnapshotDependency.BuiltinVectorBarsicSnapshotDependencyBytesFillRandom(rg, &item.Dependencies)
	item.PayloadOffset = basictl.RandomLong(rg)
	item.EngineVersion = basictl.RandomStringBytes(rg)
	item.CreationTimeNano = basictl.RandomLong(rg)
	if item.FieldsMask&(1<<0) != 0 {
		item.ControlMeta = basictl.RandomStringBytes(rg)
	} else {
		item.ControlMeta = item.ControlMeta[:0]
	}
	if item.FieldsMask&(1<<1) != 0 {
		tlBuiltinVectorBarsicSnapshotExternalFile.BuiltinVectorBarsicSnapshotExternalFileBytesFillRandom(rg, &item.ExternalFiles)
	} else {
		item.ExternalFiles = item.ExternalFiles[:0]
	}
}

func (item *BarsicSnapshotHeaderBytes) Read(w []byte) (_ []byte, err error) {
	if w, err = basictl.NatRead(w, &item.FieldsMask); err != nil {
		return w, err
	}
	if w, err = basictl.StringReadBytes(w, &item.ClusterId); err != nil {
		return w, err
	}
	if w, err = basictl.StringReadBytes(w, &item.ShardId); err != nil {
		return w, err
	}
	if w, err = basictl.StringReadBytes(w, &item.SnapshotMeta); err != nil {
		return w, err
	}
	if w, err = tlBuiltinVectorBarsicSnapshotDependency.BuiltinVectorBarsicSnapshotDependencyBytesRead(w, &item.Dependencies); err != nil {
		return w, err
	}
	if w, err = basictl.LongRead(w, &item.PayloadOffset); err != nil {
		return w, err
	}
	if w, err = basictl.StringReadBytes(w, &item.EngineVersion); err != nil {
		return w, err
	}
	if w, err = basictl.LongRead(w, &item.CreationTimeNano); err != nil {
		return w, err
	}
	if item.FieldsMask&(1<<0) != 0 {
		if w, err = basictl.StringReadBytes(w, &item.ControlMeta); err != nil {
			return w, err
		}
	} else {
		item.ControlMeta = item.ControlMeta[:0]
	}
	if item.FieldsMask&(1<<1) != 0 {
		if w, err = tlBuiltinVectorBarsicSnapshotExternalFile.BuiltinVectorBarsicSnapshotExternalFileBytesRead(w, &item.ExternalFiles); err != nil {
			return w, err
		}
	} else {
		item.ExternalFiles = item.ExternalFiles[:0]
	}
	return w, nil
}

func (item *BarsicSnapshotHeaderBytes) WriteGeneral(w []byte) (_ []byte, err error) {
	return item.Write(w), nil
}

func (item *BarsicSnapshotHeaderBytes) Write(w []byte) []byte {
	w = basictl.NatWrite(w, item.FieldsMask)
	w = basictl.StringWriteBytes(w, item.ClusterId)
	w = basictl.StringWriteBytes(w, item.ShardId)
	w = basictl.StringWriteBytes(w, item.SnapshotMeta)
	w = tlBuiltinVectorBarsicSnapshotDependency.BuiltinVectorBarsicSnapshotDependencyBytesWrite(w, item.Dependencies)
	w = basictl.LongWrite(w, item.PayloadOffset)
	w = basictl.StringWriteBytes(w, item.EngineVersion)
	w = basictl.LongWrite(w, item.CreationTimeNano)
	if item.FieldsMask&(1<<0) != 0 {
		w = basictl.StringWriteBytes(w, item.ControlMeta)
	}
	if item.FieldsMask&(1<<1) != 0 {
		w = tlBuiltinVectorBarsicSnapshotExternalFile.BuiltinVectorBarsicSnapshotExternalFileBytesWrite(w, item.ExternalFiles)
	}
	return w
}

func (item *BarsicSnapshotHeaderBytes) ReadBoxed(w []byte) (_ []byte, err error) {
	if w, err = basictl.NatReadExactTag(w, 0x1d0d1b74); err != nil {
		return w, err
	}
	return item.Read(w)
}

func (item *BarsicSnapshotHeaderBytes) WriteBoxedGeneral(w []byte) (_ []byte, err error) {
	return item.WriteBoxed(w), nil
}

func (item *BarsicSnapshotHeaderBytes) WriteBoxed(w []byte) []byte {
	w = basictl.NatWrite(w, 0x1d0d1b74)
	return item.Write(w)
}

func (item BarsicSnapshotHeaderBytes) String() string {
	return string(item.WriteJSON(nil))
}

func (item *BarsicSnapshotHeaderBytes) ReadJSON(legacyTypeNames bool, in *basictl.JsonLexer) error {
	var propFieldsMaskPresented bool
	var propClusterIdPresented bool
	var propShardIdPresented bool
	var propSnapshotMetaPresented bool
	var propDependenciesPresented bool
	var propPayloadOffsetPresented bool
	var propEngineVersionPresented bool
	var propCreationTimeNanoPresented bool
	var propControlMetaPresented bool
	var propExternalFilesPresented bool

	if in != nil {
		in.Delim('{')
		if !in.Ok() {
			return in.Error()
		}
		for !in.IsDelim('}') {
			key := in.UnsafeFieldName(true)
			in.WantColon()
			switch key {
			case "fields_mask":
				if propFieldsMaskPresented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("barsic.snapshotHeader", "fields_mask")
				}
				if err := internal.Json2ReadUint32(in, &item.FieldsMask); err != nil {
					return err
				}
				propFieldsMaskPresented = true
			case "cluster_id":
				if propClusterIdPresented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("barsic.snapshotHeader", "cluster_id")
				}
				if err := internal.Json2ReadStringBytes(in, &item.ClusterId); err != nil {
					return err
				}
				propClusterIdPresented = true
			case "shard_id":
				if propShardIdPresented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("barsic.snapshotHeader", "shard_id")
				}
				if err := internal.Json2ReadStringBytes(in, &item.ShardId); err != nil {
					return err
				}
				propShardIdPresented = true
			case "snapshot_meta":
				if propSnapshotMetaPresented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("barsic.snapshotHeader", "snapshot_meta")
				}
				if err := internal.Json2ReadStringBytes(in, &item.SnapshotMeta); err != nil {
					return err
				}
				propSnapshotMetaPresented = true
			case "dependencies":
				if propDependenciesPresented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("barsic.snapshotHeader", "dependencies")
				}
				if err := tlBuiltinVectorBarsicSnapshotDependency.BuiltinVectorBarsicSnapshotDependencyBytesReadJSON(legacyTypeNames, in, &item.Dependencies); err != nil {
					return err
				}
				propDependenciesPresented = true
			case "payload_offset":
				if propPayloadOffsetPresented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("barsic.snapshotHeader", "payload_offset")
				}
				if err := internal.Json2ReadInt64(in, &item.PayloadOffset); err != nil {
					return err
				}
				propPayloadOffsetPresented = true
			case "engine_version":
				if propEngineVersionPresented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("barsic.snapshotHeader", "engine_version")
				}
				if err := internal.Json2ReadStringBytes(in, &item.EngineVersion); err != nil {
					return err
				}
				propEngineVersionPresented = true
			case "creation_time_nano":
				if propCreationTimeNanoPresented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("barsic.snapshotHeader", "creation_time_nano")
				}
				if err := internal.Json2ReadInt64(in, &item.CreationTimeNano); err != nil {
					return err
				}
				propCreationTimeNanoPresented = true
			case "control_meta":
				if propControlMetaPresented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("barsic.snapshotHeader", "control_meta")
				}
				if err := internal.Json2ReadStringBytes(in, &item.ControlMeta); err != nil {
					return err
				}
				propControlMetaPresented = true
			case "external_files":
				if propExternalFilesPresented {
					return internal.ErrorInvalidJSONWithDuplicatingKeys("barsic.snapshotHeader", "external_files")
				}
				if err := tlBuiltinVectorBarsicSnapshotExternalFile.BuiltinVectorBarsicSnapshotExternalFileBytesReadJSON(legacyTypeNames, in, &item.ExternalFiles); err != nil {
					return err
				}
				propExternalFilesPresented = true
			default:
				return internal.ErrorInvalidJSONExcessElement("barsic.snapshotHeader", key)
			}
			in.WantComma()
		}
		in.Delim('}')
		if !in.Ok() {
			return in.Error()
		}
	}
	if !propFieldsMaskPresented {
		item.FieldsMask = 0
	}
	if !propClusterIdPresented {
		item.ClusterId = item.ClusterId[:0]
	}
	if !propShardIdPresented {
		item.ShardId = item.ShardId[:0]
	}
	if !propSnapshotMetaPresented {
		item.SnapshotMeta = item.SnapshotMeta[:0]
	}
	if !propDependenciesPresented {
		item.Dependencies = item.Dependencies[:0]
	}
	if !propPayloadOffsetPresented {
		item.PayloadOffset = 0
	}
	if !propEngineVersionPresented {
		item.EngineVersion = item.EngineVersion[:0]
	}
	if !propCreationTimeNanoPresented {
		item.CreationTimeNano = 0
	}
	if !propControlMetaPresented {
		item.ControlMeta = item.ControlMeta[:0]
	}
	if !propExternalFilesPresented {
		item.ExternalFiles = item.ExternalFiles[:0]
	}
	if propControlMetaPresented {
		item.FieldsMask |= 1 << 0
	}
	if propExternalFilesPresented {
		item.FieldsMask |= 1 << 1
	}
	return nil
}

// This method is general version of WriteJSON, use it instead!
func (item *BarsicSnapshotHeaderBytes) WriteJSONGeneral(w []byte) (_ []byte, err error) {
	return item.WriteJSONOpt(true, false, w), nil
}

func (item *BarsicSnapshotHeaderBytes) WriteJSON(w []byte) []byte {
	return item.WriteJSONOpt(true, false, w)
}
func (item *BarsicSnapshotHeaderBytes) WriteJSONOpt(newTypeNames bool, short bool, w []byte) []byte {
	w = append(w, '{')
	backupIndexFieldsMask := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"fields_mask":`...)
	w = basictl.JSONWriteUint32(w, item.FieldsMask)
	if (item.FieldsMask != 0) == false {
		w = w[:backupIndexFieldsMask]
	}
	backupIndexClusterId := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"cluster_id":`...)
	w = basictl.JSONWriteStringBytes(w, item.ClusterId)
	if (len(item.ClusterId) != 0) == false {
		w = w[:backupIndexClusterId]
	}
	backupIndexShardId := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"shard_id":`...)
	w = basictl.JSONWriteStringBytes(w, item.ShardId)
	if (len(item.ShardId) != 0) == false {
		w = w[:backupIndexShardId]
	}
	backupIndexSnapshotMeta := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"snapshot_meta":`...)
	w = basictl.JSONWriteStringBytes(w, item.SnapshotMeta)
	if (len(item.SnapshotMeta) != 0) == false {
		w = w[:backupIndexSnapshotMeta]
	}
	backupIndexDependencies := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"dependencies":`...)
	w = tlBuiltinVectorBarsicSnapshotDependency.BuiltinVectorBarsicSnapshotDependencyBytesWriteJSONOpt(newTypeNames, short, w, item.Dependencies)
	if (len(item.Dependencies) != 0) == false {
		w = w[:backupIndexDependencies]
	}
	backupIndexPayloadOffset := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"payload_offset":`...)
	w = basictl.JSONWriteInt64(w, item.PayloadOffset)
	if (item.PayloadOffset != 0) == false {
		w = w[:backupIndexPayloadOffset]
	}
	backupIndexEngineVersion := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"engine_version":`...)
	w = basictl.JSONWriteStringBytes(w, item.EngineVersion)
	if (len(item.EngineVersion) != 0) == false {
		w = w[:backupIndexEngineVersion]
	}
	backupIndexCreationTimeNano := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"creation_time_nano":`...)
	w = basictl.JSONWriteInt64(w, item.CreationTimeNano)
	if (item.CreationTimeNano != 0) == false {
		w = w[:backupIndexCreationTimeNano]
	}
	if item.FieldsMask&(1<<0) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"control_meta":`...)
		w = basictl.JSONWriteStringBytes(w, item.ControlMeta)
	}
	if item.FieldsMask&(1<<1) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"external_files":`...)
		w = tlBuiltinVectorBarsicSnapshotExternalFile.BuiltinVectorBarsicSnapshotExternalFileBytesWriteJSONOpt(newTypeNames, short, w, item.ExternalFiles)
	}
	return append(w, '}')
}

func (item *BarsicSnapshotHeaderBytes) MarshalJSON() ([]byte, error) {
	return item.WriteJSON(nil), nil
}

func (item *BarsicSnapshotHeaderBytes) UnmarshalJSON(b []byte) error {
	if err := item.ReadJSON(true, &basictl.JsonLexer{Data: b}); err != nil {
		return internal.ErrorInvalidJSON("barsic.snapshotHeader", err.Error())
	}
	return nil
}

func (item *BarsicSnapshotHeaderBytes) WriteTL2(w []byte, ctx *basictl.TL2WriteContext) []byte {
	return w
}

func (item *BarsicSnapshotHeaderBytes) ReadTL2(r []byte, ctx *basictl.TL2ReadContext) (_ []byte, err error) {
	return r, internal.ErrorTL2SerializersNotGenerated("barsic.snapshotHeader")
}
