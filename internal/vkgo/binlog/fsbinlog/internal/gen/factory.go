// Copyright 2022 V Kontakte LLC
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

// Code generated by vktl/cmd/tlgen2; DO NOT EDIT.
package gen

import (
	"github.com/vkcom/statshouse/internal/vkgo/basictl"
	"github.com/vkcom/statshouse/internal/vkgo/binlog/fsbinlog/internal/gen/internal"
)

// We can create only types which have zero type arguments and zero nat arguments
type Object interface {
	TLName() string // returns type's TL name. For union, returns constructor name depending on actual union value
	TLTag() uint32  // returns type's TL tag. For union, returns constructor tag depending on actual union value
	String() string // returns type's representation for debugging (JSON for now)

	Read(w []byte) ([]byte, error)       // reads type's bare TL representation by consuming bytes from the start of w and returns remaining bytes, plus error
	Write(w []byte) ([]byte, error)      // appends bytes of type's bare TL representation to the end of w and returns it, plus error
	ReadBoxed(w []byte) ([]byte, error)  // same as Read, but reads/checks TLTag first
	WriteBoxed(w []byte) ([]byte, error) // same as Write, but writes TLTag first

	MarshalJSON() ([]byte, error)       // returns type's JSON representation, plus error
	UnmarshalJSON([]byte) error         // reads type's JSON representation
	WriteJSON(w []byte) ([]byte, error) // like MarshalJSON, but appends to w and returns it
}

type Function interface {
	Object

	ReadResultWriteResultJSON(r []byte, w []byte) ([]byte, []byte, error) // combination of ReadResult(r) + WriteResultJSON(w). Returns new r, new w, plus error
	ReadResultJSONWriteResult(r []byte, w []byte) ([]byte, []byte, error) // combination of ReadResultJSON(r) + WriteResult(w). Returns new r, new w, plus error
}

// for quick one-liners
func GetTLName(tag uint32, notFoundName string) string {
	if item := FactoryItemByTLTag(tag); item != nil {
		return item.TLName()
	}
	return notFoundName
}

func CreateFunction(tag uint32) Function {
	if item := FactoryItemByTLTag(tag); item != nil && item.createFunction != nil {
		return item.createFunction()
	}
	return nil
}

func CreateObject(tag uint32) Object {
	if item := FactoryItemByTLTag(tag); item != nil && item.createObject != nil {
		return item.createObject()
	}
	return nil
}

// name can be in any of 3 forms "ch_proxy.insert#7cf362ba", "ch_proxy.insert" or "#7cf362ba"
func CreateFunctionFromName(name string) Function {
	if item := FactoryItemByTLName(name); item != nil && item.createFunction != nil {
		return item.createFunction()
	}
	return nil
}

// name can be in any of 3 forms "ch_proxy.insert#7cf362ba", "ch_proxy.insert" or "#7cf362ba"
func CreateObjectFromName(name string) Object {
	if item := FactoryItemByTLName(name); item != nil && item.createObject != nil {
		return item.createObject()
	}
	return nil
}

type TLItem struct {
	tag            uint32
	tlName         string
	createFunction func() Function
	createObject   func() Object
	// TODO - annotations, etc
}

func (item TLItem) IsFunction() bool         { return item.createFunction != nil }
func (item TLItem) TLTag() uint32            { return item.tag }
func (item TLItem) TLName() string           { return item.tlName }
func (item TLItem) CreateFunction() Function { return item.createFunction() }
func (item TLItem) CreateObject() Object     { return item.createObject() }

// TLItem serves as a single type for all enum values
func (item *TLItem) Reset()                              {}
func (item *TLItem) Read(w []byte) ([]byte, error)       { return w, nil }
func (item *TLItem) Write(w []byte) ([]byte, error)      { return w, nil }
func (item *TLItem) ReadBoxed(w []byte) ([]byte, error)  { return basictl.NatReadExactTag(w, item.tag) }
func (item *TLItem) WriteBoxed(w []byte) ([]byte, error) { return basictl.NatWrite(w, item.tag), nil }
func (item TLItem) String() string {
	w, err := item.WriteJSON(nil)
	if err != nil {
		return err.Error()
	}
	return string(w)
}
func (item *TLItem) readJSON(j interface{}) error {
	_jm, _ok := j.(map[string]interface{})
	if j != nil && !_ok {
		return internal.ErrorInvalidJSON(item.tlName, "expected json object")
	}
	for k := range _jm {
		return internal.ErrorInvalidJSONExcessElement(item.tlName, k)
	}
	return nil
}
func (item *TLItem) WriteJSON(w []byte) (_ []byte, err error) {
	w = append(w, '{')
	return append(w, '}'), nil
}
func (item *TLItem) MarshalJSON() ([]byte, error) {
	return item.WriteJSON(nil)
}
func (item *TLItem) UnmarshalJSON(b []byte) error {
	j, err := internal.JsonBytesToInterface(b)
	if err != nil {
		return internal.ErrorInvalidJSON(item.tlName, err.Error())
	}
	if err = item.readJSON(j); err != nil {
		return internal.ErrorInvalidJSON(item.tlName, err.Error())
	}
	return nil
}

func FactoryItemByTLTag(tag uint32) *TLItem {
	return itemsByTag[tag]
}

func FactoryItemByTLName(name string) *TLItem {
	return itemsByName[name]
}

var (
	itemFsbinlogLevStart = TLItem{
		tag:          0x44c644b,
		tlName:       "fsbinlog.levStart",
		createObject: func() Object { var ret internal.FsbinlogLevStart; return &ret },
	}
	itemFsbinlogLevUpgradeToGms = TLItem{
		tag:          0xb75009a0,
		tlName:       "fsbinlog.levUpgradeToGms",
		createObject: func() Object { var ret internal.FsbinlogLevUpgradeToGms; return &ret },
	}
	itemFsbinlogSnapshotMeta = TLItem{
		tag:          0x6b49d850,
		tlName:       "fsbinlog.snapshotMeta",
		createObject: func() Object { var ret internal.FsbinlogSnapshotMeta; return &ret },
	}
)

func init() {
	// avoid circular definitions
}

var itemsByTag = map[uint32]*TLItem{
	0x44c644b:  &itemFsbinlogLevStart,
	0xb75009a0: &itemFsbinlogLevUpgradeToGms,
	0x6b49d850: &itemFsbinlogSnapshotMeta,
}

var itemsByName = map[string]*TLItem{
	"fsbinlog.levStart":                 &itemFsbinlogLevStart,
	"fsbinlog.levStart#044c644b":        &itemFsbinlogLevStart,
	"#044c644b":                         &itemFsbinlogLevStart,
	"fsbinlog.levUpgradeToGms":          &itemFsbinlogLevUpgradeToGms,
	"fsbinlog.levUpgradeToGms#b75009a0": &itemFsbinlogLevUpgradeToGms,
	"#b75009a0":                         &itemFsbinlogLevUpgradeToGms,
	"fsbinlog.snapshotMeta":             &itemFsbinlogSnapshotMeta,
	"fsbinlog.snapshotMeta#6b49d850":    &itemFsbinlogSnapshotMeta,
	"#6b49d850":                         &itemFsbinlogSnapshotMeta,
}
