// Copyright 2024 V Kontakte LLC
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

// Code generated by vktl/cmd/tlgen2; DO NOT EDIT.
package internal

import (
	"github.com/vkcom/statshouse/internal/vkgo/basictl"
)

var _ = basictl.NatWrite

type NetUdpPacketUnencHeader struct {
	Flags       uint32
	LocalPid    NetPid // Conditional: item.Flags.0
	RemotePid   NetPid // Conditional: item.Flags.0
	Generation  uint32 // Conditional: item.Flags.0
	PidHash     int64  // Conditional: item.Flags.2
	CryptoFlags uint32 // Conditional: item.Flags.3
	// CryptoSha (TrueType) // Conditional: item.Flags.4
	CryptoRandom [8]uint32 // Conditional: item.Flags.5
	// EncryptedData (TrueType) // Conditional: item.Flags.7
	// SupportMsgOffsets (TrueType) // Conditional: item.Flags.8
}

func (NetUdpPacketUnencHeader) TLName() string { return "netUdpPacket.unencHeader" }
func (NetUdpPacketUnencHeader) TLTag() uint32  { return 0x00a8e945 }

func (item *NetUdpPacketUnencHeader) SetLocalPid(v NetPid) {
	item.LocalPid = v
	item.Flags |= 1 << 0
}
func (item *NetUdpPacketUnencHeader) ClearLocalPid() {
	item.LocalPid.Reset()
	item.Flags &^= 1 << 0
}
func (item NetUdpPacketUnencHeader) IsSetLocalPid() bool { return item.Flags&(1<<0) != 0 }

func (item *NetUdpPacketUnencHeader) SetRemotePid(v NetPid) {
	item.RemotePid = v
	item.Flags |= 1 << 0
}
func (item *NetUdpPacketUnencHeader) ClearRemotePid() {
	item.RemotePid.Reset()
	item.Flags &^= 1 << 0
}
func (item NetUdpPacketUnencHeader) IsSetRemotePid() bool { return item.Flags&(1<<0) != 0 }

func (item *NetUdpPacketUnencHeader) SetGeneration(v uint32) {
	item.Generation = v
	item.Flags |= 1 << 0
}
func (item *NetUdpPacketUnencHeader) ClearGeneration() {
	item.Generation = 0
	item.Flags &^= 1 << 0
}
func (item NetUdpPacketUnencHeader) IsSetGeneration() bool { return item.Flags&(1<<0) != 0 }

func (item *NetUdpPacketUnencHeader) SetPidHash(v int64) {
	item.PidHash = v
	item.Flags |= 1 << 2
}
func (item *NetUdpPacketUnencHeader) ClearPidHash() {
	item.PidHash = 0
	item.Flags &^= 1 << 2
}
func (item NetUdpPacketUnencHeader) IsSetPidHash() bool { return item.Flags&(1<<2) != 0 }

func (item *NetUdpPacketUnencHeader) SetCryptoFlags(v uint32) {
	item.CryptoFlags = v
	item.Flags |= 1 << 3
}
func (item *NetUdpPacketUnencHeader) ClearCryptoFlags() {
	item.CryptoFlags = 0
	item.Flags &^= 1 << 3
}
func (item NetUdpPacketUnencHeader) IsSetCryptoFlags() bool { return item.Flags&(1<<3) != 0 }

func (item *NetUdpPacketUnencHeader) SetCryptoSha(v bool) {
	if v {
		item.Flags |= 1 << 4
	} else {
		item.Flags &^= 1 << 4
	}
}
func (item NetUdpPacketUnencHeader) IsSetCryptoSha() bool { return item.Flags&(1<<4) != 0 }

func (item *NetUdpPacketUnencHeader) SetCryptoRandom(v [8]uint32) {
	item.CryptoRandom = v
	item.Flags |= 1 << 5
}
func (item *NetUdpPacketUnencHeader) ClearCryptoRandom() {
	BuiltinTuple8Reset(&item.CryptoRandom)
	item.Flags &^= 1 << 5
}
func (item NetUdpPacketUnencHeader) IsSetCryptoRandom() bool { return item.Flags&(1<<5) != 0 }

func (item *NetUdpPacketUnencHeader) SetEncryptedData(v bool) {
	if v {
		item.Flags |= 1 << 7
	} else {
		item.Flags &^= 1 << 7
	}
}
func (item NetUdpPacketUnencHeader) IsSetEncryptedData() bool { return item.Flags&(1<<7) != 0 }

func (item *NetUdpPacketUnencHeader) SetSupportMsgOffsets(v bool) {
	if v {
		item.Flags |= 1 << 8
	} else {
		item.Flags &^= 1 << 8
	}
}
func (item NetUdpPacketUnencHeader) IsSetSupportMsgOffsets() bool { return item.Flags&(1<<8) != 0 }

func (item *NetUdpPacketUnencHeader) Reset() {
	item.Flags = 0
	item.LocalPid.Reset()
	item.RemotePid.Reset()
	item.Generation = 0
	item.PidHash = 0
	item.CryptoFlags = 0
	BuiltinTuple8Reset(&item.CryptoRandom)
}

func (item *NetUdpPacketUnencHeader) FillRandom(rg *basictl.RandGenerator) {
	var maskFlags uint32
	maskFlags = basictl.RandomUint(rg)
	item.Flags = 0
	if maskFlags&(1<<0) != 0 {
		item.Flags |= (1 << 0)
	}
	if maskFlags&(1<<1) != 0 {
		item.Flags |= (1 << 2)
	}
	if maskFlags&(1<<2) != 0 {
		item.Flags |= (1 << 3)
	}
	if maskFlags&(1<<3) != 0 {
		item.Flags |= (1 << 4)
	}
	if maskFlags&(1<<4) != 0 {
		item.Flags |= (1 << 5)
	}
	if maskFlags&(1<<5) != 0 {
		item.Flags |= (1 << 7)
	}
	if maskFlags&(1<<6) != 0 {
		item.Flags |= (1 << 8)
	}
	if item.Flags&(1<<0) != 0 {
		item.LocalPid.FillRandom(rg)
	} else {
		item.LocalPid.Reset()
	}
	if item.Flags&(1<<0) != 0 {
		item.RemotePid.FillRandom(rg)
	} else {
		item.RemotePid.Reset()
	}
	if item.Flags&(1<<0) != 0 {
	} else {
		item.Generation = 0
	}
	if item.Flags&(1<<2) != 0 {
		item.PidHash = basictl.RandomLong(rg)
	} else {
		item.PidHash = 0
	}
	if item.Flags&(1<<3) != 0 {
	} else {
		item.CryptoFlags = 0
	}
	if item.Flags&(1<<5) != 0 {
		BuiltinTuple8FillRandom(rg, &item.CryptoRandom)
	} else {
		BuiltinTuple8Reset(&item.CryptoRandom)
	}
}

func (item *NetUdpPacketUnencHeader) Read(w []byte) (_ []byte, err error) {
	if w, err = basictl.NatRead(w, &item.Flags); err != nil {
		return w, err
	}
	if item.Flags&(1<<0) != 0 {
		if w, err = item.LocalPid.Read(w); err != nil {
			return w, err
		}
	} else {
		item.LocalPid.Reset()
	}
	if item.Flags&(1<<0) != 0 {
		if w, err = item.RemotePid.Read(w); err != nil {
			return w, err
		}
	} else {
		item.RemotePid.Reset()
	}
	if item.Flags&(1<<0) != 0 {
		if w, err = basictl.NatRead(w, &item.Generation); err != nil {
			return w, err
		}
	} else {
		item.Generation = 0
	}
	if item.Flags&(1<<2) != 0 {
		if w, err = basictl.LongRead(w, &item.PidHash); err != nil {
			return w, err
		}
	} else {
		item.PidHash = 0
	}
	if item.Flags&(1<<3) != 0 {
		if w, err = basictl.NatRead(w, &item.CryptoFlags); err != nil {
			return w, err
		}
	} else {
		item.CryptoFlags = 0
	}
	if item.Flags&(1<<5) != 0 {
		if w, err = BuiltinTuple8Read(w, &item.CryptoRandom); err != nil {
			return w, err
		}
	} else {
		BuiltinTuple8Reset(&item.CryptoRandom)
	}
	return w, nil
}

// This method is general version of Write, use it instead!
func (item *NetUdpPacketUnencHeader) WriteGeneral(w []byte) (_ []byte, err error) {
	return item.Write(w), nil
}

func (item *NetUdpPacketUnencHeader) Write(w []byte) []byte {
	w = basictl.NatWrite(w, item.Flags)
	if item.Flags&(1<<0) != 0 {
		w = item.LocalPid.Write(w)
	}
	if item.Flags&(1<<0) != 0 {
		w = item.RemotePid.Write(w)
	}
	if item.Flags&(1<<0) != 0 {
		w = basictl.NatWrite(w, item.Generation)
	}
	if item.Flags&(1<<2) != 0 {
		w = basictl.LongWrite(w, item.PidHash)
	}
	if item.Flags&(1<<3) != 0 {
		w = basictl.NatWrite(w, item.CryptoFlags)
	}
	if item.Flags&(1<<5) != 0 {
		w = BuiltinTuple8Write(w, &item.CryptoRandom)
	}
	return w
}

func (item *NetUdpPacketUnencHeader) ReadBoxed(w []byte) (_ []byte, err error) {
	if w, err = basictl.NatReadExactTag(w, 0x00a8e945); err != nil {
		return w, err
	}
	return item.Read(w)
}

// This method is general version of WriteBoxed, use it instead!
func (item *NetUdpPacketUnencHeader) WriteBoxedGeneral(w []byte) (_ []byte, err error) {
	return item.WriteBoxed(w), nil
}

func (item *NetUdpPacketUnencHeader) WriteBoxed(w []byte) []byte {
	w = basictl.NatWrite(w, 0x00a8e945)
	return item.Write(w)
}

func (item NetUdpPacketUnencHeader) String() string {
	return string(item.WriteJSON(nil))
}

func (item *NetUdpPacketUnencHeader) ReadJSON(legacyTypeNames bool, in *basictl.JsonLexer) error {
	var propFlagsPresented bool
	var propLocalPidPresented bool
	var propRemotePidPresented bool
	var propGenerationPresented bool
	var propPidHashPresented bool
	var propCryptoFlagsPresented bool
	var trueTypeCryptoShaPresented bool
	var trueTypeCryptoShaValue bool
	var propCryptoRandomPresented bool
	var trueTypeEncryptedDataPresented bool
	var trueTypeEncryptedDataValue bool
	var trueTypeSupportMsgOffsetsPresented bool
	var trueTypeSupportMsgOffsetsValue bool

	if in != nil {
		in.Delim('{')
		if !in.Ok() {
			return in.Error()
		}
		for !in.IsDelim('}') {
			key := in.UnsafeFieldName(true)
			in.WantColon()
			switch key {
			case "flags":
				if propFlagsPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("netUdpPacket.unencHeader", "flags")
				}
				if err := Json2ReadUint32(in, &item.Flags); err != nil {
					return err
				}
				propFlagsPresented = true
			case "local_pid":
				if propLocalPidPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("netUdpPacket.unencHeader", "local_pid")
				}
				if err := item.LocalPid.ReadJSON(legacyTypeNames, in); err != nil {
					return err
				}
				propLocalPidPresented = true
			case "remote_pid":
				if propRemotePidPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("netUdpPacket.unencHeader", "remote_pid")
				}
				if err := item.RemotePid.ReadJSON(legacyTypeNames, in); err != nil {
					return err
				}
				propRemotePidPresented = true
			case "generation":
				if propGenerationPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("netUdpPacket.unencHeader", "generation")
				}
				if err := Json2ReadUint32(in, &item.Generation); err != nil {
					return err
				}
				propGenerationPresented = true
			case "pid_hash":
				if propPidHashPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("netUdpPacket.unencHeader", "pid_hash")
				}
				if err := Json2ReadInt64(in, &item.PidHash); err != nil {
					return err
				}
				propPidHashPresented = true
			case "crypto_flags":
				if propCryptoFlagsPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("netUdpPacket.unencHeader", "crypto_flags")
				}
				if err := Json2ReadUint32(in, &item.CryptoFlags); err != nil {
					return err
				}
				propCryptoFlagsPresented = true
			case "crypto_sha":
				if trueTypeCryptoShaPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("netUdpPacket.unencHeader", "crypto_sha")
				}
				if err := Json2ReadBool(in, &trueTypeCryptoShaValue); err != nil {
					return err
				}
				trueTypeCryptoShaPresented = true
			case "crypto_random":
				if propCryptoRandomPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("netUdpPacket.unencHeader", "crypto_random")
				}
				if err := BuiltinTuple8ReadJSON(legacyTypeNames, in, &item.CryptoRandom); err != nil {
					return err
				}
				propCryptoRandomPresented = true
			case "encrypted_data":
				if trueTypeEncryptedDataPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("netUdpPacket.unencHeader", "encrypted_data")
				}
				if err := Json2ReadBool(in, &trueTypeEncryptedDataValue); err != nil {
					return err
				}
				trueTypeEncryptedDataPresented = true
			case "support_msg_offsets":
				if trueTypeSupportMsgOffsetsPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("netUdpPacket.unencHeader", "support_msg_offsets")
				}
				if err := Json2ReadBool(in, &trueTypeSupportMsgOffsetsValue); err != nil {
					return err
				}
				trueTypeSupportMsgOffsetsPresented = true
			default:
				return ErrorInvalidJSONExcessElement("netUdpPacket.unencHeader", key)
			}
			in.WantComma()
		}
		in.Delim('}')
		if !in.Ok() {
			return in.Error()
		}
	}
	if !propFlagsPresented {
		item.Flags = 0
	}
	if !propLocalPidPresented {
		item.LocalPid.Reset()
	}
	if !propRemotePidPresented {
		item.RemotePid.Reset()
	}
	if !propGenerationPresented {
		item.Generation = 0
	}
	if !propPidHashPresented {
		item.PidHash = 0
	}
	if !propCryptoFlagsPresented {
		item.CryptoFlags = 0
	}
	if !propCryptoRandomPresented {
		BuiltinTuple8Reset(&item.CryptoRandom)
	}
	if propLocalPidPresented {
		item.Flags |= 1 << 0
	}
	if propRemotePidPresented {
		item.Flags |= 1 << 0
	}
	if propGenerationPresented {
		item.Flags |= 1 << 0
	}
	if propPidHashPresented {
		item.Flags |= 1 << 2
	}
	if propCryptoFlagsPresented {
		item.Flags |= 1 << 3
	}
	if trueTypeCryptoShaPresented {
		if trueTypeCryptoShaValue {
			item.Flags |= 1 << 4
		}
	}
	if propCryptoRandomPresented {
		item.Flags |= 1 << 5
	}
	if trueTypeEncryptedDataPresented {
		if trueTypeEncryptedDataValue {
			item.Flags |= 1 << 7
		}
	}
	if trueTypeSupportMsgOffsetsPresented {
		if trueTypeSupportMsgOffsetsValue {
			item.Flags |= 1 << 8
		}
	}
	// tries to set bit to zero if it is 1
	if trueTypeCryptoShaPresented && !trueTypeCryptoShaValue && (item.Flags&(1<<4) != 0) {
		return ErrorInvalidJSON("netUdpPacket.unencHeader", "fieldmask bit flags.0 is indefinite because of the contradictions in values")
	}
	// tries to set bit to zero if it is 1
	if trueTypeEncryptedDataPresented && !trueTypeEncryptedDataValue && (item.Flags&(1<<7) != 0) {
		return ErrorInvalidJSON("netUdpPacket.unencHeader", "fieldmask bit flags.0 is indefinite because of the contradictions in values")
	}
	// tries to set bit to zero if it is 1
	if trueTypeSupportMsgOffsetsPresented && !trueTypeSupportMsgOffsetsValue && (item.Flags&(1<<8) != 0) {
		return ErrorInvalidJSON("netUdpPacket.unencHeader", "fieldmask bit flags.0 is indefinite because of the contradictions in values")
	}
	return nil
}

// This method is general version of WriteJSON, use it instead!
func (item *NetUdpPacketUnencHeader) WriteJSONGeneral(w []byte) (_ []byte, err error) {
	return item.WriteJSONOpt(true, false, w), nil
}

func (item *NetUdpPacketUnencHeader) WriteJSON(w []byte) []byte {
	return item.WriteJSONOpt(true, false, w)
}
func (item *NetUdpPacketUnencHeader) WriteJSONOpt(newTypeNames bool, short bool, w []byte) []byte {
	w = append(w, '{')
	backupIndexFlags := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"flags":`...)
	w = basictl.JSONWriteUint32(w, item.Flags)
	if (item.Flags != 0) == false {
		w = w[:backupIndexFlags]
	}
	if item.Flags&(1<<0) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"local_pid":`...)
		w = item.LocalPid.WriteJSONOpt(newTypeNames, short, w)
	}
	if item.Flags&(1<<0) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"remote_pid":`...)
		w = item.RemotePid.WriteJSONOpt(newTypeNames, short, w)
	}
	if item.Flags&(1<<0) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"generation":`...)
		w = basictl.JSONWriteUint32(w, item.Generation)
	}
	if item.Flags&(1<<2) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"pid_hash":`...)
		w = basictl.JSONWriteInt64(w, item.PidHash)
	}
	if item.Flags&(1<<3) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"crypto_flags":`...)
		w = basictl.JSONWriteUint32(w, item.CryptoFlags)
	}
	if item.Flags&(1<<4) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"crypto_sha":true`...)
	}
	if item.Flags&(1<<5) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"crypto_random":`...)
		w = BuiltinTuple8WriteJSONOpt(newTypeNames, short, w, &item.CryptoRandom)
	}
	if item.Flags&(1<<7) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"encrypted_data":true`...)
	}
	if item.Flags&(1<<8) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"support_msg_offsets":true`...)
	}
	return append(w, '}')
}

func (item *NetUdpPacketUnencHeader) MarshalJSON() ([]byte, error) {
	return item.WriteJSON(nil), nil
}

func (item *NetUdpPacketUnencHeader) UnmarshalJSON(b []byte) error {
	if err := item.ReadJSON(true, &basictl.JsonLexer{Data: b}); err != nil {
		return ErrorInvalidJSON("netUdpPacket.unencHeader", err.Error())
	}
	return nil
}
