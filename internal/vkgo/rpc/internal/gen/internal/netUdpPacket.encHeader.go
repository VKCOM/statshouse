// Copyright 2025 V Kontakte LLC
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

// Code generated by vktl/cmd/tlgen2; DO NOT EDIT.
package internal

import (
	"github.com/VKCOM/statshouse/internal/vkgo/basictl"
)

var _ = basictl.NatWrite

type NetUdpPacketEncHeader struct {
	Flags           uint32
	Time            int32    // Conditional: item.Flags.9
	Version         int32    // Conditional: item.Flags.10
	PacketAckPrefix uint32   // Conditional: item.Flags.13
	PacketAckFrom   uint32   // Conditional: item.Flags.14
	PacketAckTo     uint32   // Conditional: item.Flags.14
	PacketAckSet    []uint32 // Conditional: item.Flags.15
	PacketNum       uint32   // Conditional: item.Flags.20
	PacketsFrom     uint32   // Conditional: item.Flags.21
	PacketsCount    uint32   // Conditional: item.Flags.21
	PrevParts       uint32   // Conditional: item.Flags.22
	NextParts       uint32   // Conditional: item.Flags.23
	PrevLength      uint32   // Conditional: item.Flags.24
	NextLength      uint32   // Conditional: item.Flags.25
	// SingleRpcMsg (TrueType) // Conditional: item.Flags.26
	// MultipleRpcMsgs (TrueType) // Conditional: item.Flags.27
	// ZeroPadding4Bytes (TrueType) // Conditional: item.Flags.28
	// ZeroPadding8Bytes (TrueType) // Conditional: item.Flags.29
	PacketOffset  int64  // Conditional: item.Flags.30
	WindowControl uint32 // Conditional: item.Flags.31
}

func (NetUdpPacketEncHeader) TLName() string { return "netUdpPacket.encHeader" }
func (NetUdpPacketEncHeader) TLTag() uint32  { return 0x251a7bfd }

func (item *NetUdpPacketEncHeader) SetTime(v int32) {
	item.Time = v
	item.Flags |= 1 << 9
}
func (item *NetUdpPacketEncHeader) ClearTime() {
	item.Time = 0
	item.Flags &^= 1 << 9
}
func (item *NetUdpPacketEncHeader) IsSetTime() bool { return item.Flags&(1<<9) != 0 }

func (item *NetUdpPacketEncHeader) SetVersion(v int32) {
	item.Version = v
	item.Flags |= 1 << 10
}
func (item *NetUdpPacketEncHeader) ClearVersion() {
	item.Version = 0
	item.Flags &^= 1 << 10
}
func (item *NetUdpPacketEncHeader) IsSetVersion() bool { return item.Flags&(1<<10) != 0 }

func (item *NetUdpPacketEncHeader) SetPacketAckPrefix(v uint32) {
	item.PacketAckPrefix = v
	item.Flags |= 1 << 13
}
func (item *NetUdpPacketEncHeader) ClearPacketAckPrefix() {
	item.PacketAckPrefix = 0
	item.Flags &^= 1 << 13
}
func (item *NetUdpPacketEncHeader) IsSetPacketAckPrefix() bool { return item.Flags&(1<<13) != 0 }

func (item *NetUdpPacketEncHeader) SetPacketAckFrom(v uint32) {
	item.PacketAckFrom = v
	item.Flags |= 1 << 14
}
func (item *NetUdpPacketEncHeader) ClearPacketAckFrom() {
	item.PacketAckFrom = 0
	item.Flags &^= 1 << 14
}
func (item *NetUdpPacketEncHeader) IsSetPacketAckFrom() bool { return item.Flags&(1<<14) != 0 }

func (item *NetUdpPacketEncHeader) SetPacketAckTo(v uint32) {
	item.PacketAckTo = v
	item.Flags |= 1 << 14
}
func (item *NetUdpPacketEncHeader) ClearPacketAckTo() {
	item.PacketAckTo = 0
	item.Flags &^= 1 << 14
}
func (item *NetUdpPacketEncHeader) IsSetPacketAckTo() bool { return item.Flags&(1<<14) != 0 }

func (item *NetUdpPacketEncHeader) SetPacketAckSet(v []uint32) {
	item.PacketAckSet = v
	item.Flags |= 1 << 15
}
func (item *NetUdpPacketEncHeader) ClearPacketAckSet() {
	item.PacketAckSet = item.PacketAckSet[:0]
	item.Flags &^= 1 << 15
}
func (item *NetUdpPacketEncHeader) IsSetPacketAckSet() bool { return item.Flags&(1<<15) != 0 }

func (item *NetUdpPacketEncHeader) SetPacketNum(v uint32) {
	item.PacketNum = v
	item.Flags |= 1 << 20
}
func (item *NetUdpPacketEncHeader) ClearPacketNum() {
	item.PacketNum = 0
	item.Flags &^= 1 << 20
}
func (item *NetUdpPacketEncHeader) IsSetPacketNum() bool { return item.Flags&(1<<20) != 0 }

func (item *NetUdpPacketEncHeader) SetPacketsFrom(v uint32) {
	item.PacketsFrom = v
	item.Flags |= 1 << 21
}
func (item *NetUdpPacketEncHeader) ClearPacketsFrom() {
	item.PacketsFrom = 0
	item.Flags &^= 1 << 21
}
func (item *NetUdpPacketEncHeader) IsSetPacketsFrom() bool { return item.Flags&(1<<21) != 0 }

func (item *NetUdpPacketEncHeader) SetPacketsCount(v uint32) {
	item.PacketsCount = v
	item.Flags |= 1 << 21
}
func (item *NetUdpPacketEncHeader) ClearPacketsCount() {
	item.PacketsCount = 0
	item.Flags &^= 1 << 21
}
func (item *NetUdpPacketEncHeader) IsSetPacketsCount() bool { return item.Flags&(1<<21) != 0 }

func (item *NetUdpPacketEncHeader) SetPrevParts(v uint32) {
	item.PrevParts = v
	item.Flags |= 1 << 22
}
func (item *NetUdpPacketEncHeader) ClearPrevParts() {
	item.PrevParts = 0
	item.Flags &^= 1 << 22
}
func (item *NetUdpPacketEncHeader) IsSetPrevParts() bool { return item.Flags&(1<<22) != 0 }

func (item *NetUdpPacketEncHeader) SetNextParts(v uint32) {
	item.NextParts = v
	item.Flags |= 1 << 23
}
func (item *NetUdpPacketEncHeader) ClearNextParts() {
	item.NextParts = 0
	item.Flags &^= 1 << 23
}
func (item *NetUdpPacketEncHeader) IsSetNextParts() bool { return item.Flags&(1<<23) != 0 }

func (item *NetUdpPacketEncHeader) SetPrevLength(v uint32) {
	item.PrevLength = v
	item.Flags |= 1 << 24
}
func (item *NetUdpPacketEncHeader) ClearPrevLength() {
	item.PrevLength = 0
	item.Flags &^= 1 << 24
}
func (item *NetUdpPacketEncHeader) IsSetPrevLength() bool { return item.Flags&(1<<24) != 0 }

func (item *NetUdpPacketEncHeader) SetNextLength(v uint32) {
	item.NextLength = v
	item.Flags |= 1 << 25
}
func (item *NetUdpPacketEncHeader) ClearNextLength() {
	item.NextLength = 0
	item.Flags &^= 1 << 25
}
func (item *NetUdpPacketEncHeader) IsSetNextLength() bool { return item.Flags&(1<<25) != 0 }

func (item *NetUdpPacketEncHeader) SetSingleRpcMsg(v bool) {
	if v {
		item.Flags |= 1 << 26
	} else {
		item.Flags &^= 1 << 26
	}
}
func (item *NetUdpPacketEncHeader) IsSetSingleRpcMsg() bool { return item.Flags&(1<<26) != 0 }

func (item *NetUdpPacketEncHeader) SetMultipleRpcMsgs(v bool) {
	if v {
		item.Flags |= 1 << 27
	} else {
		item.Flags &^= 1 << 27
	}
}
func (item *NetUdpPacketEncHeader) IsSetMultipleRpcMsgs() bool { return item.Flags&(1<<27) != 0 }

func (item *NetUdpPacketEncHeader) SetZeroPadding4Bytes(v bool) {
	if v {
		item.Flags |= 1 << 28
	} else {
		item.Flags &^= 1 << 28
	}
}
func (item *NetUdpPacketEncHeader) IsSetZeroPadding4Bytes() bool { return item.Flags&(1<<28) != 0 }

func (item *NetUdpPacketEncHeader) SetZeroPadding8Bytes(v bool) {
	if v {
		item.Flags |= 1 << 29
	} else {
		item.Flags &^= 1 << 29
	}
}
func (item *NetUdpPacketEncHeader) IsSetZeroPadding8Bytes() bool { return item.Flags&(1<<29) != 0 }

func (item *NetUdpPacketEncHeader) SetPacketOffset(v int64) {
	item.PacketOffset = v
	item.Flags |= 1 << 30
}
func (item *NetUdpPacketEncHeader) ClearPacketOffset() {
	item.PacketOffset = 0
	item.Flags &^= 1 << 30
}
func (item *NetUdpPacketEncHeader) IsSetPacketOffset() bool { return item.Flags&(1<<30) != 0 }

func (item *NetUdpPacketEncHeader) SetWindowControl(v uint32) {
	item.WindowControl = v
	item.Flags |= 1 << 31
}
func (item *NetUdpPacketEncHeader) ClearWindowControl() {
	item.WindowControl = 0
	item.Flags &^= 1 << 31
}
func (item *NetUdpPacketEncHeader) IsSetWindowControl() bool { return item.Flags&(1<<31) != 0 }

func (item *NetUdpPacketEncHeader) Reset() {
	item.Flags = 0
	item.Time = 0
	item.Version = 0
	item.PacketAckPrefix = 0
	item.PacketAckFrom = 0
	item.PacketAckTo = 0
	item.PacketAckSet = item.PacketAckSet[:0]
	item.PacketNum = 0
	item.PacketsFrom = 0
	item.PacketsCount = 0
	item.PrevParts = 0
	item.NextParts = 0
	item.PrevLength = 0
	item.NextLength = 0
	item.PacketOffset = 0
	item.WindowControl = 0
}

func (item *NetUdpPacketEncHeader) FillRandom(rg *basictl.RandGenerator) {
	var maskFlags uint32
	maskFlags = basictl.RandomUint(rg)
	item.Flags = 0
	if maskFlags&(1<<0) != 0 {
		item.Flags |= (1 << 9)
	}
	if maskFlags&(1<<1) != 0 {
		item.Flags |= (1 << 10)
	}
	if maskFlags&(1<<2) != 0 {
		item.Flags |= (1 << 13)
	}
	if maskFlags&(1<<3) != 0 {
		item.Flags |= (1 << 14)
	}
	if maskFlags&(1<<4) != 0 {
		item.Flags |= (1 << 15)
	}
	if maskFlags&(1<<5) != 0 {
		item.Flags |= (1 << 20)
	}
	if maskFlags&(1<<6) != 0 {
		item.Flags |= (1 << 21)
	}
	if maskFlags&(1<<7) != 0 {
		item.Flags |= (1 << 22)
	}
	if maskFlags&(1<<8) != 0 {
		item.Flags |= (1 << 23)
	}
	if maskFlags&(1<<9) != 0 {
		item.Flags |= (1 << 24)
	}
	if maskFlags&(1<<10) != 0 {
		item.Flags |= (1 << 25)
	}
	if maskFlags&(1<<11) != 0 {
		item.Flags |= (1 << 26)
	}
	if maskFlags&(1<<12) != 0 {
		item.Flags |= (1 << 27)
	}
	if maskFlags&(1<<13) != 0 {
		item.Flags |= (1 << 28)
	}
	if maskFlags&(1<<14) != 0 {
		item.Flags |= (1 << 29)
	}
	if maskFlags&(1<<15) != 0 {
		item.Flags |= (1 << 30)
	}
	if maskFlags&(1<<16) != 0 {
		item.Flags |= (1 << 31)
	}
	if item.Flags&(1<<9) != 0 {
		item.Time = basictl.RandomInt(rg)
	} else {
		item.Time = 0
	}
	if item.Flags&(1<<10) != 0 {
		item.Version = basictl.RandomInt(rg)
	} else {
		item.Version = 0
	}
	if item.Flags&(1<<13) != 0 {
		item.PacketAckPrefix = basictl.RandomUint(rg)
	} else {
		item.PacketAckPrefix = 0
	}
	if item.Flags&(1<<14) != 0 {
		item.PacketAckFrom = basictl.RandomUint(rg)
	} else {
		item.PacketAckFrom = 0
	}
	if item.Flags&(1<<14) != 0 {
		item.PacketAckTo = basictl.RandomUint(rg)
	} else {
		item.PacketAckTo = 0
	}
	if item.Flags&(1<<15) != 0 {
		BuiltinVectorFillRandom(rg, &item.PacketAckSet)
	} else {
		item.PacketAckSet = item.PacketAckSet[:0]
	}
	if item.Flags&(1<<20) != 0 {
		item.PacketNum = basictl.RandomUint(rg)
	} else {
		item.PacketNum = 0
	}
	if item.Flags&(1<<21) != 0 {
		item.PacketsFrom = basictl.RandomUint(rg)
	} else {
		item.PacketsFrom = 0
	}
	if item.Flags&(1<<21) != 0 {
		item.PacketsCount = basictl.RandomUint(rg)
	} else {
		item.PacketsCount = 0
	}
	if item.Flags&(1<<22) != 0 {
		item.PrevParts = basictl.RandomUint(rg)
	} else {
		item.PrevParts = 0
	}
	if item.Flags&(1<<23) != 0 {
		item.NextParts = basictl.RandomUint(rg)
	} else {
		item.NextParts = 0
	}
	if item.Flags&(1<<24) != 0 {
		item.PrevLength = basictl.RandomUint(rg)
	} else {
		item.PrevLength = 0
	}
	if item.Flags&(1<<25) != 0 {
		item.NextLength = basictl.RandomUint(rg)
	} else {
		item.NextLength = 0
	}
	if item.Flags&(1<<30) != 0 {
		item.PacketOffset = basictl.RandomLong(rg)
	} else {
		item.PacketOffset = 0
	}
	if item.Flags&(1<<31) != 0 {
		item.WindowControl = basictl.RandomUint(rg)
	} else {
		item.WindowControl = 0
	}
}

func (item *NetUdpPacketEncHeader) Read(w []byte) (_ []byte, err error) {
	if w, err = basictl.NatRead(w, &item.Flags); err != nil {
		return w, err
	}
	if item.Flags&(1<<9) != 0 {
		if w, err = basictl.IntRead(w, &item.Time); err != nil {
			return w, err
		}
	} else {
		item.Time = 0
	}
	if item.Flags&(1<<10) != 0 {
		if w, err = basictl.IntRead(w, &item.Version); err != nil {
			return w, err
		}
	} else {
		item.Version = 0
	}
	if item.Flags&(1<<13) != 0 {
		if w, err = basictl.NatRead(w, &item.PacketAckPrefix); err != nil {
			return w, err
		}
	} else {
		item.PacketAckPrefix = 0
	}
	if item.Flags&(1<<14) != 0 {
		if w, err = basictl.NatRead(w, &item.PacketAckFrom); err != nil {
			return w, err
		}
	} else {
		item.PacketAckFrom = 0
	}
	if item.Flags&(1<<14) != 0 {
		if w, err = basictl.NatRead(w, &item.PacketAckTo); err != nil {
			return w, err
		}
	} else {
		item.PacketAckTo = 0
	}
	if item.Flags&(1<<15) != 0 {
		if w, err = BuiltinVectorRead(w, &item.PacketAckSet); err != nil {
			return w, err
		}
	} else {
		item.PacketAckSet = item.PacketAckSet[:0]
	}
	if item.Flags&(1<<20) != 0 {
		if w, err = basictl.NatRead(w, &item.PacketNum); err != nil {
			return w, err
		}
	} else {
		item.PacketNum = 0
	}
	if item.Flags&(1<<21) != 0 {
		if w, err = basictl.NatRead(w, &item.PacketsFrom); err != nil {
			return w, err
		}
	} else {
		item.PacketsFrom = 0
	}
	if item.Flags&(1<<21) != 0 {
		if w, err = basictl.NatRead(w, &item.PacketsCount); err != nil {
			return w, err
		}
	} else {
		item.PacketsCount = 0
	}
	if item.Flags&(1<<22) != 0 {
		if w, err = basictl.NatRead(w, &item.PrevParts); err != nil {
			return w, err
		}
	} else {
		item.PrevParts = 0
	}
	if item.Flags&(1<<23) != 0 {
		if w, err = basictl.NatRead(w, &item.NextParts); err != nil {
			return w, err
		}
	} else {
		item.NextParts = 0
	}
	if item.Flags&(1<<24) != 0 {
		if w, err = basictl.NatRead(w, &item.PrevLength); err != nil {
			return w, err
		}
	} else {
		item.PrevLength = 0
	}
	if item.Flags&(1<<25) != 0 {
		if w, err = basictl.NatRead(w, &item.NextLength); err != nil {
			return w, err
		}
	} else {
		item.NextLength = 0
	}
	if item.Flags&(1<<30) != 0 {
		if w, err = basictl.LongRead(w, &item.PacketOffset); err != nil {
			return w, err
		}
	} else {
		item.PacketOffset = 0
	}
	if item.Flags&(1<<31) != 0 {
		if w, err = basictl.NatRead(w, &item.WindowControl); err != nil {
			return w, err
		}
	} else {
		item.WindowControl = 0
	}
	return w, nil
}

func (item *NetUdpPacketEncHeader) WriteGeneral(w []byte) (_ []byte, err error) {
	return item.Write(w), nil
}

func (item *NetUdpPacketEncHeader) Write(w []byte) []byte {
	w = basictl.NatWrite(w, item.Flags)
	if item.Flags&(1<<9) != 0 {
		w = basictl.IntWrite(w, item.Time)
	}
	if item.Flags&(1<<10) != 0 {
		w = basictl.IntWrite(w, item.Version)
	}
	if item.Flags&(1<<13) != 0 {
		w = basictl.NatWrite(w, item.PacketAckPrefix)
	}
	if item.Flags&(1<<14) != 0 {
		w = basictl.NatWrite(w, item.PacketAckFrom)
	}
	if item.Flags&(1<<14) != 0 {
		w = basictl.NatWrite(w, item.PacketAckTo)
	}
	if item.Flags&(1<<15) != 0 {
		w = BuiltinVectorWrite(w, item.PacketAckSet)
	}
	if item.Flags&(1<<20) != 0 {
		w = basictl.NatWrite(w, item.PacketNum)
	}
	if item.Flags&(1<<21) != 0 {
		w = basictl.NatWrite(w, item.PacketsFrom)
	}
	if item.Flags&(1<<21) != 0 {
		w = basictl.NatWrite(w, item.PacketsCount)
	}
	if item.Flags&(1<<22) != 0 {
		w = basictl.NatWrite(w, item.PrevParts)
	}
	if item.Flags&(1<<23) != 0 {
		w = basictl.NatWrite(w, item.NextParts)
	}
	if item.Flags&(1<<24) != 0 {
		w = basictl.NatWrite(w, item.PrevLength)
	}
	if item.Flags&(1<<25) != 0 {
		w = basictl.NatWrite(w, item.NextLength)
	}
	if item.Flags&(1<<30) != 0 {
		w = basictl.LongWrite(w, item.PacketOffset)
	}
	if item.Flags&(1<<31) != 0 {
		w = basictl.NatWrite(w, item.WindowControl)
	}
	return w
}

func (item *NetUdpPacketEncHeader) ReadBoxed(w []byte) (_ []byte, err error) {
	if w, err = basictl.NatReadExactTag(w, 0x251a7bfd); err != nil {
		return w, err
	}
	return item.Read(w)
}

func (item *NetUdpPacketEncHeader) WriteBoxedGeneral(w []byte) (_ []byte, err error) {
	return item.WriteBoxed(w), nil
}

func (item *NetUdpPacketEncHeader) WriteBoxed(w []byte) []byte {
	w = basictl.NatWrite(w, 0x251a7bfd)
	return item.Write(w)
}

func (item NetUdpPacketEncHeader) String() string {
	return string(item.WriteJSON(nil))
}

func (item *NetUdpPacketEncHeader) ReadJSON(legacyTypeNames bool, in *basictl.JsonLexer) error {
	var propFlagsPresented bool
	var propTimePresented bool
	var propVersionPresented bool
	var propPacketAckPrefixPresented bool
	var propPacketAckFromPresented bool
	var propPacketAckToPresented bool
	var propPacketAckSetPresented bool
	var propPacketNumPresented bool
	var propPacketsFromPresented bool
	var propPacketsCountPresented bool
	var propPrevPartsPresented bool
	var propNextPartsPresented bool
	var propPrevLengthPresented bool
	var propNextLengthPresented bool
	var trueTypeSingleRpcMsgPresented bool
	var trueTypeSingleRpcMsgValue bool
	var trueTypeMultipleRpcMsgsPresented bool
	var trueTypeMultipleRpcMsgsValue bool
	var trueTypeZeroPadding4BytesPresented bool
	var trueTypeZeroPadding4BytesValue bool
	var trueTypeZeroPadding8BytesPresented bool
	var trueTypeZeroPadding8BytesValue bool
	var propPacketOffsetPresented bool
	var propWindowControlPresented bool

	if in != nil {
		in.Delim('{')
		if !in.Ok() {
			return in.Error()
		}
		for !in.IsDelim('}') {
			key := in.UnsafeFieldName(true)
			in.WantColon()
			switch key {
			case "flags":
				if propFlagsPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("netUdpPacket.encHeader", "flags")
				}
				if err := Json2ReadUint32(in, &item.Flags); err != nil {
					return err
				}
				propFlagsPresented = true
			case "time":
				if propTimePresented {
					return ErrorInvalidJSONWithDuplicatingKeys("netUdpPacket.encHeader", "time")
				}
				if err := Json2ReadInt32(in, &item.Time); err != nil {
					return err
				}
				propTimePresented = true
			case "version":
				if propVersionPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("netUdpPacket.encHeader", "version")
				}
				if err := Json2ReadInt32(in, &item.Version); err != nil {
					return err
				}
				propVersionPresented = true
			case "packet_ack_prefix":
				if propPacketAckPrefixPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("netUdpPacket.encHeader", "packet_ack_prefix")
				}
				if err := Json2ReadUint32(in, &item.PacketAckPrefix); err != nil {
					return err
				}
				propPacketAckPrefixPresented = true
			case "packet_ack_from":
				if propPacketAckFromPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("netUdpPacket.encHeader", "packet_ack_from")
				}
				if err := Json2ReadUint32(in, &item.PacketAckFrom); err != nil {
					return err
				}
				propPacketAckFromPresented = true
			case "packet_ack_to":
				if propPacketAckToPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("netUdpPacket.encHeader", "packet_ack_to")
				}
				if err := Json2ReadUint32(in, &item.PacketAckTo); err != nil {
					return err
				}
				propPacketAckToPresented = true
			case "packet_ack_set":
				if propPacketAckSetPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("netUdpPacket.encHeader", "packet_ack_set")
				}
				if err := BuiltinVectorReadJSON(legacyTypeNames, in, &item.PacketAckSet); err != nil {
					return err
				}
				propPacketAckSetPresented = true
			case "packet_num":
				if propPacketNumPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("netUdpPacket.encHeader", "packet_num")
				}
				if err := Json2ReadUint32(in, &item.PacketNum); err != nil {
					return err
				}
				propPacketNumPresented = true
			case "packets_from":
				if propPacketsFromPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("netUdpPacket.encHeader", "packets_from")
				}
				if err := Json2ReadUint32(in, &item.PacketsFrom); err != nil {
					return err
				}
				propPacketsFromPresented = true
			case "packets_count":
				if propPacketsCountPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("netUdpPacket.encHeader", "packets_count")
				}
				if err := Json2ReadUint32(in, &item.PacketsCount); err != nil {
					return err
				}
				propPacketsCountPresented = true
			case "prev_parts":
				if propPrevPartsPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("netUdpPacket.encHeader", "prev_parts")
				}
				if err := Json2ReadUint32(in, &item.PrevParts); err != nil {
					return err
				}
				propPrevPartsPresented = true
			case "next_parts":
				if propNextPartsPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("netUdpPacket.encHeader", "next_parts")
				}
				if err := Json2ReadUint32(in, &item.NextParts); err != nil {
					return err
				}
				propNextPartsPresented = true
			case "prev_length":
				if propPrevLengthPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("netUdpPacket.encHeader", "prev_length")
				}
				if err := Json2ReadUint32(in, &item.PrevLength); err != nil {
					return err
				}
				propPrevLengthPresented = true
			case "next_length":
				if propNextLengthPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("netUdpPacket.encHeader", "next_length")
				}
				if err := Json2ReadUint32(in, &item.NextLength); err != nil {
					return err
				}
				propNextLengthPresented = true
			case "single_rpc_msg":
				if trueTypeSingleRpcMsgPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("netUdpPacket.encHeader", "single_rpc_msg")
				}
				if err := Json2ReadBool(in, &trueTypeSingleRpcMsgValue); err != nil {
					return err
				}
				trueTypeSingleRpcMsgPresented = true
			case "multiple_rpc_msgs":
				if trueTypeMultipleRpcMsgsPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("netUdpPacket.encHeader", "multiple_rpc_msgs")
				}
				if err := Json2ReadBool(in, &trueTypeMultipleRpcMsgsValue); err != nil {
					return err
				}
				trueTypeMultipleRpcMsgsPresented = true
			case "zero_padding_4_bytes":
				if trueTypeZeroPadding4BytesPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("netUdpPacket.encHeader", "zero_padding_4_bytes")
				}
				if err := Json2ReadBool(in, &trueTypeZeroPadding4BytesValue); err != nil {
					return err
				}
				trueTypeZeroPadding4BytesPresented = true
			case "zero_padding_8_bytes":
				if trueTypeZeroPadding8BytesPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("netUdpPacket.encHeader", "zero_padding_8_bytes")
				}
				if err := Json2ReadBool(in, &trueTypeZeroPadding8BytesValue); err != nil {
					return err
				}
				trueTypeZeroPadding8BytesPresented = true
			case "packet_offset":
				if propPacketOffsetPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("netUdpPacket.encHeader", "packet_offset")
				}
				if err := Json2ReadInt64(in, &item.PacketOffset); err != nil {
					return err
				}
				propPacketOffsetPresented = true
			case "window_control":
				if propWindowControlPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("netUdpPacket.encHeader", "window_control")
				}
				if err := Json2ReadUint32(in, &item.WindowControl); err != nil {
					return err
				}
				propWindowControlPresented = true
			default:
				return ErrorInvalidJSONExcessElement("netUdpPacket.encHeader", key)
			}
			in.WantComma()
		}
		in.Delim('}')
		if !in.Ok() {
			return in.Error()
		}
	}
	if !propFlagsPresented {
		item.Flags = 0
	}
	if !propTimePresented {
		item.Time = 0
	}
	if !propVersionPresented {
		item.Version = 0
	}
	if !propPacketAckPrefixPresented {
		item.PacketAckPrefix = 0
	}
	if !propPacketAckFromPresented {
		item.PacketAckFrom = 0
	}
	if !propPacketAckToPresented {
		item.PacketAckTo = 0
	}
	if !propPacketAckSetPresented {
		item.PacketAckSet = item.PacketAckSet[:0]
	}
	if !propPacketNumPresented {
		item.PacketNum = 0
	}
	if !propPacketsFromPresented {
		item.PacketsFrom = 0
	}
	if !propPacketsCountPresented {
		item.PacketsCount = 0
	}
	if !propPrevPartsPresented {
		item.PrevParts = 0
	}
	if !propNextPartsPresented {
		item.NextParts = 0
	}
	if !propPrevLengthPresented {
		item.PrevLength = 0
	}
	if !propNextLengthPresented {
		item.NextLength = 0
	}
	if !propPacketOffsetPresented {
		item.PacketOffset = 0
	}
	if !propWindowControlPresented {
		item.WindowControl = 0
	}
	if propTimePresented {
		item.Flags |= 1 << 9
	}
	if propVersionPresented {
		item.Flags |= 1 << 10
	}
	if propPacketAckPrefixPresented {
		item.Flags |= 1 << 13
	}
	if propPacketAckFromPresented {
		item.Flags |= 1 << 14
	}
	if propPacketAckToPresented {
		item.Flags |= 1 << 14
	}
	if propPacketAckSetPresented {
		item.Flags |= 1 << 15
	}
	if propPacketNumPresented {
		item.Flags |= 1 << 20
	}
	if propPacketsFromPresented {
		item.Flags |= 1 << 21
	}
	if propPacketsCountPresented {
		item.Flags |= 1 << 21
	}
	if propPrevPartsPresented {
		item.Flags |= 1 << 22
	}
	if propNextPartsPresented {
		item.Flags |= 1 << 23
	}
	if propPrevLengthPresented {
		item.Flags |= 1 << 24
	}
	if propNextLengthPresented {
		item.Flags |= 1 << 25
	}
	if trueTypeSingleRpcMsgPresented {
		if trueTypeSingleRpcMsgValue {
			item.Flags |= 1 << 26
		}
	}
	if trueTypeMultipleRpcMsgsPresented {
		if trueTypeMultipleRpcMsgsValue {
			item.Flags |= 1 << 27
		}
	}
	if trueTypeZeroPadding4BytesPresented {
		if trueTypeZeroPadding4BytesValue {
			item.Flags |= 1 << 28
		}
	}
	if trueTypeZeroPadding8BytesPresented {
		if trueTypeZeroPadding8BytesValue {
			item.Flags |= 1 << 29
		}
	}
	if propPacketOffsetPresented {
		item.Flags |= 1 << 30
	}
	if propWindowControlPresented {
		item.Flags |= 1 << 31
	}
	// tries to set bit to zero if it is 1
	if trueTypeSingleRpcMsgPresented && !trueTypeSingleRpcMsgValue && (item.Flags&(1<<26) != 0) {
		return ErrorInvalidJSON("netUdpPacket.encHeader", "fieldmask bit flags.0 is indefinite because of the contradictions in values")
	}
	// tries to set bit to zero if it is 1
	if trueTypeMultipleRpcMsgsPresented && !trueTypeMultipleRpcMsgsValue && (item.Flags&(1<<27) != 0) {
		return ErrorInvalidJSON("netUdpPacket.encHeader", "fieldmask bit flags.0 is indefinite because of the contradictions in values")
	}
	// tries to set bit to zero if it is 1
	if trueTypeZeroPadding4BytesPresented && !trueTypeZeroPadding4BytesValue && (item.Flags&(1<<28) != 0) {
		return ErrorInvalidJSON("netUdpPacket.encHeader", "fieldmask bit flags.0 is indefinite because of the contradictions in values")
	}
	// tries to set bit to zero if it is 1
	if trueTypeZeroPadding8BytesPresented && !trueTypeZeroPadding8BytesValue && (item.Flags&(1<<29) != 0) {
		return ErrorInvalidJSON("netUdpPacket.encHeader", "fieldmask bit flags.0 is indefinite because of the contradictions in values")
	}
	return nil
}

// This method is general version of WriteJSON, use it instead!
func (item *NetUdpPacketEncHeader) WriteJSONGeneral(w []byte) (_ []byte, err error) {
	return item.WriteJSONOpt(true, false, w), nil
}

func (item *NetUdpPacketEncHeader) WriteJSON(w []byte) []byte {
	return item.WriteJSONOpt(true, false, w)
}
func (item *NetUdpPacketEncHeader) WriteJSONOpt(newTypeNames bool, short bool, w []byte) []byte {
	w = append(w, '{')
	backupIndexFlags := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"flags":`...)
	w = basictl.JSONWriteUint32(w, item.Flags)
	if (item.Flags != 0) == false {
		w = w[:backupIndexFlags]
	}
	if item.Flags&(1<<9) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"time":`...)
		w = basictl.JSONWriteInt32(w, item.Time)
	}
	if item.Flags&(1<<10) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"version":`...)
		w = basictl.JSONWriteInt32(w, item.Version)
	}
	if item.Flags&(1<<13) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"packet_ack_prefix":`...)
		w = basictl.JSONWriteUint32(w, item.PacketAckPrefix)
	}
	if item.Flags&(1<<14) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"packet_ack_from":`...)
		w = basictl.JSONWriteUint32(w, item.PacketAckFrom)
	}
	if item.Flags&(1<<14) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"packet_ack_to":`...)
		w = basictl.JSONWriteUint32(w, item.PacketAckTo)
	}
	if item.Flags&(1<<15) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"packet_ack_set":`...)
		w = BuiltinVectorWriteJSONOpt(newTypeNames, short, w, item.PacketAckSet)
	}
	if item.Flags&(1<<20) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"packet_num":`...)
		w = basictl.JSONWriteUint32(w, item.PacketNum)
	}
	if item.Flags&(1<<21) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"packets_from":`...)
		w = basictl.JSONWriteUint32(w, item.PacketsFrom)
	}
	if item.Flags&(1<<21) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"packets_count":`...)
		w = basictl.JSONWriteUint32(w, item.PacketsCount)
	}
	if item.Flags&(1<<22) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"prev_parts":`...)
		w = basictl.JSONWriteUint32(w, item.PrevParts)
	}
	if item.Flags&(1<<23) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"next_parts":`...)
		w = basictl.JSONWriteUint32(w, item.NextParts)
	}
	if item.Flags&(1<<24) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"prev_length":`...)
		w = basictl.JSONWriteUint32(w, item.PrevLength)
	}
	if item.Flags&(1<<25) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"next_length":`...)
		w = basictl.JSONWriteUint32(w, item.NextLength)
	}
	if item.Flags&(1<<26) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"single_rpc_msg":true`...)
	}
	if item.Flags&(1<<27) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"multiple_rpc_msgs":true`...)
	}
	if item.Flags&(1<<28) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"zero_padding_4_bytes":true`...)
	}
	if item.Flags&(1<<29) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"zero_padding_8_bytes":true`...)
	}
	if item.Flags&(1<<30) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"packet_offset":`...)
		w = basictl.JSONWriteInt64(w, item.PacketOffset)
	}
	if item.Flags&(1<<31) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"window_control":`...)
		w = basictl.JSONWriteUint32(w, item.WindowControl)
	}
	return append(w, '}')
}

func (item *NetUdpPacketEncHeader) MarshalJSON() ([]byte, error) {
	return item.WriteJSON(nil), nil
}

func (item *NetUdpPacketEncHeader) UnmarshalJSON(b []byte) error {
	if err := item.ReadJSON(true, &basictl.JsonLexer{Data: b}); err != nil {
		return ErrorInvalidJSON("netUdpPacket.encHeader", err.Error())
	}
	return nil
}
