// Copyright 2024 V Kontakte LLC
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

// Code generated by vktl/cmd/tlgen2; DO NOT EDIT.
package internal

import (
	"github.com/vkcom/statshouse/internal/vkgo/basictl"
)

var _ = basictl.NatWrite

type NetUdpPacketEncHeader struct {
	Flags           uint32
	Time            int32   // Conditional: item.Flags.9
	Version         int32   // Conditional: item.Flags.10
	PacketAckPrefix int32   // Conditional: item.Flags.13
	PacketAckFrom   int32   // Conditional: item.Flags.14
	PacketAckTo     int32   // Conditional: item.Flags.14
	PacketAckSet    []int32 // Conditional: item.Flags.15
	PacketNum       int32   // Conditional: item.Flags.20
	PacketsFrom     int32   // Conditional: item.Flags.21
	PacketsTo       int32   // Conditional: item.Flags.21
	PrevParts       int32   // Conditional: item.Flags.22
	NextParts       int32   // Conditional: item.Flags.23
}

func (NetUdpPacketEncHeader) TLName() string { return "netUdpPacket.encHeader" }
func (NetUdpPacketEncHeader) TLTag() uint32  { return 0x251a7bfd }

func (item *NetUdpPacketEncHeader) SetTime(v int32) {
	item.Time = v
	item.Flags |= 1 << 9
}
func (item *NetUdpPacketEncHeader) ClearTime() {
	item.Time = 0
	item.Flags &^= 1 << 9
}
func (item NetUdpPacketEncHeader) IsSetTime() bool { return item.Flags&(1<<9) != 0 }

func (item *NetUdpPacketEncHeader) SetVersion(v int32) {
	item.Version = v
	item.Flags |= 1 << 10
}
func (item *NetUdpPacketEncHeader) ClearVersion() {
	item.Version = 0
	item.Flags &^= 1 << 10
}
func (item NetUdpPacketEncHeader) IsSetVersion() bool { return item.Flags&(1<<10) != 0 }

func (item *NetUdpPacketEncHeader) SetPacketAckPrefix(v int32) {
	item.PacketAckPrefix = v
	item.Flags |= 1 << 13
}
func (item *NetUdpPacketEncHeader) ClearPacketAckPrefix() {
	item.PacketAckPrefix = 0
	item.Flags &^= 1 << 13
}
func (item NetUdpPacketEncHeader) IsSetPacketAckPrefix() bool { return item.Flags&(1<<13) != 0 }

func (item *NetUdpPacketEncHeader) SetPacketAckFrom(v int32) {
	item.PacketAckFrom = v
	item.Flags |= 1 << 14
}
func (item *NetUdpPacketEncHeader) ClearPacketAckFrom() {
	item.PacketAckFrom = 0
	item.Flags &^= 1 << 14
}
func (item NetUdpPacketEncHeader) IsSetPacketAckFrom() bool { return item.Flags&(1<<14) != 0 }

func (item *NetUdpPacketEncHeader) SetPacketAckTo(v int32) {
	item.PacketAckTo = v
	item.Flags |= 1 << 14
}
func (item *NetUdpPacketEncHeader) ClearPacketAckTo() {
	item.PacketAckTo = 0
	item.Flags &^= 1 << 14
}
func (item NetUdpPacketEncHeader) IsSetPacketAckTo() bool { return item.Flags&(1<<14) != 0 }

func (item *NetUdpPacketEncHeader) SetPacketAckSet(v []int32) {
	item.PacketAckSet = v
	item.Flags |= 1 << 15
}
func (item *NetUdpPacketEncHeader) ClearPacketAckSet() {
	item.PacketAckSet = item.PacketAckSet[:0]
	item.Flags &^= 1 << 15
}
func (item NetUdpPacketEncHeader) IsSetPacketAckSet() bool { return item.Flags&(1<<15) != 0 }

func (item *NetUdpPacketEncHeader) SetPacketNum(v int32) {
	item.PacketNum = v
	item.Flags |= 1 << 20
}
func (item *NetUdpPacketEncHeader) ClearPacketNum() {
	item.PacketNum = 0
	item.Flags &^= 1 << 20
}
func (item NetUdpPacketEncHeader) IsSetPacketNum() bool { return item.Flags&(1<<20) != 0 }

func (item *NetUdpPacketEncHeader) SetPacketsFrom(v int32) {
	item.PacketsFrom = v
	item.Flags |= 1 << 21
}
func (item *NetUdpPacketEncHeader) ClearPacketsFrom() {
	item.PacketsFrom = 0
	item.Flags &^= 1 << 21
}
func (item NetUdpPacketEncHeader) IsSetPacketsFrom() bool { return item.Flags&(1<<21) != 0 }

func (item *NetUdpPacketEncHeader) SetPacketsTo(v int32) {
	item.PacketsTo = v
	item.Flags |= 1 << 21
}
func (item *NetUdpPacketEncHeader) ClearPacketsTo() {
	item.PacketsTo = 0
	item.Flags &^= 1 << 21
}
func (item NetUdpPacketEncHeader) IsSetPacketsTo() bool { return item.Flags&(1<<21) != 0 }

func (item *NetUdpPacketEncHeader) SetPrevParts(v int32) {
	item.PrevParts = v
	item.Flags |= 1 << 22
}
func (item *NetUdpPacketEncHeader) ClearPrevParts() {
	item.PrevParts = 0
	item.Flags &^= 1 << 22
}
func (item NetUdpPacketEncHeader) IsSetPrevParts() bool { return item.Flags&(1<<22) != 0 }

func (item *NetUdpPacketEncHeader) SetNextParts(v int32) {
	item.NextParts = v
	item.Flags |= 1 << 23
}
func (item *NetUdpPacketEncHeader) ClearNextParts() {
	item.NextParts = 0
	item.Flags &^= 1 << 23
}
func (item NetUdpPacketEncHeader) IsSetNextParts() bool { return item.Flags&(1<<23) != 0 }

func (item *NetUdpPacketEncHeader) Reset() {
	item.Flags = 0
	item.Time = 0
	item.Version = 0
	item.PacketAckPrefix = 0
	item.PacketAckFrom = 0
	item.PacketAckTo = 0
	item.PacketAckSet = item.PacketAckSet[:0]
	item.PacketNum = 0
	item.PacketsFrom = 0
	item.PacketsTo = 0
	item.PrevParts = 0
	item.NextParts = 0
}

func (item *NetUdpPacketEncHeader) Read(w []byte) (_ []byte, err error) {
	if w, err = basictl.NatRead(w, &item.Flags); err != nil {
		return w, err
	}
	if item.Flags&(1<<9) != 0 {
		if w, err = basictl.IntRead(w, &item.Time); err != nil {
			return w, err
		}
	} else {
		item.Time = 0
	}
	if item.Flags&(1<<10) != 0 {
		if w, err = basictl.IntRead(w, &item.Version); err != nil {
			return w, err
		}
	} else {
		item.Version = 0
	}
	if item.Flags&(1<<13) != 0 {
		if w, err = basictl.IntRead(w, &item.PacketAckPrefix); err != nil {
			return w, err
		}
	} else {
		item.PacketAckPrefix = 0
	}
	if item.Flags&(1<<14) != 0 {
		if w, err = basictl.IntRead(w, &item.PacketAckFrom); err != nil {
			return w, err
		}
	} else {
		item.PacketAckFrom = 0
	}
	if item.Flags&(1<<14) != 0 {
		if w, err = basictl.IntRead(w, &item.PacketAckTo); err != nil {
			return w, err
		}
	} else {
		item.PacketAckTo = 0
	}
	if item.Flags&(1<<15) != 0 {
		if w, err = BuiltinVectorIntRead(w, &item.PacketAckSet); err != nil {
			return w, err
		}
	} else {
		item.PacketAckSet = item.PacketAckSet[:0]
	}
	if item.Flags&(1<<20) != 0 {
		if w, err = basictl.IntRead(w, &item.PacketNum); err != nil {
			return w, err
		}
	} else {
		item.PacketNum = 0
	}
	if item.Flags&(1<<21) != 0 {
		if w, err = basictl.IntRead(w, &item.PacketsFrom); err != nil {
			return w, err
		}
	} else {
		item.PacketsFrom = 0
	}
	if item.Flags&(1<<21) != 0 {
		if w, err = basictl.IntRead(w, &item.PacketsTo); err != nil {
			return w, err
		}
	} else {
		item.PacketsTo = 0
	}
	if item.Flags&(1<<22) != 0 {
		if w, err = basictl.IntRead(w, &item.PrevParts); err != nil {
			return w, err
		}
	} else {
		item.PrevParts = 0
	}
	if item.Flags&(1<<23) != 0 {
		if w, err = basictl.IntRead(w, &item.NextParts); err != nil {
			return w, err
		}
	} else {
		item.NextParts = 0
	}
	return w, nil
}

func (item *NetUdpPacketEncHeader) Write(w []byte) (_ []byte, err error) {
	w = basictl.NatWrite(w, item.Flags)
	if item.Flags&(1<<9) != 0 {
		w = basictl.IntWrite(w, item.Time)
	}
	if item.Flags&(1<<10) != 0 {
		w = basictl.IntWrite(w, item.Version)
	}
	if item.Flags&(1<<13) != 0 {
		w = basictl.IntWrite(w, item.PacketAckPrefix)
	}
	if item.Flags&(1<<14) != 0 {
		w = basictl.IntWrite(w, item.PacketAckFrom)
	}
	if item.Flags&(1<<14) != 0 {
		w = basictl.IntWrite(w, item.PacketAckTo)
	}
	if item.Flags&(1<<15) != 0 {
		if w, err = BuiltinVectorIntWrite(w, item.PacketAckSet); err != nil {
			return w, err
		}
	}
	if item.Flags&(1<<20) != 0 {
		w = basictl.IntWrite(w, item.PacketNum)
	}
	if item.Flags&(1<<21) != 0 {
		w = basictl.IntWrite(w, item.PacketsFrom)
	}
	if item.Flags&(1<<21) != 0 {
		w = basictl.IntWrite(w, item.PacketsTo)
	}
	if item.Flags&(1<<22) != 0 {
		w = basictl.IntWrite(w, item.PrevParts)
	}
	if item.Flags&(1<<23) != 0 {
		w = basictl.IntWrite(w, item.NextParts)
	}
	return w, nil
}

func (item *NetUdpPacketEncHeader) ReadBoxed(w []byte) (_ []byte, err error) {
	if w, err = basictl.NatReadExactTag(w, 0x251a7bfd); err != nil {
		return w, err
	}
	return item.Read(w)
}

func (item *NetUdpPacketEncHeader) WriteBoxed(w []byte) ([]byte, error) {
	w = basictl.NatWrite(w, 0x251a7bfd)
	return item.Write(w)
}

func (item NetUdpPacketEncHeader) String() string {
	w, err := item.WriteJSON(nil)
	if err != nil {
		return err.Error()
	}
	return string(w)
}

func (item *NetUdpPacketEncHeader) ReadJSONLegacy(legacyTypeNames bool, j interface{}) error {
	_jm, _ok := j.(map[string]interface{})
	if j != nil && !_ok {
		return ErrorInvalidJSON("netUdpPacket.encHeader", "expected json object")
	}
	_jFlags := _jm["flags"]
	delete(_jm, "flags")
	if err := JsonReadUint32(_jFlags, &item.Flags); err != nil {
		return err
	}
	_jTime := _jm["time"]
	delete(_jm, "time")
	_jVersion := _jm["version"]
	delete(_jm, "version")
	_jPacketAckPrefix := _jm["packet_ack_prefix"]
	delete(_jm, "packet_ack_prefix")
	_jPacketAckFrom := _jm["packet_ack_from"]
	delete(_jm, "packet_ack_from")
	_jPacketAckTo := _jm["packet_ack_to"]
	delete(_jm, "packet_ack_to")
	_jPacketAckSet := _jm["packet_ack_set"]
	delete(_jm, "packet_ack_set")
	_jPacketNum := _jm["packet_num"]
	delete(_jm, "packet_num")
	_jPacketsFrom := _jm["packets_from"]
	delete(_jm, "packets_from")
	_jPacketsTo := _jm["packets_to"]
	delete(_jm, "packets_to")
	_jPrevParts := _jm["prev_parts"]
	delete(_jm, "prev_parts")
	_jNextParts := _jm["next_parts"]
	delete(_jm, "next_parts")
	for k := range _jm {
		return ErrorInvalidJSONExcessElement("netUdpPacket.encHeader", k)
	}
	if _jTime != nil {
		item.Flags |= 1 << 9
	}
	if _jVersion != nil {
		item.Flags |= 1 << 10
	}
	if _jPacketAckPrefix != nil {
		item.Flags |= 1 << 13
	}
	if _jPacketAckFrom != nil {
		item.Flags |= 1 << 14
	}
	if _jPacketAckTo != nil {
		item.Flags |= 1 << 14
	}
	if _jPacketAckSet != nil {
		item.Flags |= 1 << 15
	}
	if _jPacketNum != nil {
		item.Flags |= 1 << 20
	}
	if _jPacketsFrom != nil {
		item.Flags |= 1 << 21
	}
	if _jPacketsTo != nil {
		item.Flags |= 1 << 21
	}
	if _jPrevParts != nil {
		item.Flags |= 1 << 22
	}
	if _jNextParts != nil {
		item.Flags |= 1 << 23
	}
	if _jTime != nil {
		if err := JsonReadInt32(_jTime, &item.Time); err != nil {
			return err
		}
	} else {
		item.Time = 0
	}
	if _jVersion != nil {
		if err := JsonReadInt32(_jVersion, &item.Version); err != nil {
			return err
		}
	} else {
		item.Version = 0
	}
	if _jPacketAckPrefix != nil {
		if err := JsonReadInt32(_jPacketAckPrefix, &item.PacketAckPrefix); err != nil {
			return err
		}
	} else {
		item.PacketAckPrefix = 0
	}
	if _jPacketAckFrom != nil {
		if err := JsonReadInt32(_jPacketAckFrom, &item.PacketAckFrom); err != nil {
			return err
		}
	} else {
		item.PacketAckFrom = 0
	}
	if _jPacketAckTo != nil {
		if err := JsonReadInt32(_jPacketAckTo, &item.PacketAckTo); err != nil {
			return err
		}
	} else {
		item.PacketAckTo = 0
	}
	if _jPacketAckSet != nil {
		if err := BuiltinVectorIntReadJSONLegacy(legacyTypeNames, _jPacketAckSet, &item.PacketAckSet); err != nil {
			return err
		}
	} else {
		item.PacketAckSet = item.PacketAckSet[:0]
	}
	if _jPacketNum != nil {
		if err := JsonReadInt32(_jPacketNum, &item.PacketNum); err != nil {
			return err
		}
	} else {
		item.PacketNum = 0
	}
	if _jPacketsFrom != nil {
		if err := JsonReadInt32(_jPacketsFrom, &item.PacketsFrom); err != nil {
			return err
		}
	} else {
		item.PacketsFrom = 0
	}
	if _jPacketsTo != nil {
		if err := JsonReadInt32(_jPacketsTo, &item.PacketsTo); err != nil {
			return err
		}
	} else {
		item.PacketsTo = 0
	}
	if _jPrevParts != nil {
		if err := JsonReadInt32(_jPrevParts, &item.PrevParts); err != nil {
			return err
		}
	} else {
		item.PrevParts = 0
	}
	if _jNextParts != nil {
		if err := JsonReadInt32(_jNextParts, &item.NextParts); err != nil {
			return err
		}
	} else {
		item.NextParts = 0
	}
	return nil
}

func (item *NetUdpPacketEncHeader) WriteJSON(w []byte) (_ []byte, err error) {
	return item.WriteJSONOpt(true, false, w)
}
func (item *NetUdpPacketEncHeader) WriteJSONOpt(newTypeNames bool, short bool, w []byte) (_ []byte, err error) {
	w = append(w, '{')
	if item.Flags != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"flags":`...)
		w = basictl.JSONWriteUint32(w, item.Flags)
	}
	if item.Flags&(1<<9) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"time":`...)
		w = basictl.JSONWriteInt32(w, item.Time)
	}
	if item.Flags&(1<<10) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"version":`...)
		w = basictl.JSONWriteInt32(w, item.Version)
	}
	if item.Flags&(1<<13) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"packet_ack_prefix":`...)
		w = basictl.JSONWriteInt32(w, item.PacketAckPrefix)
	}
	if item.Flags&(1<<14) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"packet_ack_from":`...)
		w = basictl.JSONWriteInt32(w, item.PacketAckFrom)
	}
	if item.Flags&(1<<14) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"packet_ack_to":`...)
		w = basictl.JSONWriteInt32(w, item.PacketAckTo)
	}
	if item.Flags&(1<<15) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"packet_ack_set":`...)
		if w, err = BuiltinVectorIntWriteJSONOpt(newTypeNames, short, w, item.PacketAckSet); err != nil {
			return w, err
		}
	}
	if item.Flags&(1<<20) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"packet_num":`...)
		w = basictl.JSONWriteInt32(w, item.PacketNum)
	}
	if item.Flags&(1<<21) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"packets_from":`...)
		w = basictl.JSONWriteInt32(w, item.PacketsFrom)
	}
	if item.Flags&(1<<21) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"packets_to":`...)
		w = basictl.JSONWriteInt32(w, item.PacketsTo)
	}
	if item.Flags&(1<<22) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"prev_parts":`...)
		w = basictl.JSONWriteInt32(w, item.PrevParts)
	}
	if item.Flags&(1<<23) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"next_parts":`...)
		w = basictl.JSONWriteInt32(w, item.NextParts)
	}
	return append(w, '}'), nil
}

func (item *NetUdpPacketEncHeader) MarshalJSON() ([]byte, error) {
	return item.WriteJSON(nil)
}

func (item *NetUdpPacketEncHeader) UnmarshalJSON(b []byte) error {
	j, err := JsonBytesToInterface(b)
	if err != nil {
		return ErrorInvalidJSON("netUdpPacket.encHeader", err.Error())
	}
	if err = item.ReadJSONLegacy(true, j); err != nil {
		return ErrorInvalidJSON("netUdpPacket.encHeader", err.Error())
	}
	return nil
}
