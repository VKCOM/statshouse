// Copyright 2025 V Kontakte LLC
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

// Code generated by vktl/cmd/tlgen2; DO NOT EDIT.
package internal

import (
	"github.com/VKCOM/statshouse/internal/vkgo/basictl"
)

var _ = basictl.NatWrite

type TracingTraceContext struct {
	FieldsMask uint32
	TraceId    TracingTraceID
	ParentId   int64  // Conditional: item.FieldsMask.2
	SourceId   string // Conditional: item.FieldsMask.3
	// ReservedStatus0 (TrueType) // Conditional: item.FieldsMask.0
	// ReservedStatus1 (TrueType) // Conditional: item.FieldsMask.1
	// ReservedLevel0 (TrueType) // Conditional: item.FieldsMask.4
	// ReservedLevel1 (TrueType) // Conditional: item.FieldsMask.5
	// ReservedLevel2 (TrueType) // Conditional: item.FieldsMask.6
	// DebugFlag (TrueType) // Conditional: item.FieldsMask.7
}

func (TracingTraceContext) TLName() string { return "tracing.traceContext" }
func (TracingTraceContext) TLTag() uint32  { return 0xc463a95c }

func (item *TracingTraceContext) SetParentId(v int64) {
	item.ParentId = v
	item.FieldsMask |= 1 << 2
}
func (item *TracingTraceContext) ClearParentId() {
	item.ParentId = 0
	item.FieldsMask &^= 1 << 2
}
func (item *TracingTraceContext) IsSetParentId() bool { return item.FieldsMask&(1<<2) != 0 }

func (item *TracingTraceContext) SetSourceId(v string) {
	item.SourceId = v
	item.FieldsMask |= 1 << 3
}
func (item *TracingTraceContext) ClearSourceId() {
	item.SourceId = ""
	item.FieldsMask &^= 1 << 3
}
func (item *TracingTraceContext) IsSetSourceId() bool { return item.FieldsMask&(1<<3) != 0 }

func (item *TracingTraceContext) SetReservedStatus0(v bool) {
	if v {
		item.FieldsMask |= 1 << 0
	} else {
		item.FieldsMask &^= 1 << 0
	}
}
func (item *TracingTraceContext) IsSetReservedStatus0() bool { return item.FieldsMask&(1<<0) != 0 }

func (item *TracingTraceContext) SetReservedStatus1(v bool) {
	if v {
		item.FieldsMask |= 1 << 1
	} else {
		item.FieldsMask &^= 1 << 1
	}
}
func (item *TracingTraceContext) IsSetReservedStatus1() bool { return item.FieldsMask&(1<<1) != 0 }

func (item *TracingTraceContext) SetReservedLevel0(v bool) {
	if v {
		item.FieldsMask |= 1 << 4
	} else {
		item.FieldsMask &^= 1 << 4
	}
}
func (item *TracingTraceContext) IsSetReservedLevel0() bool { return item.FieldsMask&(1<<4) != 0 }

func (item *TracingTraceContext) SetReservedLevel1(v bool) {
	if v {
		item.FieldsMask |= 1 << 5
	} else {
		item.FieldsMask &^= 1 << 5
	}
}
func (item *TracingTraceContext) IsSetReservedLevel1() bool { return item.FieldsMask&(1<<5) != 0 }

func (item *TracingTraceContext) SetReservedLevel2(v bool) {
	if v {
		item.FieldsMask |= 1 << 6
	} else {
		item.FieldsMask &^= 1 << 6
	}
}
func (item *TracingTraceContext) IsSetReservedLevel2() bool { return item.FieldsMask&(1<<6) != 0 }

func (item *TracingTraceContext) SetDebugFlag(v bool) {
	if v {
		item.FieldsMask |= 1 << 7
	} else {
		item.FieldsMask &^= 1 << 7
	}
}
func (item *TracingTraceContext) IsSetDebugFlag() bool { return item.FieldsMask&(1<<7) != 0 }

func (item *TracingTraceContext) Reset() {
	item.FieldsMask = 0
	item.TraceId.Reset()
	item.ParentId = 0
	item.SourceId = ""
}

func (item *TracingTraceContext) FillRandom(rg *basictl.RandGenerator) {
	var maskFieldsMask uint32
	maskFieldsMask = basictl.RandomUint(rg)
	item.FieldsMask = 0
	if maskFieldsMask&(1<<0) != 0 {
		item.FieldsMask |= (1 << 0)
	}
	if maskFieldsMask&(1<<1) != 0 {
		item.FieldsMask |= (1 << 1)
	}
	if maskFieldsMask&(1<<2) != 0 {
		item.FieldsMask |= (1 << 2)
	}
	if maskFieldsMask&(1<<3) != 0 {
		item.FieldsMask |= (1 << 3)
	}
	if maskFieldsMask&(1<<4) != 0 {
		item.FieldsMask |= (1 << 4)
	}
	if maskFieldsMask&(1<<5) != 0 {
		item.FieldsMask |= (1 << 5)
	}
	if maskFieldsMask&(1<<6) != 0 {
		item.FieldsMask |= (1 << 6)
	}
	if maskFieldsMask&(1<<7) != 0 {
		item.FieldsMask |= (1 << 7)
	}
	item.TraceId.FillRandom(rg)
	if item.FieldsMask&(1<<2) != 0 {
		item.ParentId = basictl.RandomLong(rg)
	} else {
		item.ParentId = 0
	}
	if item.FieldsMask&(1<<3) != 0 {
		item.SourceId = basictl.RandomString(rg)
	} else {
		item.SourceId = ""
	}
}

func (item *TracingTraceContext) Read(w []byte) (_ []byte, err error) {
	if w, err = basictl.NatRead(w, &item.FieldsMask); err != nil {
		return w, err
	}
	if w, err = item.TraceId.Read(w); err != nil {
		return w, err
	}
	if item.FieldsMask&(1<<2) != 0 {
		if w, err = basictl.LongRead(w, &item.ParentId); err != nil {
			return w, err
		}
	} else {
		item.ParentId = 0
	}
	if item.FieldsMask&(1<<3) != 0 {
		if w, err = basictl.StringRead(w, &item.SourceId); err != nil {
			return w, err
		}
	} else {
		item.SourceId = ""
	}
	return w, nil
}

func (item *TracingTraceContext) WriteGeneral(w []byte) (_ []byte, err error) {
	return item.Write(w), nil
}

func (item *TracingTraceContext) Write(w []byte) []byte {
	w = basictl.NatWrite(w, item.FieldsMask)
	w = item.TraceId.Write(w)
	if item.FieldsMask&(1<<2) != 0 {
		w = basictl.LongWrite(w, item.ParentId)
	}
	if item.FieldsMask&(1<<3) != 0 {
		w = basictl.StringWrite(w, item.SourceId)
	}
	return w
}

func (item *TracingTraceContext) ReadBoxed(w []byte) (_ []byte, err error) {
	if w, err = basictl.NatReadExactTag(w, 0xc463a95c); err != nil {
		return w, err
	}
	return item.Read(w)
}

func (item *TracingTraceContext) WriteBoxedGeneral(w []byte) (_ []byte, err error) {
	return item.WriteBoxed(w), nil
}

func (item *TracingTraceContext) WriteBoxed(w []byte) []byte {
	w = basictl.NatWrite(w, 0xc463a95c)
	return item.Write(w)
}

func (item TracingTraceContext) String() string {
	return string(item.WriteJSON(nil))
}

func (item *TracingTraceContext) ReadJSON(legacyTypeNames bool, in *basictl.JsonLexer) error {
	var propFieldsMaskPresented bool
	var propTraceIdPresented bool
	var propParentIdPresented bool
	var propSourceIdPresented bool
	var trueTypeReservedStatus0Presented bool
	var trueTypeReservedStatus0Value bool
	var trueTypeReservedStatus1Presented bool
	var trueTypeReservedStatus1Value bool
	var trueTypeReservedLevel0Presented bool
	var trueTypeReservedLevel0Value bool
	var trueTypeReservedLevel1Presented bool
	var trueTypeReservedLevel1Value bool
	var trueTypeReservedLevel2Presented bool
	var trueTypeReservedLevel2Value bool
	var trueTypeDebugFlagPresented bool
	var trueTypeDebugFlagValue bool

	if in != nil {
		in.Delim('{')
		if !in.Ok() {
			return in.Error()
		}
		for !in.IsDelim('}') {
			key := in.UnsafeFieldName(true)
			in.WantColon()
			switch key {
			case "fields_mask":
				if propFieldsMaskPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("tracing.traceContext", "fields_mask")
				}
				if err := Json2ReadUint32(in, &item.FieldsMask); err != nil {
					return err
				}
				propFieldsMaskPresented = true
			case "trace_id":
				if propTraceIdPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("tracing.traceContext", "trace_id")
				}
				if err := item.TraceId.ReadJSON(legacyTypeNames, in); err != nil {
					return err
				}
				propTraceIdPresented = true
			case "parent_id":
				if propParentIdPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("tracing.traceContext", "parent_id")
				}
				if err := Json2ReadInt64(in, &item.ParentId); err != nil {
					return err
				}
				propParentIdPresented = true
			case "source_id":
				if propSourceIdPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("tracing.traceContext", "source_id")
				}
				if err := Json2ReadString(in, &item.SourceId); err != nil {
					return err
				}
				propSourceIdPresented = true
			case "reserved_status_0":
				if trueTypeReservedStatus0Presented {
					return ErrorInvalidJSONWithDuplicatingKeys("tracing.traceContext", "reserved_status_0")
				}
				if err := Json2ReadBool(in, &trueTypeReservedStatus0Value); err != nil {
					return err
				}
				trueTypeReservedStatus0Presented = true
			case "reserved_status_1":
				if trueTypeReservedStatus1Presented {
					return ErrorInvalidJSONWithDuplicatingKeys("tracing.traceContext", "reserved_status_1")
				}
				if err := Json2ReadBool(in, &trueTypeReservedStatus1Value); err != nil {
					return err
				}
				trueTypeReservedStatus1Presented = true
			case "reserved_level_0":
				if trueTypeReservedLevel0Presented {
					return ErrorInvalidJSONWithDuplicatingKeys("tracing.traceContext", "reserved_level_0")
				}
				if err := Json2ReadBool(in, &trueTypeReservedLevel0Value); err != nil {
					return err
				}
				trueTypeReservedLevel0Presented = true
			case "reserved_level_1":
				if trueTypeReservedLevel1Presented {
					return ErrorInvalidJSONWithDuplicatingKeys("tracing.traceContext", "reserved_level_1")
				}
				if err := Json2ReadBool(in, &trueTypeReservedLevel1Value); err != nil {
					return err
				}
				trueTypeReservedLevel1Presented = true
			case "reserved_level_2":
				if trueTypeReservedLevel2Presented {
					return ErrorInvalidJSONWithDuplicatingKeys("tracing.traceContext", "reserved_level_2")
				}
				if err := Json2ReadBool(in, &trueTypeReservedLevel2Value); err != nil {
					return err
				}
				trueTypeReservedLevel2Presented = true
			case "debug_flag":
				if trueTypeDebugFlagPresented {
					return ErrorInvalidJSONWithDuplicatingKeys("tracing.traceContext", "debug_flag")
				}
				if err := Json2ReadBool(in, &trueTypeDebugFlagValue); err != nil {
					return err
				}
				trueTypeDebugFlagPresented = true
			default:
				return ErrorInvalidJSONExcessElement("tracing.traceContext", key)
			}
			in.WantComma()
		}
		in.Delim('}')
		if !in.Ok() {
			return in.Error()
		}
	}
	if !propFieldsMaskPresented {
		item.FieldsMask = 0
	}
	if !propTraceIdPresented {
		item.TraceId.Reset()
	}
	if !propParentIdPresented {
		item.ParentId = 0
	}
	if !propSourceIdPresented {
		item.SourceId = ""
	}
	if propParentIdPresented {
		item.FieldsMask |= 1 << 2
	}
	if propSourceIdPresented {
		item.FieldsMask |= 1 << 3
	}
	if trueTypeReservedStatus0Presented {
		if trueTypeReservedStatus0Value {
			item.FieldsMask |= 1 << 0
		}
	}
	if trueTypeReservedStatus1Presented {
		if trueTypeReservedStatus1Value {
			item.FieldsMask |= 1 << 1
		}
	}
	if trueTypeReservedLevel0Presented {
		if trueTypeReservedLevel0Value {
			item.FieldsMask |= 1 << 4
		}
	}
	if trueTypeReservedLevel1Presented {
		if trueTypeReservedLevel1Value {
			item.FieldsMask |= 1 << 5
		}
	}
	if trueTypeReservedLevel2Presented {
		if trueTypeReservedLevel2Value {
			item.FieldsMask |= 1 << 6
		}
	}
	if trueTypeDebugFlagPresented {
		if trueTypeDebugFlagValue {
			item.FieldsMask |= 1 << 7
		}
	}
	// tries to set bit to zero if it is 1
	if trueTypeReservedStatus0Presented && !trueTypeReservedStatus0Value && (item.FieldsMask&(1<<0) != 0) {
		return ErrorInvalidJSON("tracing.traceContext", "fieldmask bit fields_mask.0 is indefinite because of the contradictions in values")
	}
	// tries to set bit to zero if it is 1
	if trueTypeReservedStatus1Presented && !trueTypeReservedStatus1Value && (item.FieldsMask&(1<<1) != 0) {
		return ErrorInvalidJSON("tracing.traceContext", "fieldmask bit fields_mask.0 is indefinite because of the contradictions in values")
	}
	// tries to set bit to zero if it is 1
	if trueTypeReservedLevel0Presented && !trueTypeReservedLevel0Value && (item.FieldsMask&(1<<4) != 0) {
		return ErrorInvalidJSON("tracing.traceContext", "fieldmask bit fields_mask.0 is indefinite because of the contradictions in values")
	}
	// tries to set bit to zero if it is 1
	if trueTypeReservedLevel1Presented && !trueTypeReservedLevel1Value && (item.FieldsMask&(1<<5) != 0) {
		return ErrorInvalidJSON("tracing.traceContext", "fieldmask bit fields_mask.0 is indefinite because of the contradictions in values")
	}
	// tries to set bit to zero if it is 1
	if trueTypeReservedLevel2Presented && !trueTypeReservedLevel2Value && (item.FieldsMask&(1<<6) != 0) {
		return ErrorInvalidJSON("tracing.traceContext", "fieldmask bit fields_mask.0 is indefinite because of the contradictions in values")
	}
	// tries to set bit to zero if it is 1
	if trueTypeDebugFlagPresented && !trueTypeDebugFlagValue && (item.FieldsMask&(1<<7) != 0) {
		return ErrorInvalidJSON("tracing.traceContext", "fieldmask bit fields_mask.0 is indefinite because of the contradictions in values")
	}
	return nil
}

// This method is general version of WriteJSON, use it instead!
func (item *TracingTraceContext) WriteJSONGeneral(w []byte) (_ []byte, err error) {
	return item.WriteJSONOpt(true, false, w), nil
}

func (item *TracingTraceContext) WriteJSON(w []byte) []byte {
	return item.WriteJSONOpt(true, false, w)
}
func (item *TracingTraceContext) WriteJSONOpt(newTypeNames bool, short bool, w []byte) []byte {
	w = append(w, '{')
	backupIndexFieldsMask := len(w)
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"fields_mask":`...)
	w = basictl.JSONWriteUint32(w, item.FieldsMask)
	if (item.FieldsMask != 0) == false {
		w = w[:backupIndexFieldsMask]
	}
	w = basictl.JSONAddCommaIfNeeded(w)
	w = append(w, `"trace_id":`...)
	w = item.TraceId.WriteJSONOpt(newTypeNames, short, w)
	if item.FieldsMask&(1<<2) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"parent_id":`...)
		w = basictl.JSONWriteInt64(w, item.ParentId)
	}
	if item.FieldsMask&(1<<3) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"source_id":`...)
		w = basictl.JSONWriteString(w, item.SourceId)
	}
	if item.FieldsMask&(1<<0) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"reserved_status_0":true`...)
	}
	if item.FieldsMask&(1<<1) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"reserved_status_1":true`...)
	}
	if item.FieldsMask&(1<<4) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"reserved_level_0":true`...)
	}
	if item.FieldsMask&(1<<5) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"reserved_level_1":true`...)
	}
	if item.FieldsMask&(1<<6) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"reserved_level_2":true`...)
	}
	if item.FieldsMask&(1<<7) != 0 {
		w = basictl.JSONAddCommaIfNeeded(w)
		w = append(w, `"debug_flag":true`...)
	}
	return append(w, '}')
}

func (item *TracingTraceContext) MarshalJSON() ([]byte, error) {
	return item.WriteJSON(nil), nil
}

func (item *TracingTraceContext) UnmarshalJSON(b []byte) error {
	if err := item.ReadJSON(true, &basictl.JsonLexer{Data: b}); err != nil {
		return ErrorInvalidJSON("tracing.traceContext", err.Error())
	}
	return nil
}
